Math.random()*10;	生成随机数*10，就是生成10以内不包括10，从0开始。


JDK文件解析：
	java安装bin目录下有很多可执行文件。
	java：是jvm，运行java程序就是启动jvm，然后可以让jvm执行指定的编译后的代码。
	javac：是java编译器，用于将java源码文件(.java后缀的文件)编译为java字节码文件(.class结尾)。
	jar：用于将一组.class文件打包成一个.jar文件，便于发布。
	javadoc：用于从java源码中自动提取注释并生成文档。
	jdb：java调试器，用于开发阶段的运行调试。

使用cmd运行java文件：
	创建一个文本文件写个类，类名和文件名一致，文件后缀改为java。
	先用javac将java文件编译成class字节码文件，然后使用java命令执行字节码文件
	Hello.java  >>compile>>  Hello.class  >>execute>>  Run on JVM
	source code	   (编译)	   byte code	 (执行)
	(源码文件)				  (字节码文件)
	
	可执行文件javac是编译器，可执行文件java是虚拟机。
	在保存java文件下打开cmd窗口，
	javac Hello.java	编译java文件，将java编译成class
	java  Hello.class	执行class文件
	以上步骤是必须的，但是在java11后加入了新的功能，可以运行单个文件源码了！
	也就是说可以直接运行java了，不需要使用javac编译成class文件了。
	但是在实际项目中很少有不依赖第三方库的java源码，大多情况下无法直接运行java源码文件，因为它需要以来其他的库。
	定义类的时候可以不写public也能正常编译，但是此类无法从命令行执行。
	java入口规定方法必须是静态的，方法名必须为main，括号内参数必须是String数组。

常用注释：
	单行注释：//
	多行注释：/*开头    */结尾
	特殊多行：/**   	*/结尾，中间每行以*开头
	
	
注：代码是按顺序执行的！！！	
	
java規定：
	类名以大写开头，方法名小写开头驼峰规则。
	public为访问修饰符，static是修饰符。
	方法上加上DOTO是等待后续修改或编写的方法。

基本数据类型：
	整数类型：byte、short、int、long
	浮点类型：float、double
	字符类型：char
	布尔类型：boolean
	计算机内存最小储存单元是字节(byte)，一个字节是一个8位二进制数，即8个bit(位)。
	它的二进制表示范围从00000000~11111111，换算成十进制0~255，换算成十六进制是00~ff。
	(身为数学渣子的我，从廖老师网站搬过来的)
	
	内存单元从0开始编号，称为内存地址，每个内存单元可看作是一间房间，内存地址是门牌号。
	一个字节是1byte，1024字节是1k，1024k是1m，1024m是1g，1024g是1t，一个拥有4t内存的计算机字节数量：
	4T = 4 x 1024G；
	   = 4 x 1024 x 1024M；
	   = 4 x 1024 x 1024 x 1024K；
	   = 4 x 1024 x 1024 x 1024 x 1024；
	   = 4398046511104；
	
	不同数据类型占用的字节也不一样：
	byte   	1	  整型
	short  	2	  整型
	char   	2	  字符型
	float  	4	  浮点
	int	   	4	  整型
	long   	8	  整型
	double 	8	  布尔
	因为不了解数学，一下只做了解：
		java定义的带符号的整型。最高位的bit表示符号位(0位正，1为负)
		浮点类型是小数，因为小数点可以向前或向后浮动，所以称为浮点，对于float浮点类型数值后需加上f，如1.33f。
		布尔只有true和false两个值，数值比较运算也可替代true和false如：false1=1>2	true=1<2。
		char只能保存一个字符使用单引号''。
		String字符串引用类型使用双引号""。
		引用类型类似C语言的指针，内部存储一个地址，指向某个对象在内存中的位置涉及类和数据库(数据库学的细碎后面再说)。
		常量需要在变量前加上final修饰符，常量名通常全部大写，常量值是不能被改变的，枚举enum相似，只是枚举定义的是类。
	
	var关键字：有事类型名过长可将变量的类型写为var：var s = new Shool(); 效果等同于  shool s = new shool();
			   因为编译器会根据赋值语句自动推断变量的类型。
	变量存在作用域即作用范围，在同一个或同一个中的{}花括号中生效，如果超出范围，编译器会报错。
	
	整数运算：
		java的整数遵循四则运算规则，可以任意嵌套小括号，括号内优先运算。
			
		自增减：++n的话表示先加1再引用n，n++则相反是先引用再加1。
		移位运算二进制中，左移是乘2，右移是除2。
		位运算：
			&：相同为1，不同为0。
			|：任意为1，结果为1。
			~：0，1互换，输入0时结果为1，反之亦然。
			^：两个数值不同为1，否则为0。
		运算符优先级：
					()
					! ~ ++ --
					* / %
					+ -
					<< >> >>>
					&
					|
					+= -= *= /=
		
		注意++写在前面和后面计算结果是不同的，++n表示先加1再引用n，n++表示先引用n再加1。
		不建议把++运算混入到常规运算中，容易自己把自己搞懵了。(搬运廖老师的原话，谁做项目写++n，n++的钻简直牛角尖，虽然是因为我不会)。
		自动类型转换发生在字节低转为字节高。
		强制类型转换字节高转为字节低，但是字节高转为字节低时会损失精度，导致结果不准确。
	浮点数运算：
		浮点数只能做加减乘除运算，不能做位运算和移位运算。
		浮点数虽然范围大但是常常无法精准表示。
		0.1在计算机中无法精确表示，因为十进制0.1转成二进制时无限循环小数。
		如果小数强转为整数类型的话，小数.后的值会被舍弃如，12.3和12.7皆为12。
		整数和浮点进行运算的时候整数自动转为浮点类型。
	布尔运算：
		只有true和false	；
			比较运算符：>，>=，<，<=，==，!=
			与运算 &&
			或运算 ||
			非运算 !
		关系运算符的优先级从高到低依次是：
			!
			>，>=，<，<=
			==，!=
			&&
			||
		布尔里有一种短路运算：
			x1 && x1 如果x1为false时x2不再进行运算，第一个值为false时不再进行运算直接返回false。
			如果x1为true时，第二个值错误不能进行运算时，会报错，这样来说短路也相当于是一种保护机制。
		三元运算符：
			表达式：成功？失败
			意思是如果a>b的话，就显示：后的语句，如果a<b的话就显示？后的语句。
	字符和字符串：
		字符时基本数据类型，是charrcter的缩写，保存一个unicode字符。
		查看字符在unicode中的编码只需要将char赋值给int即可。
		字符串常见的转义字符：
			\" 表示字符"
			\' 表示字符'
			\\ 表示字符\
			\n 表示换行符
			\r 表示回车符
			\t 表示Tab
			\u#### 表示一个Unicode编码的字符
			可以使用+将多个""进行连接效果和一个""一样
			如果使用+连接字符串和其他数据类型会将其他数据类型自动转为字符串再进行连接。
		从java13开始使用"""...."""表示多行字符串和/*...*/效果差不多。
		而且字符串是不可变的，变的是指向：
			如果创建了两个s字符串
				String s = "aa";
				String s = "bb";
				会在内存中创建两个变量aa和bb，s只是一个指针的效果，s="aa";时候虚拟机创建了aa字符串，
				然后用变量s指向它，第二次s="bb";时虚拟机创建bb并且s指向它。
				当然如果a="aa";已经创建aa变量了，b="aa";时b也只是去内存中指定了aa而已，也就是说aa在内存中只创建了一次。
			null和""是有区别的，null是没有值，"是为空的有效字符串。
	数组：
		数组可以是值类型或引用类型，但是数组本身是引用类型。
		多个相同的数据类型可以使用数组进行保存。
		int [] name = new int[2]; 第二个[]中的数字为数组的个数，数组下标为0,并且规定几个必须创建几个。
		name[0] = 1;
		name[1] = 2;
		name.length使用此语法获取数组大小。
		name[1]查看下标为1的数据，输入几查看几。
		int [] name = new int [] {1,2,3,4}; 使用此方式不用指定数组大小，输入保存的数据编译器自动推算数组大小。
		int [] name = {1,2,3,4}; 这是最简洁的创建数组方式。
		
流程控制：
	System.out表示输出流	System.in表示输入流
	语句从上到下按顺序执行。
	输出语句：System.out.print();	输出后不换行。
			  System.out.println(); 输出后换行。
			  ecplise中输入sout和sys使用alt+/快捷键快速生成。
			  占位符	说明
				%d		格式化输出整数
				%x		格式化输出十六进制整数
				%f		格式化输出浮点数
				%e		格式化输出科学计数法表示的浮点数
				%s		格式化字符串
	输入：先创建Scanner对象。
		Scanner scanner = new Scanner(System.in);
		scanner.nextLine();		输入字符串
		scanner.nextInt();		输入整数
	
	switch语句：使用多重if判断的话，switch更加清晰。
		switch(){
		case 1:
			break;
		case 2:
			break;
		default:
		}
		如值=1就进入第一层，因为case具有穿透性，不写break的话，会将下一层也输出，如果下一层也没break，就滚雪球了。
		default是默认值，case的顺序不影响逻辑。
		switch条件值也可以是字符串或者枚举。
		从java12开始switch语句更加简洁化，使用模式匹配保证只有一条路径会被执行，并且不需要break。
		switch(标准值){
			case "条件值" -> 语句 ;
			case "条件值" -> 语句 ;
			case "条件值" -> {语句 };
			default ->	语句;
		}
		以上是java12后的语句，如果写逻辑判断等有多个语句的话可用{}进行扩盖，并且新语法使用->。
		可以将swithc的值作为变量进行设置int xx = switch(){}
		可以case"123","312"使用,设置多个条件。可以使用yield返回一个值作为返回值。
	while循环：根据条件做循环就按，条件满足时退出循环
		while(条件表达式){
			循环语句
			值++；
		}
		开始时先判断条件表达式，如果位true就运行，false就终止跳出while循环。
		while必须在最底层使用条件值++，否则无限循环
	do{
		语句;
		值++;
	}while(条件表达式);
	dowhile较while不同，
	while先判断再执行，dowhile先执行再判断。
	
	for循环：最便利的循环之一，在每次循环后更新计数器计数器通常为1不需要写n++。
		for(int i=0; i<=100; i++){
			i<=100是条件；
			i++;是自增；
			int i=0;声明一个计数器并指定默认值；
		}
		对计数器变量的修改尽量在for循环中。
	for each使用此循环遍历数组,也能遍历输出map，list等集合。
		int [] a={1,3,5,7,9};
		for(int b : a){
			 System.out.println(b);
		}
		
		for循环可以访问数组索引，for each直接迭代每个数组元素，无法获取索引。
		
		在while和for中都能使用break和comtinue语句(switch也能用)
		在循环中判断加上break，当数值到达xx时就break，
		注意break只挑出当前那层循环，如果有两层在最里层加上break，就是跳出里层循环，外层循环不会结束。
		comtinue提前结束本次循环，comtinue后的语句不执行，然后继续循环。
	
数组：Arrays.toString(数组名);快速打印数组内容
	  Arrays.sort(数组名);对数组进行排序，但实际上时修改了数组本身。
	冒泡排序的特点，每一轮循环结束后，最大的一位被交换到末尾，so下一轮就可以忽略最后的数，
	每一轮循环都比上一轮循环结束位置靠前一位。
	for(int i=0;i < ns.length - 1;i++){
		for(int j=0;j < ns.length-i-1;j++){
			if(ns[j] > ns[j+1]){
				int tmp = ns[j];
				ns[j] = ns[j+1];
				ns[j+1] = tmp;
			}
		}
    }这是冒泡排序的例子，降序只需要将if中的>换成<。
	还有二维数组：
		int[][] ns = {
            { 1, 2, 3, 4 },
            { 5, 6, 7, 8 },
            { 9, 10, 11, 12 }
        };酱紫的，二维数组要使用两个[][]，使用，隔开每个数组
		查看特定数组的某位数时ns[0][0]，意思是下标为0的数组中下标为0的数字。
		二维数组.length时显示的是二维数组的长度。
		ns[0].length查看下标为0数组的长度。
		Arrays.deepToString();能打印二位数组。
		还有一种三维数组，就是二维数组的数组。
		int[][][] ns = {
			{
				{1, 2, 3},
				{4, 5, 6},
				{7, 8, 9}
			},
			{
				{10, 11},
				{12, 13}
			},
			{
				{14, 15, 16},
				{17, 18}
			}
		};
	

命令行参数：
	程序入口时main方法，main方法可以接受一个命令行参数，它是String[]数组，此命令行由jvm接受用户输入传给main方法。


面向百度编程：
	class(类)
	instance(实例、类)
	method(方法)
	field(字段)
	面向过程编程：将模型分解成一步一步的过程，比如洗一个TODO任务：
					1.读取文件
					2.编写TODO
					3.保存文件
	面向对象编程：通过对象的方式，将现实世界映射到计算机模型的一种编程方式。
					基本概念：类、实例、方法。
					面向对象实现方式：继承、多态。
					java本身提供机制：package、classpath、jar。
					java标准库提供核心类：字符串、包装类型、javabean、枚举、常用工具类。
	
				类定义的是一种抽象的概念，如电脑是类，那么和电脑相关的实例都可放在其中。
				面向对象主要就是class(类)和instance(实例、对象)
				class是对象模板，定义如何创建实例，so，class本身就是一种数据类型。
				instance是对象实例，instance是根据class1创建的实例，可以创建多个instance，每个instance类型相同，但属性可能不同。
				
				将一组数据汇聚到对象上就是数据封装。
				Student s = new Student();
				创建了一个实例，通过变量s指向它，Studnet s是创建student的变量s，new Student()是创建实例。
				有了这个实例就能通过变量操作实例，s.字段。来使用studnet中封装的字段。
				如果实例类型一样，变量名不一样那么在调用字段的时候在内存中有独立的空间，互不干扰。
				指向instance的变量都是引用变量。
	方法：一个class可以含多个field，如果field使用public修饰暴露给外部会破坏封装性。
			可以使用private进行修饰拒绝外部访问，private是私密的，public是公用的。
			使用private的话，可用get、set方法让外部获取字段，外部用过调用get方法获取字段，set方法修改字段。
			也可以在set中加上判断，对输入值进行判断是否符合条件使输入值更加严谨。
		定义方法语句：
			修饰符 方法返回类型 方法名(方法参数列表) {
				若干方法语句;
				return 方法返回值;
			}	没有特定情况下可省略return。
			可以在其中的方法封装一个类的对外接口，调用方不需要也不用关心实例的方法中做了什么操作。
			
		在方法中可使用一个隐含变量this，它始终指向当前实例，so，通过this.field就能访问当前所在实例的字段。
		若没有命名冲突就可省略this，如歌有局部变量和字段冲突，那么局部变量优先级更高，必须加上this。
		
		方法参数：
			方法可以报包含多个参数，方法参数用于接收传递给方法的变量值，调用方法时，必须严格按照参数设定的定义传递。
		
		可变参数：
			相当于数组类型public void setNames(String... names) ，那么调用的时候就可以写成，
			g.setNames("Xiao Ming", "Xiao Hong", "Xiao Jun")。
			所以完全可以将可变参数改为数组类型。
			
		参数绑定：
			调用方将参数传递给实例方法时，调用传递值会按照参数位置进行绑定。
			基本参数类型传递，调用方法值的复制，双方各自的后续修改互不影响。
			但引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一对象，
			双方任意一方对此对象的修改都会影响对方(因为指向的同一对象)。
			
	构造方法：
		在创建实例的时候就将内部字段全部初始化为合适的值。
		创建类的时候，默认创建一个隐式的类的构造方法，默认的构造方法是无参的没有返回值的。
		如果自定义一个构造方法那么编译器就不再创建默认构造方法，这个时候我们就要自己创建无参构造。
		因为如果你自定义有参构造，那么实例化对象的时候构造方法中没有参数就会报错。
		没有在构造方法中初始化字段时，应用类型字段默认null，int默认0，布尔默认false。
		可以设置多个不同参数的构造方法来对应不同的参数需求。
		一个构造方法可调用另一个构造方法，使用this()；
	
	
	继承(extends)：
		java中只允许单继承，但是可以无限单继承，a继承b继承c继承d.....依次类推。、
		java中创建的类会默认继承object类，object是没有父类的。
		b类继承另a类的时候，b能使用a类的方法和属性，增加程序扩展性，使用extends实现继承。
		b继承a时，b就拥有了a的所有功能，也能为b添加独有的功能。
		术语中被继承的类被称为：
			超类(super class)
			父类(parent class)
			基类(base class)
		继承的类又称为：
			子类(subclass)
			扩展类(extended class)
		但是子类中不能有和符类相同的字段。
		继承的特点是子类无法访问符类的private字段或private的方法。这样的话继承的作用就被削弱了。
		这样的话，就需要将private改为protected，被protected修饰的字段或方法可以被子类访问。
		
		如果说this表示本类的话，那么super就是表示父类。类加载时会先加载构造方法，super()表示父类构造方法。
		使用父类字段时super.，而且如果有父类的话会先加载父类的信息再加载子类的。
		
		向上转型(upcasting)：子类类型安全转为父类类型称为向上转型,向上转型时将子类类型安全地变为更加抽象的父类。
							子类 子 = new 父类();	向上转型
		向下转型(downcasting)：将父类类型强制转换为子类类型，为避免出错，java提供instanceof操作符。
							可以判断变量所指向的实例是否是指定类型或此类型的子类，如果引用变量为null，
							那么对让你和instanceof的判断都为false。
							父类 父 = new 子类();  or  父类 父 = (父) new 子类();
						从java14后判断instanceof后可直接转型为指定变量，避免再次强制转换。
	继承and组合(is and has):				
		不能继承没有is关系的类，但是可以使用组合，就是a(子)可以持有一个b的实例。
		组合是has的关系。
		如果父类不想子类对父类某些方法或字段进行重写，使用final进行修饰，被final修饰的是常量并且不能修改的。
		如果一个类不想被继承也可使用final进行修饰，被final修饰的不能被继承。
			final修饰符有多种作用：

			final修饰的方法可以阻止被覆写；

			final修饰的class可以阻止被继承；

			final修饰的field必须在创建对象时初始化，随后不可修改。
		
	重载(Overload)：
		一个类中一系列方法功能相同，参数不同，就可以及那个这组方法编程同名方法，即重载。
		方法名相同，参数不同，是为重载(Overload)。重载返回值通常相同。
		(个人感觉重载和创建多个构造方法差不多)
	重写(Override)：子类定义一个和父类方法名一样的方法，是重写(Override)。
		重写的话方法名、参数、返回值相同。
		
	多态：		
		多态指的是针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。
		多态特性是运行期才能动态决定调用的子类方法，针对某个类型调用某个方法，执行的实际方法可能是某个子类的重写方法。
		多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。
		Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；
		
	抽象类：
		父类方法本身不需要实现任何功能，只是为了定义方法签名，让子类进行实现，这就是抽象方法。
		抽象方法使用abstract进行修饰，类名也用abstract进行修饰。
		抽象方法本身的作用是定义一个规范，子类进行方法重写。
		子类继承抽象类，必须重写抽象类方法否则子类还是抽象类。
		抽象方法也使得程序扩展性更高，耦合性降低。
	
	面向抽象编程：
		面向抽象的本质是抽象类只定义规范。
		不需要子类就能实现业务逻辑。
		具体业务逻辑由不同子类进行实现，调用者不必关心是谁实现。
	
	接口(interface)：
		抽象类的本质是定义规范，保证所有子类都有相同的接口实现，从而体现多态。
		接口和抽象类的区别是：
			接口所有方法必须都是抽象方法，实现接口implements关键字。
			抽象类可以有抽象方法和普通方法，继承类extends关键字。
		接口中只能有抽象方法，只能！！！
		
		java只能继承一个类但是可以实现无数个接口。
		
		抽象类和接口的对比如下：
						abstract class			interface
			继承		只能extends一个class	可以implements多个interface
			字段		可以定义实例字段		不能定义实例字段
			抽象方法	可以定义抽象方法		可以定义抽象方法
			非抽象方法	可以定义非抽象方法		可以定义default方法
												default是默认方法将public改为default。
			
	术语：
		接口分java和编程：
			java接口是指interface中全是抽象方法的定义。
			编程接口是指接口规范，方法签名、数据格式、网络协议等。
	
	静态字段静态方法：
		static修饰字段或方法是为静态，静态字段只有一个共享空间，所有实例都会共享此字段。
									  普通字段都会有独立的空间，每个实例的同名字段互不影响。
		
		普通实例方法需要通过实例变量，调用静态方法则不需要，通过类名即可：类名.方法名。
		因为静态方法属于class，so静态方法内部无法访问this变量，也无法访问实例字段只能访问静态字段。
		静态方法常用于工具类：
			Arrays.sort();
			Math.random();
			也用于辅助类，如main();
		interface因为是抽象类不能定义实例字段，但可以有静态字段而且必须为final类型。
		
	包：
		jvm执行的时候，只看完整类名，so只要报名不同，类就不同。
		包作用域：
			位于同一包内，不用public、protected、private的字段和方法就是包作用域。
		import：在使用其他class时需要导入包路径，但是创建实例的时候大部分都已经自动生成了。
			·	如果import com.* 就是将这个包下所有class都导入进来。
		
	作用域：
		第一要点是，代码从上到下执行，第一行无法访问第二行的变量。
		不能直接访问不同类的变量等等。
	
	模块：
		.class是jvm看到最小可执行文件，大型程序需要很多class，不便管理，所以jar文件就是class的容器。
		java9之前开发程序时除了自己的app.jar还需要一堆第三方jar包。
		jvm自带的标准库rt.jar不能写到classpath中不然会干扰jvm正常运行，漏写了某个运行用到的jar，
		那么运行时可能抛出ClassNotFoundException，jar只是存放class的容器，并不关心class之间的依赖。
		java9开始引入模块，为了解决依赖的问题，如果a.jar必须依赖b.jar才能运行，应该给a.jar加点说明，让他
		再编译和运行的时候自动定位到b.jar,这种依赖关系的class容器就是模块。
		
		从java9开始java库将rt.jar拆分成几十个模块，以.jmod扩展名标识，在$JAVA_HOME/jmods目录下。
			每个.jmod都是一个模块，模块名就是文件名。如java.base就是java.base.jmod，模块之间的
			关系已经写到模块内的module-info.class文件，所有模块之间莫简介依赖java.base,但是它不
			依赖任何模块，可将它看作成根模块。
		将一堆class封装成jar需要打包，将class封装成模块不但要打包号要写入依赖关系。
		
		创建模块：
			如在src下创建module-info.java文件，这是模块描述文件
			运行java需要jar，jdk提供了jlink命令，只使用程序需要的jar：
				$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.w件是b明确导出可访问的包。
	
	orld --output jre/
			权限访问：
				class访问权限只在一个模块内有效，模块之间，a要访问b的某个class，必要条件是b明确的到处可访问的包。
				只有声明导出的包外部代码才允许访问。
				如想访问com.itranswarp.sample.Greeting必须导出(exports)exports com.itranswarp.sample;



Java核心类：
	字符串

	StringBuilder

	StringJoiner

	包装类型

	JavaBean

	枚举

	常用工具类
	
	字符串和编码：
		
		String：是引用类，本身也是class。编译器对其有特殊处理可用"..."表示一个字符串。
				在其内部是通过char[]数组显示的如下：
				String s = new String(new char[]{'h','e','l','l','o'});
				字符串最重要的特点就是字符串不变，是通过内部的private final char[]以及没有任何修改char[]方法实现的。
			比较：==一般表示数值，字符串比较必须使用equals()，忽略大小写使用equalsIgnoreCase()方法。
				
			提取、搜索子串：
				搜索："字符串".indexOf("串");	显示串的下标
				      "字符串串".lastIndexOf("串");		显示最后一个串的下标
					  "字符串".startsWith("字符");		判断是否从字符开始 返回布尔
					  "字符串".endWith("符串");			判断时候以符串结尾 返回布尔
					  
				提取："字符串".substring(下标); 提取指定下标及以后的字符。
					  "字符串".substring(1,2);  只提取1，2下标的字符。
	
			去除首位空白字符：
				使用trim()一处字符串首尾空字符,如:\t, \r, \n;
				trim()并没有改变字符串内容,二十返回一个新字符串。
				strip()也可以移除首位空字符,但是中文空格的\u3000也会被移除。
			判断是否为空：
				"".isEmpty();		空字符串返回true,否则为false如:"  "
				" \n".isBlank();	含空白字符串返回true否则false如:"hello"
			替换字符串：
				变量名.replace('e','a');		将变量中的所有e改为a
				正则表达式替换：
					String s = "A,,B;C ,D";
					s.replaceAll("[\\,\\;\\s]+", ","); // "A,B,C,D" 将匹配的子串统一替换为，。
			分割字符串：
				split()方法，传入正则表达式，如下：
					String s = "A,B,C,D";
					String[] ss = s.split("\\,"); // {"A", "B", "C", "D"}
			拼接字符串：
				join()静态方法进行拼接，如下：
					String[] arr = {"A", "B", "C"};
					String s = String.join("***", arr); // "A***B***C"

			格式化字符串：
				formatted()和format静态方法传入其他参数替换占位符生成新的字符串：
					String s = "Hi %s, your score is %d!";
					System.out.println(s.formatted("Alice", 80));
					System.out.println(String.format("Hi %s, your score is %.2f!", "Bob", 59.5));
				后面有几个占位符就传几个参数，参数类型要和占位符一致，如果不确定的话使用%s因为其可以显示任何数据类型。
					%s：显示字符串；
					%d：显示整数；
					%x：显示十六进制整数；
					%f：显示浮点数。
			类型转换：
				将任意基本类型或引用类型转换为字符串，使用静态方法valueOf(),这是重载方法，编译器会根据适合的参数选择合适的方法。
					String.valueOf(123);
					String.valueOf(23.23);
					String.valueOf(true);
					String.valueOf(new Object());
				将字符串转为其他类型需要根据实际情况：
					int n = Integer.parseInt("123");	int类型
					boolean b1 = Boolean.parseBoolean("true");  Boolean类型
					将字符串对应的系统变量转换为integer，Integer是int的包装类
						Integer.getInteger("java.version"); // 版本号，11
					string和char互相转换：
						char[] cs = "Hello".toCharArray(); // String -> char[]
						String s = new String(cs); // char[] -> String
	
				因为String的不变特性，如果传入对象可能改变，就需要复制而不是直接引用。
		
		字符编码：
			简介在这里：https://www.liaoxuefeng.com/wiki/1252599548343744/1260469698963456
			因为不同编码的字符集是不一样的，所以统一发布了Unicode编码，将主要语言统一就不会发生冲突了。
			UTF-8是容错力强传输过程中某些字符出错不影响后续字符，因为是靠高字节位确定字符是几个字节的，常用于传输编码。
				byte[] b1 = "Hello".getBytes(); // 按系统默认编码转换，不推荐
				byte[] b2 = "Hello".getBytes("UTF-8"); // 按UTF-8编码转换
				byte[] b2 = "Hello".getBytes("GBK"); // 按GBK编码转换
				byte[] b3 = "Hello".getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换
				以上转换编码后就变成byte类型了。
				将byte转为String：
					byte[] b = ...
					String s1 = new String(b, "GBK"); // 按GBK转换
					String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换
			注：java的String和char在内存中总是以Unicode表示。
	
		小结：
			java字符串String是不可变对象。
			字符串操作不改变原字符内容，而是返回新字符。
			常用的字符串操作：提取字符串、查找、替换、大小写转换等。
			java使用unicode编码表示string和char。
			转换编码就是将string和byte[]转换，需要指定编码。
			转为byte[]优先考虑UTF-8编码。
	
	StringBuilder：
		可以使用+拼接字符串但是用for循环拼接字符串的话，每次循环创建新的字符串，抛弃旧的
		大部分都是临时对象，浪费内存影响GC(垃圾回收)效率。
		可使用StringBuilder，可变对象可以预分配缓冲区，所以新增字符串时不会创建新的临时对象。
		(当然拼接的时候还是要使用for，只是将string类型改为StringBuilder类型罢了)
		也可以进行链式操作：
			var sb = new StringBuilder(1024);
				sb.append("Mr ")
				  .append("Bob")
				  .append("!")
				  .insert(0, "Hello, ");
			System.out.println(sb.toString());
		StringBuffer是java早期的StringBuilder线程安全版本，通过同步保证多个线程操作StringBuffer也是安全的，
		但是同步会让执行速度下降。
		StringBuilder和StringBuffer接口完全相同，现在没有必要使用StringBuffer。
	
	StringJoiner:
		new StringJoiner(",");就是遍历数组的时候中间值与值之间加上，号，在使用stringjoiner的变量.add添加值即可。
		如果需要在值首位添加数据new StringJoiner(",", "头", "尾");	toString();是转为string类型。
		不指定首尾时可用静态方法String.join()更方便，因为在内部使用StringJoiner拼接字符。
		String.join(",", 数组名);	自动进行拼接
		
		
	包装类：
		java数据类型两种：基本：byte、short、int、long、boolean、float、double、char
						  引用：所有class和interface类型。
			引用类型能为null，基本类型不行。
			将基本类型视为引用的话，用到包装类。
			以下时基本类型的包装类，所有的包装类都是不变类：
				boolean			java.lang.Boolean
				byte			java.lang.Byte
				short			java.lang.Short
				int				java.lang.Integer
				long			java.lang.Long
				float			java.lang.Float
				double 			java.lang.Double
				char			java.lang.Character
			
			int和integer是可以互换的，编译器自动在int和integer之间转型。
			直接将int变为integer的复制方式，为自动装箱(Auto Boxing)，integer转为int的就是自动拆箱(Auto Unboxing)。
			自动拆装箱只发生在编译阶段，是为了少写代码。但会影响代码执行效率，编译后的class严格区分基本和引用的。
			自动拆箱时可能报NullPointerException。
			
			包装类是引用类型比如integer所以比较时用equals()。
			integer不可变类，如设置了值为1，第二次在设置变量b=2，那么值还是1。此例子不标准
			integer.valueOf()对于较小的数，始终返回相同的实例所以==恰好为true。
			integer==为true是因为，valueof返回之前，进行判断当前的值是否在-128-127之间，
			如果存在就直接返回引用不用重新开辟空间，
			如果不存在就创建一个新对象，
			利用缓存提高车光绪执行效率节约内存，但是还是尽量使用equals进行数值比较。
			可能integer.valueof可能始终返回同一个integer实例，所以：
				Integer n = new Integer(数值);
				Integer n = Integer.valueOf(数值);
				第二个好一点因为第一个总是创建新的实例，而且第二个将内部优化留给integer实现者去做。
			能创建新对象的静态方法称为静态工厂方法。
			Integer.valueOf就是，它尽可能返回缓存实例以节省内存。
			创建新对象时，优先选用静态工厂而不是new操作符。
		进制转换：
			Integer的静态方法：
				parseInt()将字符串解析成一个整数
			将整数格式化成指定进制的字符串：
				Integer.toString(100); 			"100",表示为10进制
				Integer.toString(100, 36); 		"2s",表示为36进制
				Integer.toHexString(100);  		"64",表示为16进制
				Integer.toOctalString(100); 	"144",表示为8进制
				Integer.toBinaryString(100);  	"1100100",表示为2进制
			顺带一提String好像在内存中只用二进制显示。
			程序的重要原则就是数据存储和显示分离。
			整数和浮点的包装类型都继承自number，so可直接通过包装类型获取各种基本类型。
	
	JavaBean(组件):	
		封装实体类为了让外部访问设置值，而创造的getset方法，这种方法称为javabean。
		boolean比较特殊读方法get变成is(具体是get还是is根据情况来)
		ecplise的getset的快捷键：Shift+Alt+S；或者 右键Source里面的getset。
	枚举JavaBean属性：
		例如：
		BeanInfo info = Introspector.getBeanInfo(Person.class);
        for (PropertyDescriptor pd : info.getPropertyDescriptors()) {
            System.out.println(pd.getName());
            System.out.println("  " + pd.getReadMethod());
            System.out.println("  " + pd.getWriteMethod());
        }
		使用Introspector枚举javabean的所有属性以及读写方法。
		class属性是从object继承的getClass()方法的。
	
		小结：JavaBean是一种命名规范的class，用getset定义熟悉。
			  使用Introspector.getBeanInfo()可以获取属性列表。
	
	枚举类：
		枚举使用，进行分割如：a，b，c，d;
		enum是枚举类，枚举是类型，每个枚举类型是不一样的。
		枚举的好处是，不同枚举不能相互比较或赋值，因为类型不符。
		也就是说a枚举类复制称为b枚举类的值，a只能给a复制，因为枚举类型不一样所以会报类型错误。
		enum比较方式:
			enum是引用类型，但是比较不用equals而是用==因为，enum每个常量在jvm中只有一个唯一实例。
		enum类型：
			enum定义的枚举类和class没有任何区别，enum定义类型就是class只不过有几个特点：
				定义的enum总是继承java.lang.Enum并且无法被继承。
				只能定义出enum的实例，无法通过new创建enum实例。
				定义的每个实例都是应用类型的唯一实例。
				enum可用于switch语句。
		enum是一个class，每个枚举的值都是class实例，so实例有些方法：
			枚举类.枚举.name();		返回枚举名称。
			枚举类.枚举.ordinal();	返回定义的常量的顺序，从0开始。
			枚举类中是可以定义字段的(但是尽量定义常量的)。
			可以给每个枚举常量添加字段如：
				a(1),b(2),c(3),d(4);
				这样就不用担心顺序变化，新增枚举常量时要指定个int值。
			对枚举常量调用toString()会返回name()一样的字符串，但toString()可以被重写name()不行。
			判断枚举常量的名字必须使用name()绝不能调用toString()。
		因为枚举类天生的类型信息和有限个枚举常量，所以更适合switch语句。
			
		小结：
			enum定义枚举，编译器会编译为final class ClassName extends Enum{}。
			通过name()获取常量定义的字符串，不要使用toString()。
			可为enum编写构造方法、字段、方法。
			enum的构造方法要声明private，尽量使用final。
	
	记录类：
		String、Integer都是不变类，不变类的特点：
			定义class时使用final，无法派生子类。
			每个字段使用final，保证创建实例后无法修改任何字段。
		
		record(重新编码):
			java14后引入了Record类，类需要extends Record，定义语法是public record 方法名（）{}。
			使用record关键字可以一行写出一个不变类。
		
	BigLnteger：
		常用方法链接：https://blog.csdn.net/sobermineded/article/details/79299435
		java中，cpu原生提供整数最大范围是64位long型整数。使用long型整数可以直接通过cpu指令进行计算，速度非常快。
		java.math.BigInteger类用来表示任意大小整数，其内部用int[]数组模拟非常大的整数。
			BigInteger bi = new BigInteger("1234567890");
			System.out.println(bi.pow(5)); // 2867971860299718107233761438093672048294900000
		BigInteger做运算的时候只能用实例方法如+：
			BigInteger i1 = new BigInteger("1234567890");
			BigInteger i2 = new BigInteger("12345678901234567890");
			BigInteger sum = i1.add(i2); // 12345678902469135780
		和long相比，BiGInteger没有范围限制但是速度慢，可将BigTnteger转为long。
			BigInteger i = new BigInteger("123456789000");
			System.out.println(i.longValue()); // 123456789000
			System.out.println(i.multiply(i).longValueExact()); 
			// java.lang.ArithmeticException: BigInteger out of long range
		使用longValueExact()时，超出long范围后会抛出ArithmeticException。
		BigInteger和Integer、Long都是不可变类，也继承自number，Number定义转换为基本类的方法：
			转为byte：		byteValue()
			转为short：		shortValue()
			转为int:		intValue()
			转为long:		longValue()
			转为float: 		floatValue()
			转为double:		doubleValue()
		如果BigInteger表示范围超出了基本类型的范围，转换时丢失高位信息，结果不一定准确的。
		要准确的转换成基本类型，使用intValueExact()、longValueExact()等方法，转换时超出范围，
		直接抛出ArithmeticException异常。
		
	BigDecimal：
		和BigInteger类似，它可以表示任意大小且精度完全准确的浮点数。
		实例一个BigDecimal对象db：
			db.multiply(db);					如果值是3，那么就是3*3，multiply是乘。
			db.scale(db);						取浮点的小数。
			db.stripTrailingZeros();			去掉末尾的0，如果使用scale查看返回负数的话
												就是这个数是整数并且,-2就是就是两个0。
			指定精度：
				db.setScale(4,RoundingMode.HALF_UP)	四舍五入(看着语句的意思应该是向上取整)根据第一个值保留小数。
				db.setScale(4,RoundingMode.DOWN);	截断根据第一个值保留小数，此处保留4位小数。
			如果有两个bigdecimal对象1and2，那么创建一个该对象数组
				1.divideAndRemainder(2);	做出发的同时求余数
		在比较两个bigdecimal值时候相等时，使用equals()不但要求两个值相等还要求scale()相等。
		必须必须必须使用compareTo()比较，它根据两个值大小分别返回负、正数和0，分别表示> < =。
		源码中BigDecimal是通过BigInteger和scal表示的，BigInteger表示完整整数，scal表示小位数。
		当然了BitDeicmal也是继承自Number的，也是不可变对象。
		
		因为其表示精确的小数，常用于财务计算。
	
	常用工具类：
		Math：
			进行数学计算的类，提供大量的静态方法便于实现数学计算。
			求绝对值：
				Math.abs(-100);		整数and0绝对值是其本身，负数绝对值是它相反数。
			取最大最小：
				Math.max(10,1);		选取值中最大的
				Math.min(13.1,1.2);	选取值中最小的
			计算xy次方：
				Math.pow(2,10);		2的10次方=1024
			计算√x：	
				Math.sqrt(2); // 1.414...
			计算ex次方：
				Math.exp(2); // 7.389...
			计算以e为底的对数：
				Math.log(4); // 1.386..
			计算以10为底的对数：
				Math.log10(100); // 2
			三角函数：
				Math.sin(3.14); // 0.00159...
				Math.cos(3.14); // -0.9999...
				Math.tan(3.14); // -0.0015...
				Math.asin(1.0); // 1.57079...
				Math.acos(1.0); // 0.0
			Math还提供了几个数学常量：
				double pi = Math.PI; // 3.14159...
				double e = Math.E; // 2.7182818...
				Math.sin(Math.PI / 6); // sin(π/6) = 0.5
			生成一个随机数x，x的范围是0 <= x < 1：
				Math.random(); // 0.53907... 每次都不一样
				这个生成随机数的类型只能是double，例子：
					double a = Math.random();	现在的取值范围0，1
					double b = 10;
					double c = 30;
					double d = a*(c-b)+b; 	现在的取值范围是10-30的小数
					long e = (long) d;		使用类型的话e的取值范围就是10-30的整数
					Systom.out.println(d);
			Random：
				创建伪随机数，是指定一个初始的种子，产生的水机数序列是完全一样的。
				生成随机数的方法：
					nextInt()、nextLong()、nextFloat()、nextDouble()
					Random r = new Random();
					r.nextInt(); // 2071575453,每次都不一样
					r.nextInt(10); // 5,生成一个[0,10)之间的int
					r.nextLong(); // 8811649292570369305,每次都不一样
					r.nextFloat(); // 0.54335...生成一个[0,1)之间的float
					r.nextDouble(); // 0.3716...生成一个[0,1)之间的double
				SecureRandom:
					有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，
					而我们想要的是一个不可预测的安全的随机数，SecureRandom就是用来创建安全的随机数的：
					SecureRandom sr = new SecureRandom();
					System.out.println(sr.nextInt(100));
					密码学中，安全的随机数非常重要，不使用安全的伪随机数，所有加密体系都将被攻破，
					必须使用secureRandom产生安全的随机数。
					详情：https://www.liaoxuefeng.com/wiki/1252599548343744/1260473555087392
			
			Math：数据计算
			Random：生成伪随机数
			SecureRandom：生成安全的伪随机数

异常处理：
	
	java异常：
		值为int但输入String时会报数字形式错误异常 							NumberFormatExcrption
		程序像读取文件，但是计算机没有或者被删掉了报文件未被创建			FileNotFoundException	
		调用方法获知调用失败的信息：
			1.约定返回错误码：
				如：处理个文件返回0成功返回其他整数表示约定的错误码。
			2.语言层面上提供个异常处理机制：
				java内置了一套异常处理机制总是使用异常表示错误。
				异常是一种class，so本身带有类型信息。异常可以在任何地方抛出，但是要在上层捕获，
				这样就和方法调用分离了。
		如下是异常的继承关系：
					 ┌───────────┐
                     │  Object   │
                     └───────────┘
                           ▲
                           │
                     ┌───────────┐
                     │ Throwable │
                     └───────────┘
                           ▲
                 ┌─────────┴─────────┐
                 │                   │
           ┌───────────┐       ┌───────────┐
           │   Error   │       │ Exception │
           └───────────┘       └───────────┘
                 ▲                   ▲
         ┌───────┘              ┌────┴──────────┐
         │                      │               │
┌─────────────────┐    ┌─────────────────┐┌───────────┐
│OutOfMemoryError │... │RuntimeException ││IOException│...
└─────────────────┘    └─────────────────┘└───────────┘
                                ▲
                    ┌───────────┴─────────────┐
                    │                         │
         ┌─────────────────────┐ ┌─────────────────────────┐
         │NullPointerException │ │IllegalArgumentException │...
         └─────────────────────┘ └─────────────────────────┘
		Throwable是异常的根继承自object，他有两个体系：error和exception
		error表示严重错误，程序对此无能为力如：
			OutOfMemoryError：内存耗尽
			NoClassDefFoundError：无法加载某个Class
			StackOverflowError：栈溢出
		exception是运行时错误，可以被捕获并处理如：
			NumberFormatException：数值类型的格式错误
			FileNotFoundException：未找到文件
			SocketException：读取网络失败
		又或者是程序逻辑不对造成如：
			NullPointerException：对某个null的对象调用方法或字段
			IndexOutOfBoundsException：数组索引越界
		exception分两大类：
			1.RuntimeException及它的子类
			2.非RuntimeException（包括IOException、ReflectiveOperationException等等）
		java规定：
			必须捕获的异常包括Exception及其子类，不包括RuntimeException及其子类，这种类型称为Checked Exception。
			不需要捕获的异常，error及其子类，RuntimeException及其子类。
		
		捕获异常：
			通常使用try..catch语句，将可能异常的代码放到try{}下，使用catch捕获对应的exception及其子类。
			很多地方不捕获异常将会报错，捕获后将返回异常信息。
			
			方法定义的时候使用throws xx表示改方法可能抛出异常类型。调用方在调用的时候必须强制捕获否则编译报错。
			也就是说可见本类的异常进行抛出，但是其他类调用此类时必须强制捕获异常否则报错。
			如果不捕获的话可以一直throws 异常类型进行抛出。
			如果在main方法还是抛出后，那么一旦发生异常程序立刻退出。
			
			所有异常都能调用printStackTrace()方法打印异常栈，是一个简单有用快速打印异常的方法。
		
		结：
			Java使用异常来表示错误，并通过try ... catch捕获异常；

			Java的异常是class，并且从Throwable继承；

			Error是无需捕获的严重错误，Exception是应该捕获的可处理的错误；

			RuntimeException无需强制捕获，非RuntimeException（Checked Exception）需强制捕获，或者用throws声明；

			不推荐捕获了异常但不进行任何处理。
		
	捕获异常：
		多层catch语句：
			使用多个catch语句，每个分别捕获对应的exception及其子类。JVM捕获到异常后，会从上到下匹配catch语句，
			匹配到某个catch后执行catch代码，然后不再继续匹配。
			多个catch只有一个被执行，并且顺序很重要，子类写前否则就会被其他高级的异常类执行了。
		
		finally语句：
			无论发生什么都会运行finally下的代码，finally顺序在catch后面。
			finally不是必须的可写可不写，finally总是最后执行。
		
		捕获多种异常：
			某些异常处理逻辑相同，但是异常本身不存在继承关系，就得编写多条catch子句。
			
	抛出异常：
		异常传播：
			某方法抛出异常，当前方法没有抛出，异常就会被抛到上层调用方法，直到被try捕获为止。
			异常.printStackTrace()可以打印出方法的调用栈。
		抛出异常：
			发生错误时，如输入非法字符就可抛出异常。
			如果方法捕获异常后，又在carch中抛出新的异常，就相当于把抛出的异常类型转换了。
			捕获异常并抛出时，一定保留住原始异常否则很难定位第一案发现场。
			如果在catch中抛出异常那么，不会影响finally的运行，JVM会先执行finally然后抛出异常。
		异常屏蔽：
			如果执行finally时抛出异常，那么catch准备抛出的异常就消失了，so只能抛出一个异常，
			没有被抛出的被称为"被屏蔽"的异常(Suppressed Exception)。
			如果要获知所有异常先用Exception对象保存原始异常，后调用Throwable.addSuppressed(),
			把原始异常添加进来，最后在finally抛出。
		异常打印的详细的栈信息是找出问题的关键！
	
	自定义异常：
		Java标准库定义的常用异常包括：
			Exception
			│
			├─ RuntimeException
			│  │
			│  ├─ NullPointerException
			│  │
			│  ├─ IndexOutOfBoundsException
			│  │
			│  ├─ SecurityException
			│  │
			│  └─ IllegalArgumentException
			│     │
			│     └─ NumberFormatException
			│
			├─ IOException
			│  │
			│  ├─ UnsupportedCharsetException
			│  │
			│  ├─ FileNotFoundException
			│  │
			│  └─ SocketException
			│
			├─ ParseException
			│
			├─ GeneralSecurityException
			│
			├─ SQLException
			│
			└─ TimeoutException
		当我们在代码中需要抛出异常时，尽量使用JDK已定义的异常类型。例如，参数检查不合法，应该抛出IllegalArgumentException。
		大型项目可定义新的异常类型，保持合理的异常继承体系是很重要的，常见的作法是定义个BaseException作为根异常，
		从其派生出各种业务类型的异常
		
		如果期待的运行代码没有发生异常一定一定一定加上try。
		
	
	NullPointerException(空指针、NPE)：
		俗称NPE，如果一个对象为null，调用其方法或字段就会产生空指针，它通常是由JVM抛出的。
		指针源自c，java中没有指针。我们定义的变量实际上是引用，Null Pointer确切是Null Reference但两者区别不大。
		处理NullPointerException：
			首先，必须明确，处理空指针是种代码逻辑错误，原则上遇到早暴露、早修复，禁止使用catch隐藏编码错误：
				catch(NullPointerException e)这样的是禁止的。
		好的编码习惯可以极大降低空指针的产生，如声明变量为" "而不为null。
		
		java14新增的功能是空指针时显示报错详细信息，默认关闭，可给jvm添加参数启动：
			java -XX:+ShowCodeDetailsInExceptionMessages Main.java
			此命令的cmd窗口需要在项目文件下打开并保证和Main(也可以是其他需要运行类)处在同一级。
			但是经过我测试发现只能在cmd窗口运行命令才会有详细的报错信息，ecplise(ide开发环境)没有。
			
	断言(Assertion)：
		它是一种调试程序的方式，java中使用assert关键字实现断言。
		assert x => 0;	这是条件，如果条件成立则正常输出，否则抛出AssertionError。
		使用断言时可添加断言消息：assert x >=0 : "断言失败***"	
		断言失败AssertionError会带上断言失败**便于调试，在断言后面添加冒号，后加上断言消息即可。
		JVM是默认关闭断言指令，即使有assert关键字就自动忽略了。
		执行断言的话要在命令行输入如下命令：
			-ea:com.itranswarp.sample.Main
				ea是-enableassertions简写
				后面的路径是指定启用断言的类如果包路径后加上...不写类的话是再这个包启动断言。
		实际上很少使用断言，更好是编写单元测试。
		断言是一种调试方式，断言失败会抛出AssertionError，只能在开发和测试阶段启用断言。
	
	使用JDK Logging(日志)：
		程序结果与预期不符时可使用logging，用来代替输出语句。
			可以设置输出样式，避免自己每次都写"ERROR: " + var；
			可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；
			可以被重定向到文件，这样可以在程序运行结束后查看日志；
			可以按包名控制日志级别，只输出某些包打的日志；
			可以……
		日志会显示输出的详细信息如事件、类等等。
		使用方法是，先声明对象Logger l=Logger.getGlobal();用对象调用级别，如：
		l.fine("输出语句");
		日志定义了7个级别限制：
			SEVERE
			WARNING
			INFO
			CONFIG
			FINE
			FINER
			FINEST
			info是默认级别，其以下是不会打印出来的，好处是调整级别就可以屏蔽很多调试相关的日志输出。
			
		logging再jvm启动时读取配置文件完成初始化，一旦运行main()方法就无法修改配置。
		需要在JVM启动时传递参数-Djava.util.logging.config.file=<config-file-name>，uoyi
		java标准库内置的logging使用不广泛。
	
	使用Commons Logging(通用日志)：
		和logging不一样，它是第三方日志库，由Apache创建的日志模块。
		特色是，可以挂接不同的日志系统后通过配置文件指定挂接的日志系统，默认情况下，自动搜索并使用Log4j
		(另一个流行的日志系统)，如果没有找到log4j再使用JDK logging。
		
		第一步，通过LogFactory获取Log类的实例； 第二步，使用Log实例的方法打日志
			Log log = LogFactory.getLog(Main.class);
			log.info("start...");
			log.warn("end.");
		但是运行的时候会报找不到类的错误，因为它是第三方提供的，所以要提供个jar包(commons-logging-1.2.jar)，
		将jar和运行类放在同一文件下，打开命令行，先编译运行文件如：javac -cp commons-logging-1.2.jar Main.java
		编译成功后当前文件夹会多出个Main.class文件，
		然后执行Main文件：java -cp .;commons-logging-1.2.jar Main
		如果在Linux或macOS下运行：
						  java -cp .:commons-logging-1.2.jar Main
		上语句有部分：一个是.还有commons-logging-1.2.jar，使用;分割。
		.表示当前目录，没有它，JVM不会在当前目录搜索Main.class,就会报错。
		Commons Logging定义了6个日志级别(默认是info)：
			FATAL
			ERROR
			WARNING
			INFO
			DEBUG
			TRACE
		使用commons logging，在静态方法中引用log，通常定义个静态变量类型：
			  static final Log log = LogFactory.getLog(Main.class);
		实例方法中通常定义实例变量
			 protected final Log log = LogFactory.getLog(getClass());
		
		实例log获取方式有LogFactory.getLog(getClass());
						 LogFactory.getLog(当前类.getClass());
			第一个方式的好处是子类可以使用父类的log实例。
		
		由于java类动态特性，子类获取的log字段实际上相当于LogFactory.getLog(子类本类.class)，但却是从父类继承的，无需修改代码。
		日志方法除了info(String)，info是日志打印输出。
		还有重载方法info(String,Throwable)。
		log.error(String,exception)打印异常。
		Commons Logging是使用最广泛的日志模块；

		Commons Logging的API非常简单；

		Commons Logging可以自动检测并使用其他日志模块。
				
	
	使用Log4j：
		日志实现可以使用Log4j。它是一个组件化设计的日志系统，构造大致如下：
			log.info("User signed in.");
			 │
			 │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
			 ├──>│ Appender │───>│  Filter  │───>│  Layout  │───>│ Console  │
			 │   └──────────┘    └──────────┘    └──────────┘    └──────────┘
			 │
			 │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
			 ├──>│ Appender │───>│  Filter  │───>│  Layout  │───>│   File   │
			 │   └──────────┘    └──────────┘    └──────────┘    └──────────┘
			 │
			 │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
			 └──>│ Appender │───>│  Filter  │───>│  Layout  │───>│  Socket  │
				 └──────────┘    └──────────┘    └──────────┘    └──────────┘
		log4j输出一条日志时，它会自动通过不同的appender将同一条日志输出到不同目的地。
			console：输出到屏幕；
			file：输出到文件；
			socket：通过网络输出到远程计算机；
			jdbc：输出到数据库
		日志输出过程中通过filter过滤哪些log需被输出，哪些不需要，如：仅输出ERROR级别的日志。
		最后通过layout格式化日志信息，如自动添加日期、事件、方法名等信息。
		实际使用时并不关心它的api，而是通过配置文件进行配置。
		配置文件详情：https://www.liaoxuefeng.com/wiki/1252599548343744/1264739436350112
		配置log4j较繁琐，配置完成后非常方便，凡是info(默认)级别的日志会自动输出到屏幕，
		而error级别的，不但会输出到屏幕，同时会输出到文件。且日志文件达到指定大小，log4j
		就会自动切割新的日志文件，最多保留10份(详情根据配置来)。
		因为Log4j也是三方库，先下载jar包将3个jar包放入classpath中：
			og4j-api-2.x.jar
			log4j-core-2.x.jar
			log4j-jcl-2.x.jar
		因为commons logging会自动发现使用log4j，所以将commons的jar包也放入classpath。
		打印日志按Commons Logging的写法即可。
		
		结：
			通过Commons Logging实现日志，不需要修改代码即可使用Log4j；

			使用Log4j只需要把log4j2.xml和相关jar放入classpath；

			如果要更换Log4j，只需要移除log4j2.xml和相关jar；

			只有扩展Log4j时，才需要引用Log4j的接口（例如，将日志加密写入数据库的功能，需要自己开发）。
					
			
	使用SLF4J和Logback：
		Commons Logging和Log4j一个负责日志API，一个负责日志底层，搭配使用非常便于开发。
		SLF4J类似Commonslogging也是日志接口，logback类似log4j是日志实现。
		commons的时候打印日志需要拼接字符串，slf4j的话就能使用占位符，飞创简洁，占位符表示为{}。
		对比一下Commons Logging和SLF4J的接口：
			Commons Logging							SLF4J
			org.apache.commons.logging.Log			org.slf4j.Logger
			org.apache.commons.logging.LogFactory	org.slf4j.LoggerFactory
			区别就是log变成了logfactory。
		使用方法是将jar包放到classpath下，jar名：
			slf4j-api-1.7.x.jar
			logback-classic-1.2.x.jar
			logback-core-1.2.x.jar
		然后使用SLF4J的Logger和LoggerFactory即可。和Log4j类似，我们仍然需要一个Logback的配置文件，
		把logback.xml放到classpath下，配置如下：				
			https://www.liaoxuefeng.com/wiki/1252599548343744/1264739155914176
		
		结：
			SLF4J和Logback可以取代Commons Logging和Log4j。

			始终使用SLF4J的接口写入日志，使用Logback只需要配置，不需要修改代码。

			
反射(Reflection)：			
	java的反射是指程序运行期间可以拿到一个对象的所有信息。
	
	Class类：
		除了int等基本类型，其他类型基本全都是class，包括interface还有引用类型等。
		class和interface的本质是数据类型type，无继承关系的数据类无法赋值。
		class是JVM在执行过程中动态加载的，在第一次读取到一种class类型时，将其加载进内存。
		每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。
			以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后，
			为String类创建一个Class实例并关联起来：
				Class cls = new Class(String);
				
		只有JVM能创建Class实例，我们自己的java程序时无法创建class实例的，	
		所以，JVM持有的每个Class实例都指向一个数据类型（class或interface）：
			┌───────────────────────────┐
			│      Class Instance       │──────> String
			├───────────────────────────┤
			│name = "java.lang.String"  │
			└───────────────────────────┘
			┌───────────────────────────┐
			│      Class Instance       │──────> Random
			├───────────────────────────┤
			│name = "java.util.Random"  │
			└───────────────────────────┘
			┌───────────────────────────┐
			│      Class Instance       │──────> Runnable
			├───────────────────────────┤
			│name = "java.lang.Runnable"│
			└───────────────────────────┘	
			一个Class实例包含了该class的所有完整信息：
			┌───────────────────────────┐
			│      Class Instance       │──────> String
			├───────────────────────────┤
			│name = "java.lang.String"  │
			├───────────────────────────┤
			│package = "java.lang"      │
			├───────────────────────────┤
			│super = "java.lang.Object" │
			├───────────────────────────┤
			│interface = CharSequence...│
			├───────────────────────────┤
			│field = value[],hash,...   │
			├───────────────────────────┤
			│method = indexOf()...      │
			└───────────────────────────┘
		JVM为每个加载的class创建对应的Class实例，并在其中保存了该class的所有信息。	
		这种通过Class实例获取class信息的方法称为反射（Reflection）。	
			1.通过一个class静态变量class获取：
				Class c =String.class;
			2.如果有一个实例变量，可通过该实例提供的getClass()进行获取：
				String s = "xxx";
				Class c = s.getClass();
			3.知道一个Class的完整类名，可通过静态方法Class.forName()获取：
				Class c = Class.forName("java.lang.String");
		Class实例在JVM是唯一的，so上述方法获取的Class实例是同一个实例，可用==比较两个class实例。	
			像这样：
				Class c = String.class;
				String s = "xx";
				Class c2 =s.getClass();
				boolean b=c==c2;    返回true;
			class的实例和instanceof的区别：
				Integer n = new Integer(123);

				boolean b1 = n instanceof Integer; // true，因为n是Integer类型
				boolean b2 = n instanceof Number; // true，因为n是Number类型的子类

				boolean b3 = n.getClass() == Integer.class; // true，因为n.getClass()返回Integer.class
				boolean b4 = n.getClass() == Number.class; // false，因为Integer.class!=Number.class
				instanceof不但匹配指定类型还匹配指定类型的子类。而==判断class实例可以精确的判断数据类型但不能做子类类型比较。
				只有在精确判断一个类型是不是某个class的时候才使用==判断class实例。
			通过反射获取实例信息参考：
				void printObjectInfo(Object obj) {
					Class cls = obj.getClass();
				}
			过去到一个class的实例，可通过该class实例创建对应类型的实例：
				// 获取String的Class实例:
				Class cls = String.class;
				// 创建一个String实例:
				String s = (String) cls.newInstance();
				以上相当于new String()，但只能调用public的无参构造方法，带参的构造方法或非public的构造方法都无法通过
				Class.newInstance()被调用。
	
		动态加载：
			JVM执行Java程序时，不是一次性所有的class全部加载到内存，而是第一次用到class时才加载。
			就像执行Main类时，用到了main就会加载Main.class到内存，方法中有判断，成功则运行a方法，失败运行b方法
			那么true时成功运行a方法这时jvm发现需要加载a类时，才会首次加载a.class，b同理。
			这就是JVM动态加载的特性。
			动态加载的特性对java程序非常重要，利用这个特性才能在运行期根据条件加载不同的实现类。
			因为Commons Logging总是优先使用Log4j，所以只要将log4j的jar放到classpath中，commonslogging会自动使用。
			小结：
				JVM为每个加载的class及interface创建了对应的Class实例来保存class及interface的所有信息；

				获取一个class对应的Class实例后，就可以获取该class的所有信息；

				通过Class实例获取class信息的方法称为反射（Reflection）；

				JVM总是动态加载class，可以在运行期根据条件来控制加载class。
			
	访问字段：
		通过class实例获取字段信息方法：
			Field getField(name)：			根据字段名获取某个public的field（包括父类）
			Field getDeclaredField(name)：	根据字段名获取当前类的某个field（不包括父类）
			Field[] getFields()：			获取所有public的field（包括父类）
			Field[] getDeclaredFields()：	获取当前类的所有field（不包括父类）
		获取字段值：
			获取字段是getName("fieldName")的话,设置字段就是set(fieldName,"xxx")。
			反射可以直接修改字段的值。
			访问非public的话可能会报IllegalAccessException异常，因为不是public字段field访问不到，
			所以要调用setAccessible(true),意思是不管字段是不是public。
			以下有个反射修改字段的例子
				String name = "Xiao Ming";
				int age = 20;
				Person p = new Person();
				// TODO: 利用反射给name和age字段赋值:
				Class c = p.getClass();
				Field f = c.getDeclaredField("name");
				f.setAccessible(true);
				f.set(p, name);
				f=c.getDeclaredField("age");
				f.setAccessible(true);
				f.set(p, age);
				System.out.println(p.getName()); // "Xiao Ming"
				System.out.println(p.getAge()); // 20
		
		Java的反射API提供的Field类封装了字段的所有信息：

		通过Class实例的方法可以获取Field实例：getField()，getFields()，getDeclaredField()，getDeclaredFields()；

		通过Field实例可以获取字段信息：getName()，getType()，getModifiers()；

		通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用setAccessible(true)来访问非public字段。

		通过反射读写字段是一种非常规方法，它会破坏对象的封装。	
			
			
	调用方法：
		https://www.liaoxuefeng.com/wiki/1252599548343744/1264803678201760
		可以通过class实例获取所有field对象，也能获取所有method信息，Class类提供方法获取method：
			Method getMethod(name, Class...)：			获取某个public的Method（包括父类）
			Method getDeclaredMethod(name, Class...)：	获取当前类的某个Method（不包括父类）
			Method[] getMethods()：						获取所有public的Method（包括父类）
			Method[] getDeclaredMethods()：				获取当前类的所有Method（不包括父类）
		一个Method对象包含一个方法的所有信息：
			getName()：				返回方法名称，例如："getScore"；
			getReturnType()：		返回方法返回值类型，也是一个Class实例，例如：String.class；
			getParameterTypes()：	返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}；
			getModifiers()：		返回方法的修饰符，它是一个int，不同的bit表示不同的含义。
			当我们获取到一个Method对象时，就可以对它进行调用。我们以下面的代码为例：
				String s = "Hello world";
				String r = s.substring(6); // "world"
				除了substring(int)还有substring(int，int)，int是截取下标到末尾的字段
														   int，int就是从第一个int到第二个int的字段，也是通过下标截取。
			对Method实例调用invoke就相当于调用该方法，invoke的第一个参数是对象实例，即在哪个实例上调用该方法，
			后面的可变参数要与方法参数一致，否则将报错。
		调用静态方法：
			获取到method表示一个静态方法，调用static method时，由于无需指定实例对象所以invoke()传入第一个参数永远为null，
			Integer.parseInt(String)为例：
				Method m = Integer.class.getMethod("parseInt", String.class);	//这就是Integer.parseInt(String)
				// 调用该静态方法并获取结果:
				Integer n = (Integer) m.invoke(null, "12345");
		调用非public方法：
			和field类似，非public虽然可以通过Class.getDeclaredMethod()过去该方法实例，直接对其调用将得到一个IllegalAccessException。
			我可以通过Method.setAccessible(true)调用非public方法：
			如果JVM运行期存在SecurityManager那他可能不允许对java和javax开头的package的类调用setAccessible(true),
			这样可以保证JVM核心库的安全。
			
		多态！！！！！！！！！：
			 Java实现多态有三个必要条件：继承、重写、向上转型。
			 子类可向父类进行向上转型，但会丢失些许方法和属性就是父类不能调用子类独有的方法，如果子类重写了父类方法，
			 那么就会引用子类的重写方法。
			 如：											相当于：		
				Method m = Person.class.getMethod("hello");				Person p = new Student();
				m.invoke(new Student());								p.hello();	
				
				
		利用反射来调用方法例子如下：
			String name = "Xiao Ming";
			int age = 20;
			Person p = new Person();
			// TODO: 利用反射调用setName和setAge方法:
			
			Method m = p.getClass().getMethod("setName", String.class);
			m.invoke(p, name);
			Method m1 = p.getClass().getMethod("setAge", int.class);
			m1.invoke(p, age);

			System.out.println(p.getName()); // "Xiao Ming"
			System.out.println(p.getAge()); // 20
				需要先将方法信息添加到method中
				invoke(p,name)方法的作用是调用方法，将方法参数化
					   p就是方法信息如方法名和方法返回值
					   name就是需要修改的属性了。			
		结：
			Java的反射API提供的Method对象封装了方法的所有信息：

			通过Class实例的方法可以获取Method实例：getMethod()，getMethods()，getDeclaredMethod()，getDeclaredMethods()；

			通过Method实例可以获取方法信息：getName()，getReturnType()，getParameterTypes()，getModifiers()；

			通过Method实例可以调用某个对象的方法：Object invoke(Object instance, Object... parameters)；

			通过设置setAccessible(true)来访问非public方法；

			通过反射调用方法时，仍然遵循多态原则。
			
	调用构造方法：
		Constructor（构造器）
		newInstance（反射）
		Instance（实例）
		XXX x = new XXX();
		创建实例or new对象的时候，如果不加上任何参数，就是创建了一个空的构造方法，创建类的时候会默认创建一个空的构造方法。
		如果在构造方法中加上参数那么必须新建一个构造方法，否则new对象是无参时会报错。
		如通过反射创建新的实例，可以调用Class提供的newInstance()方法。
			Person p = Person.Class.newInstance();
			这个方法的局限性，它只能调用该类的public无参构造方法。如果构造方法带有参数或不是public就无法通过
			Class.newInstance()调用。
		为调用任意构造方法，反射API提供Constructor，它包含一个构造方法的所有信息，可创建一个实例。
		Constructor对象和Method相似，不同的是仅在于它是给构造方法，并且调用结果总是返回实例。
			// 获取构造方法Integer(int):
			Constructor cons1 = Integer.class.getConstructor(int.class);
			// 调用构造方法:
			Integer n1 = (Integer) cons1.newInstance(123);
			System.out.println(n1);
			类型同理。
		通过Class实例获取Constructor的方法如下：
			getConstructor(Class...)：			获取某个public的Constructor；
			getDeclaredConstructor(Class...)：	获取某个Constructor；
			getConstructors()：					获取所有public的Constructor；
			getDeclaredConstructors()：			获取所有Constructor。
		Constructor总是当前类定义的构造方法，必须先通过setAccessible(ture)设置允许访问，setAccessible可能失败。
		setAccessible(ture)是为了能访问非public的并提高反射性能。
		结：
			Constructor对象封装了构造方法的所有信息。
			通过Class实例的方法可获取constructor实例。
			通过constructor实例可创建一个实例对象，newInstance()。
			通过设置setAccessible(true)访问非public构造方法。
		
	获取继承关系：
		获取某个class对象时，就获取到一个类类型：
			Class cls = String.class; // 获取到String的Class
			也可用实例的getClass()获取：
				String s = "";
				Class cls = s.getClass(); // s是String，因此获取到String的Class
			又或者是Class.forName("")床头class的完整路径名获取：
				Class s = Class.forName("java.lang.String");
			以上都是一个实例，因为JVM对每个加载的class之创建一个class实例表示它的类型。
		
		获取父类的Class：
			也可以获取已有class实例的父类的class。
			获取父类的class用：Class s = x.getSuperclass();
			最大的父类时object再上面就是null了。
			当然除了任何非interface(接口)的Class都必定存在一个父类。
		获取interface：
			一个类可能实现一个或多个接口，通过class可以查询实现的接口类型。
				Class s = Integer.class;
				Class[] is = s.getInterfaces();
				然后循环遍历即可。
				但是getInterfaces()只返回当前类直接实现的接口类型，不包括父类实现的接口类型。
			如果要获取父类的接口需要先获取到父类，然后再获取它的实现接口。
				如：
				Class s = Integer.getSuperclass(); //获取integer的父类
				Class ss = s.getInterfaces();	//获取integer父类实现的接口。
				然后循环遍历。
			
		继承关系：
			判断实例是否为某个类型时，一般使用instanceof操作符：
				Object n = Integer.valueOf(123);
				boolean isDouble = n instanceof Double; // 想判断为什么类型就在Double输入指定类型。			
			如果两个class实例，判断一个向上转型是否成立可调用，isAssignableFrom()。
				// Integer i = ?
				Integer.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Intege
				Integer.class.isAssignableFrom(Number.class); // false，因为Number不能赋值给Integer
				如果参数填写的是父类那就是false，举例因为number不能赋值给integer
		结：
			通过Class对象可以获取继承关系：
			Class getSuperclass()：获取父类类型；
			Class[] getInterfaces()：获取当前类实现的所有接口。
			通过Class对象的isAssignableFrom()方法可以判断一个向上转型是否可以实现。	
			
	
	动态代理：https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984
		class和interface的区别
			可以实例化class(除了abstract抽象的)
			不能实例化interface
		所有的intterface类型变量总是通过向上转型并指向某个实例的。
		CharSequence cs = new StringBuilder();		Stringbuilder实现charsequence接口
		java标准库提供一种动态代理(Dynamic Proxy)的机制，可在运行期动态创建某个interface的实例。
		
		什么是动态代理，如果定义一个接口hello，但是不去编写实现类，而通过jdk提供的Proxy.newProxyInstance()创建
		一个hello接口对象。这种没有实现类但是运行期动态创建一个接口对象的方式，称为动态代码。
		JDK提供动态创建接口对象的方式为动态代理。
		
		结：
			Java标准库提供了动态代理功能，允许在运行期动态创建一个接口的实例；
			动态代理是通过Proxy创建代理对象，然后将接口方法“代理”给InvocationHandler完成的。


注解(Annotation)	一定要看https://blog.csdn.net/qq1404510094/article/details/80577555：
	注解和class还有interface一样也是一种类型。
	使用注解：
		注解是java源码的类、方法、字段、参数前的一种特殊注释，以@开头。
		注解的作用：
			有三类注解：
				1.编译器使用的注解：
					@Override：编译器检查该方法时候正确的实现重写。
					@SuppressWarnings：高速编译器忽略此处代码产生的警告。
					此类注解不会被编译到.class文件，在编译后就被丢弃。
				2.有文件处理.class文件使用的注解：
					如有些工具在加载class的时候，对class做动态修改，实现特殊功能，这一类注解就会被编译进.class文件，
					单价在结束后并不会存在于内存中。这些注解只被一些底层使用，一般不用我们处理。
				3.程序运行其能读取的注解：
					这类注解记载后一直存在于JVM，这是最常用的注解。如一个配置了@PostConstruct的方法会在调用构造方法后自动
					被调用(这是java代码读取该注解实现的功能，JVM并不会识别该注解)。
			定义注解时，也能定义配置参数：
				所有基本类型。
				String。
				枚举类型。
				基本类型、String、Class以及枚举的数组。
				配置参数必须是常量so以上的限制保证注解定义的时候已确定每个参数的值。
				注解的参数可有默认值，缺少某个配置参数时就使用默认值，如果只写注解的话，就是所有参数全采用默认值。
				大部分会有value的参数配置，也可以只写常量省略value。
			小结
				注解（Annotation）是Java语言用于工具处理的标注：

				注解可以配置参数，没有指定配置的参数使用默认值；

				如果参数名称是value，且只有一个参数，那么可以省略参数名称。	
			
	定义注解：
		java语言使用@interface语法定义注解(Annotation)：
			public @interface Report {
				int type() default 0;
				String level() default "info";
				String value() default "";
			}
			注解参数类似无参数方法，可用default设定个默认值，最常用的参数命名为value。
		元注解：
			可以修饰其他注解的注解称为元注解(meta annotation)。Java标准库已定义些元注解，我们只需要使用，不必自己定义。
			@Target：
				常用的元注解是@Target。使用它可定义注解能被应用于源码的位置。
				类或接口：ElementType.TYPE；
				字段：ElementType.FIELD；
				方法：ElementType.METHOD；
				构造方法：ElementType.CONSTRUCTOR；
				方法参数：ElementType.PARAMETER。
				像这样(但是我不知道这是干嘛用的)：
					@Target(ElementType.METHOD)
					public @interface Report {
						int type() default 0;
						String level() default "info";
						String value() default "";
					}
			@Retention：
				此注解定义了注解的声明周期：
					仅编译期：RetentionPolicy.SOURCE；	注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；被编译器忽略
					仅class文件：RetentionPolicy.CLASS；注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期
					运行期：RetentionPolicy.RUNTIME。	注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在
				如果这个注解不存在，那么注解默认为class。因为通常定义的注解都是RUNTIME(运行时间)，所以务必加上
				@Retention(RetentionPolicy.RUNTIME)
				@Retention(RetentionPolicy.RUNTIME)
				public @interface Report {
					int type() default 0;
					String level() default "info";
					String value() default "";
				}
			
			@Repeatable：
				此元注解可定义Annotation是否可重复，但应用不是特别广泛。
				如果使用此元注解的注解，则可重复声明使用，如下：
					@Report(type=1, level="debug")
					@Report(type=2, level="warning")
					public class Hello {
					}
			
			@Inherited：
				此字段定义子类是否可继承父类定义的注解，但是只针对ElementType.TYPE(类或接口)类型的注解有效，并只针对class的继承，interface继承无效。
				使用此注解定义的注解被类用到了，那么子类默认也定义了该注解。
		如何定义注解：
			1.使用@interface定义注解：
				public @interface Report {}
			2.添加参数，默认值：
				public @interface Report{
					int type() default 0;
					String level() default "info";
					String value() default "";
				}
				最常用的参数定义为value()，推荐所有参数都尽量设置默认值。
			3.用元注解配置注解：
				@Target(ElementType.TYPE)
				@Retention(RetentionPolicy.RUNTIME)
				public @interface Report {
					int type() default 0;
					String level() default "info";
					String value() default "";
				}
				必须设置target和retention，后者一般设置为runtime，因为自定义注解通常要求在运行期读取。
				一般情况下不必写inherited和repeatable
		结：
			Java使用@interface定义注解：

			可定义多个参数和默认值，核心参数使用value名称；

			必须设置@Target来指定Annotation可以应用的范围；

			应当设置@Retention(RetentionPolicy.RUNTIME)便于运行期读取该Annotation。
			
	处理注解：
		注解本身对代码逻辑没有任何影响，根据@Retention的配置：
			SOURCE类型的注解在编译期就被丢掉了；
			CLASS类型的注解仅保存在class文件中，它们不会被加载进JVM；
			RUNTIME类型的注解会被加载进JVM，并且在运行期可以被程序读取。
						
		注解使用由工具决定。
		SOURCE类型的注解主要由编译器使用，因此一般只使用不便写。
		CLASS类型的注解主要底层工具库使用，涉及class加载，很少用到。
		RUNTIME类型注解不但使用而且经常编写。
		
		注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation，so读取注解需用到反射API。		
		判断某个注解是否存在于class、filed、method或constructor：
			Class.isAnnotationPresent(Class)
			Field.isAnnotationPresent(Class)
			Method.isAnnotationPresent(Class)
			Constructor.isAnnotationPresent(Class)
			
			如判断注解是否存在与person类：
				Person.class.isAnnotationPresent(Report.class);	
				
		java提供使用反射API读取注解的方法包括以下：
			Class.getAnnotation(Class)
			Field.getAnnotation(Class)
			Method.getAnnotation(Class)
			Constructor.getAnnotation(Class)	
			如：
				// 获取Person定义的@Report注解:
				Report report = Person.class.getAnnotation(Report.class);
				int type = report.type();
				String level = report.level();
			
		反射API读取注解由两种方法：
			1.判断注解是否存在，存在就直接读取：
				Class cls = Person.class;
				if (cls.isAnnotationPresent(Report.class)) {
					Report report = cls.getAnnotation(Report.class);
					...
				}
			2.直接读取注解，如不存在就返回null：
				Class cls = Person.class;
				Report report = cls.getAnnotation(Report.class);
				if (report != null) {
				   ...
				}
			
	小结
		可以在运行期通过反射读取RUNTIME类型的注解，注意千万不要漏写@Retention(RetentionPolicy.RUNTIME)，
		否则运行期无法读取到该注解。
		可以通过程序处理注解来实现相应的功能：
			对JavaBean的属性值按规则进行检查；
			JUnit会自动运行@Test标记的测试方法。
		

泛型：
	什么是泛型：
		泛型是一种代码模块，可用一套代码套用各种类型。
		ArrayList是可变长度数组，使用比普通数字更方便。
		实际上ArrayList内部是Object[]数组，配合存储当前分配的长度，就可充当可变数组。
		但是这个数组如果要转变成其他类型就会容易出错，不方便，而且要为其单独编写一个ArrayList，
		如果每一个类型都编写一个ArrayList实在太麻烦了。
		为了解决这个问题特地将ArrayList编程一种模板ArrayList<T>这就是泛型，T可以是任何class，
		这样就可以创建任何ArrayList：
			ArrayList<String> strList = new ArrayList<String>();
			ArrayList<int> strList = new ArrayList<int>();
			ArrayList<Student> strList = new ArrayList<Student>();
			由编译器对类型作检查，值必须是相同类型的否则报异常。
			这样就是实现编写一次，万能匹配，通过编译器保证了类型安全，这就是泛型。
		向上转型：
			类型ArrayList<T>可以向上转型为List<T>。
			ArrayList<Integer>上转为List<Integer>只能根据这样的规则进行向上转型。
		注：
			泛型就是编写模板代码来适应任意类型；

			泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查；

			注意泛型的继承关系：可以把ArrayList<Integer>向上转型为List<Integer>（T不能变！），
			但不能把ArrayList<Integer>向上转型为ArrayList<Number>（T不能变成父类）。
					
	使用泛型：
		如果不定义泛型类型的话，那它实际上类型就是object
		编译器看到接收的泛型类型是Integer的话，后面的泛型类型必须也是Integer。
		所以后面的泛型可以省略：
			List<Integer> i=new Arraylist<>();

		泛型接口：
			public interface Comparable<T>
			class Person implements Comparable<Person>
			
			Comparable接口中的compareTo是用来比较对象大小的，使用a.compareTo(b),就是对比a和b的大小。
			字符串和数值类型都能比较。
			结：
				使用泛型时，把泛型参数<T>替换为需要的class类型，例如：ArrayList<String>，ArrayList<Number>等；

				可以省略编译器能自动推断出的类型，例如：List<String> list = new ArrayList<>();；

				不指定泛型参数类型时，编译器会给出警告，且只能将<T>视为Object类型；

				可以在接口中定义泛型类型，实现此接口的类必须实现正确的泛型类型。
		
		编写泛型：
			泛型类型<T>不能用于静态方法！！！
		多个泛型类型：
			可以public class 泛型类<int,String>{}这样，参数也可以改为其他。但是这样有点麻烦所以可以
			将参数改为类，这样的话该类中所有类型都能接受。
		结：
			编写泛型时，需要定义泛型类型<T>；

			静态方法不能引用泛型类型<T>，必须定义其他类型（例如<K>）来实现静态泛型方法；

			泛型可以同时定义多种类型，例如Map<K, V>。
			
	擦拭法(Type Erasure)：
		擦拭法是虚拟机对泛型一无所知，所有工作都是编译器做的。
		虚拟机会将泛型看作object，Java使用擦拭法实现泛型导致：
			编译器将类型<T>视为object。
			编译器根据<T>实现安全的强制转型。
		java泛型是虚拟机在编译时实行的，编译器内部永远将所有类型T视为object处理，但在需要转型的时候，
		编译器会根据T的类型自动为我们实行安全强制类型转换。
		
		java泛型的局限性，<T>不能是基本类型，如int，因为实际是object，object无法持有基本类型。
		所有泛型实例，无论T类型是什么，getClass()返回同一个Class实例，因为T编译后全是Object。
		而且无法判断带泛型的类型，因为不存在泛型类.class,只有唯一的类.class。
		也就是说getClass()获取实例时，获取的时同一个class实例。
		不能实例化T类型，因为擦拭后变成了Object类型。
		
		实例化T类型，要借助额外的Class<T>参数，如：
			public Pair(Class<T> clazz) {
				first = clazz.newInstance();
				last = clazz.newInstance();}
		实例化：Pair<String> pair = new Pair<>(String.class);
		可通过String.class实例化String类型。
		
		泛型继承：
			类可以继承自泛型类
		
		结：
			Java的泛型是采用擦拭法实现的；

			擦拭法决定了泛型<T>：

			不能是基本类型，例如：int；
			不能获取带泛型类型的Class，例如：Pair<String>.class；
			不能判断带泛型类型的类型，例如：x instanceof Pair<String>；
			不能实例化T类型，例如：new T()。
			泛型方法要防止重复定义方法，例如：public boolean equals(T obj)；

			子类可以获取父类的泛型类型<T>。
			
	extends通配符：
		可参考实例https://www.liaoxuefeng.com/wiki/1252599548343744/1265105899616928
		
		如果泛型定了是number类型，那么就只能传入number类型，就连其子类Integer都不行。
		那么可使用extends让他接受number和其子类类型，如下:
			类<? extends Number>这样就能接收number和它子类类型了。
			这种泛型定义称为上界通配符，就是把泛型类T的上界限定在Number了。
		
			<? extends Number>通配符的一个重要限制：方法参数签名setFirst(? extends Number)
			无法传递任何Number类型给setFirst(? extends Number)。
		extends通配符作用：
			java.util.List<T>接口，它实现的是一个类似“可变数组”的列表。
			如果定义一个List<? extends integer>或者List<Integer>是一样的，但它的限制是：
				允许调用get()方法获取Integer的引用；
				不允许调用set(? extends Integer)方法并传入任何Integer的引用（null除外）。
		使用extends限定T类型：
			<? extends Number>限定T的类型，String、Object都不符合Number因为他们不是。
			
		结：
			使用类似<? extends Number>通配符作为方法参数时表示：

			方法内部可以调用获取Number引用的方法，例如：Number n = obj.getFirst();；

			方法内部无法调用传入Number引用的方法（null除外），例如：obj.setFirst(Number n);。

			即一句话总结：使用extends通配符表示可以读，不能写。

			使用类似<T extends Number>定义泛型类时表示：

			泛型类型限定为Number以及Number的子类。
	

	Super通配符：
		void set(Pair<Integer> p, Integer first, Integer last) {
			p.setFirst(first);
			p.setLast(last);
		}
		传入Integer可以，Number不行。
		因为number和object是integer的父类，setFirst(Integer)是能接受的。
		<? super Integer>意思是发发参数接受所有泛型类型为Integer和它父类的类型。
		 
		<? super Integer>表示：
			可以调用set(? super Integer)传入Integer的引用。
			不可以调用get()方法获得Integer的引用。
		唯一例外是可以获取object的引用：Object o=p.getFirst();
		其实就是<? super Integer>通配符为方法参数，表示方法内部代码对于参数只能写不能读。
		extends可能是只能读不能写把，大概。。。。。
		
		对比extends和super通配符：
			<? extends T>和<? super T>的区别在于：
				extends允许调用读方法T get()获取T的引用，但不允许调用写方法set(T)传入T的引用(null除外)。
				super允许调用写方法set(T)传入T的引用，但不允许调用读方法T get()获取T的引用(获取object除外)。
				extends是可读不可写，super是可写不可读。
		
		public static <T> void copy(List<? super T> dest,List<? extends T> src) {
			for(int i=0;i<src.size();i++) {
				T t = src.get(i);
				dest.add(t);
			}
		}	这个copy()方法的定义就完美地展示了extends和super的意图：

			copy()方法内部不会读取dest，因为不能调用dest.get()来获取T的引用；

			copy()方法内部也不会修改src，因为不能调用src.add(T)。
			这个copy方法另一个好处是安全地将List<Integer>添加到List<Number>，但无法反过来添加。
			
		PECS原则：
			为了便于记忆何时使用extends和super，可使用PECS原则Producer Extends Consumer Super(生产者照顾消费者)。
			如果需返回T，它是生产者Producer，就要使用extends通配符。
			如需写入T，它是消费者Consumer，要使用super通配符。
			返回的是生产者，写入的是消费者。
		无限定通配符：
			java的泛型允许使用无限定通配符(Unbounded Wildcard Type)，只定义一个？。
			void sample(Pair<?> p) {}
			因为<?>没有extends和super，so：
				不允许调用set(T)方法并传入引用，null除外。
				不允许调用T get()方法并获取T引用，只能获取Object引用。
				所以说不能读或写，只能做一些null判断。
			可引入泛型参数<T>消除<?>通配符。
			<?>通配符特点是，Pair<?>是所有Pair<T>的超类，T是？的子类，可以安全的进行向上转型。
		
		结：
			使用类似<? super Integer>通配符作为方法参数时表示：

			方法内部可以调用传入Integer引用的方法，例如：obj.setFirst(Integer n);；

			方法内部无法调用获取Integer引用的方法（Object除外），例如：Integer n = obj.getFirst();。

			即使用super通配符表示只能写不能读。

			使用extends和super通配符要遵循PECS原则。

			无限定通配符<?>很少使用，可以用<T>替换，同时它是所有<T>类型的超类。
	
	
	泛型和反射：
		java部分反射API也是泛型，如Class<T>。
		参考这个：https://www.liaoxuefeng.com/wiki/1252599548343744/1265105940850016
		结：
			部分反射API是泛型，例如：Class<T>，Constructor<T>；

			可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型；

			可以通过Array.newInstance(Class<T>, int)创建T[]数组，需要强制转型；

			同时使用泛型和可变参数时需要特别小心。
			
			
集合：
	java集合简介：
		有限集合：如一个班所有同学构成的集合之类的。
		无限集合：所有自然数集合，1、2、3...之类的。
		Java中一个java对象可在内部持有若干其他的java对象，并对外提供访问接口，将这种java称为集合，
		java数组可看作是种集合：
			String[] s=new String[10];		s[0]="ss";		String ss=s[0];
		因为数组有初始化后大小不可变，只能按照索引顺序存取。所以不同的集合类处理不同数据：
		可变大小的顺序链表，保证无重复元素集合。
		Collection(集合)：
			java.util提供了Conllection集合类，是除了Map外所有其他集合类的根接口。
				List：一种由序列表的集合，如按索引排列的Student的List。
				Set：保证没有重复元素的集合，如所有无重复名称的Student的Set。
				Map：通过键值对(Key-Value)查找的映射表集合，如根据Student的name查找相应Student的Map。
			集合的特点：
				1.实现了接口和实现类分离，如有序表接口是List，具体实现类有ArrayList，LinkedList等。
				2.支持泛型，可以限制在一个集合只能放入同一种数据类型的元素：
					List<String> l= new ArrayList<>();	只能放入String。
				java访问集合总是通过统一的方式 迭代器(Iterator)实现，最明显的好处是无需知道集合内部
				元素按什么方式存储。
		当然有一小部分集合是遗留类，不应继续使用：
			Hashtable：	线程安全的Map实现。
			Vector：	线程安全的List实现。
			Stack：		基于Vector实现的LIFO的栈。
		遗留接口：Ecnumeration<E>	被Iterator<E>取代。
		
		结：
			Java的集合类定义在java.util包中，支持泛型，主要提供了3种集合类，包括List，Set和Map。
			Java集合使用统一的Iterator遍历，尽量不要使用遗留接口。
			
	使用List：
		List是一种基础集合和有序列表。
		List和数组几乎完全相同，
		list内部按照元素先后顺序存放，每个元素通过索引确定位置，索引从0开始。
		数组的添加是将指定位置后的元素向后移动空出一个位置，删除则是将该位置后的元素向前移动一个位置。
		
		增删元素的有序列表，通常使用ArrayList。在它的内部使用数组存储所有元素。
		添加元素时，arraylist自动移动需要移动的元素，然后往内部指定索引的数组添加一个元素，将集合大小+1。
		如果数组已满，那么ArrayList将会创建一个更大的新数组，将所有元素复制到新数组，将新数组替代旧数组。
		
		相当于是ArrayList将增删操作进行封装，操作list类似于数组，却不关心内部元素如何移动。
		
		考察List<E>接口，可以看到几个主要的接口方法：
			在末尾添加一个元素：		void add(E e)
			在指定索引添加一个元素：	void add(int index, E e)
			删除指定索引的元素：		int remove(int index)
			删除某个元素：				int remove(Object e)
			获取指定索引的元素：		E get(int index)
			获取链表大小(含元素的个数)：int size()
			
		List不一定只能通过ArrayList的数组实现，
		也可以通过LinkedList链表实现List接口，LinkedList中内部每个元素都指向下一个元素。
			        ┌───┬───┐   ┌───┬───┐   ┌───┬───┐   ┌───┬───┐
			HEAD ──>│ A │ ●─┼──>│ B │ ●─┼──>│ C │ ●─┼──>│ D │   │
					└───┴───┘   └───┴───┘   └───┴───┘   └───┴───┘
			像自行车链条一样，这就是链表。
					
								ArrayList		LinkedList
			获取指定元素		速度很快		需要从头开始查找元素
			添加元素到末尾		速度很快		速度很快
			在指定位置添加/删除	需要移动元素	不需要移动元素
			内存占用			少				较大
			通常情况下优先使用ArrayList。
		
		List的特点：
			list接口能添加重复数据，也可以添加null。
		创建List：
			除了ArrayList和LinkedList，也可通过List接口的of()方法，根据给定元素快速创建List。
			List<Integer> l=List.of(1,2,3);
			但是of不能接受null值，会报NullPointerException异常。
			get()根据索引查询值的方法只有在ArrayList才是高效的，LinkedList时索引越大访问越慢。
			
			所以使用迭代器Iterator访问List，Iterator本身也是一个对象，由List的实例调用iterator()方法
			的时候创建的。Iterator对象值道如何遍历一个List，不同List类型返回的Iterator对象实现也是不同的，
			但总是具有最高访问效率。
			
			Iterator对象有两个方法：
				boolean hasNext()判断是否有下一个元素，
				E next()返回下一个元素。
				以下是Iterator遍历List的方法：
				List<String> list = List.of("apple", "pear", "banana");
				for (Iterator<String> it = list.iterator(); it.hasNext(); ) {
					String s = it.next();
					System.out.println(s);}
				虽然使用Itaretor比索引更复杂些。但这是遍历List最高效的方式。
				for(String s : list){}	这样更简便。
			只要实现了Iterable接口集合类都可以直接用for each循环遍历，编译器本身不知道怎么遍历集合对象，
			但它会自动将for each循环变成Iterator的调用，因为Iterator接口定义一个Iterator<E> iterator()
			方法，强迫集合类必须返回一个Iterator实例。
		list和Array转换：
			List转为Array有3种方法：
				1.调用toArray()方法直接返回一个object[]数组：
					Object[] array = list.toArray();
					list是List集合，此方法会丢失类型信息，实际应用很少。
				2.给toArray(T[])传入类型相同的Array，List内部自动将元素复制到传入的Array中：
					Integer[] array = list.toArray(new Integer[3]);
					toArray(T[])方法的泛型参数是可以传入其他类型的数组，如传入Number返回Number，Integer类型同理。
					
					但如果传入类型不匹配的数组，如String[]类型数组，由于List元素是Integer，所以无法放入String数组，
					会抛出ArratStoreExcepsion。
					如果传入数组不够大，那么list会创建一个新的够大的数组，填充后返回。
					如果传入数组比list元素要多，那么填充玩元素后，剩下数组元素一律填充null。
					
				3.常用的传入一个刚好大小的数组(第二个更简单)：
						Integer[] array = list.toArray(new Integer[list.size()]);
						Integer[] array = list.toArray(Integer[]::new);
			将Array转为List：
				可直接通过List.of(T..)进行转换。
				Integer[] array = { 1, 2, 3 };
				List<Integer> list = List.of(array);
				如果JDK11前的版本可用Array.asList(T...)将数组转换为List。
				
			返回的List不一定是ArrayList或者LinkedList，因为List只是个接口，如果调用List.of()，返回的是一个只读List。
				对只读List使用add()、remove()方法的话会抛出UnsupportedOperationException异常。
				
			结：
				List是按索引顺序访问的长度可变的有序表，优先使用ArrayList而不是LinkedList；

				可以直接使用for each遍历List；

				List可以和Array相互转换。
			
			
	编写equals方法：
			list的contains(object o方法判断list是否包含某个指定元素，indexOf(object o)方法可以返回指定元素索引，元素不存在就返回-1。
			因为list是通过equals()判断两个元素是否相等，所以使用contains()、indexOf()方法时，实例要正确重写equals()方法，
			否则放入的实例，查找不到。
			有些能正常放入String、Integer等对象是因为定义类的时候已经实现了equals()方法。
			
		编写equals：
			满足以下条件：
				自反性（Reflexive）：对于非null的x来说，x.equals(x)必须返回true；
				对称性（Symmetric）：对于非null的x和y来说，如果x.equals(y)为true，则y.equals(x)也必须为true；
				传递性（Transitive）：对于非null的x、y和z来说，如果x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)也必须为true；
				一致性（Consistent）：对于非null的x和y来说，只要x和y状态不变，则x.equals(y)总是一致地返回true或者false；
				对null的比较：即x.equals(null)永远返回false。
			编写equals最简单的方式：
				public boolean equals(Object o){
					if(o instanceof list集合类型){	使用传入参数和list类型进行比较
						list集合类型 l=(list集合类型) o;
						return Object.equals(this.属性,l.属性);	返回为true的条件，也就是传入的参数属性进行比较相同返回true。
					}
					return false;
				}
			equals正确的编写方法：
				1.先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；
				2.用instanceof判断传入的待比较的Object是不是当前类型，如果是，继续比较，否则，返回false；
				3.对引用类型用Objects.equals()比较，对基本类型直接用==比较。
			使用Objects.equals()比较两个引用类型是否相等的目的是省去了判断null的麻烦。两个引用类型都是null时它们也是相等的。
			如果不调用List的contains()、indexOf()这些方法，那么放入的元素就不需要实现equals()方法。
			
			结:
				在List中查找元素时，List的实现类通过元素的equals()方法比较两个元素是否相等，
				因此，放入的元素必须正确覆写equals()方法，Java标准库提供的String、Integer等已经覆写了equals()方法；

				编写equals()方法可借助Objects.equals()判断。

				如果不在List中查找元素，就不必覆写equals()方法。
		
		
	使用Map：
		键值对(Key-Value)，能高效通过key快速查找value。
		map是一个键值映射表，
			put(key, value); 添加键值到map中。
			get(key);	通过输入key获取到指定的数据，key不存在则返回null。
			containsKey(key);	查询key是否存在。
		map是一个接口，常见的实现类是HashMap。
		put方法如果添加一个已存在的键，那么会将原有的value删掉添加新的value，否则返回null。
		注：map中不存在重复的key，因为会把原有的value给替换掉，但是value可以重复。
		
		遍历Map：
			使用foreach循环：
				for(String s : map.KeySet())	keyset表示获取map集合所有key。
				map.get(s);		get方法是获取map的value。
			同时遍历Key and Value可以使用Entry：
				for(Map.Entry<String,Integer> entry : map.entrySet())	entrySet获取map的key和value。
					entry.getKey()		entry.getValue()			通过这两种方法获取key和value。
			
			注：
				需要注意的是，因为map存储的键值对的，所以遍历的时候不保证添加和遍历顺序一致。
				不可假设输出key是有序的。
		
		结：
			Map是一种映射表，可以通过key快速查找value。

			可以通过for each遍历keySet()，也可以通过for each遍历entrySet()，直接获取key-value。

			最常用的一种Map实现是HashMap。
			
			
	编写equals和hashCode：
		HashMap能根据key直接拿到value，因为内部通过空间换时间方法，用一个大数组存储所有value，
		并根据key直接计算出value应该存储在那个索引：
			  ┌───┐
			0 │   │
			  ├───┤
			1 │ ●─┼───> Person("Xiao Ming")
			  ├───┤
			2 │   │
			  ├───┤
			3 │   │
			  ├───┤
			4 │   │
			  ├───┤
			5 │ ●─┼───> Person("Xiao Hong")
			  ├───┤
			6 │ ●─┼───> Person("Xiao Jun")
			  ├───┤
			7 │   │
			  └───┘
		因为key为xiaoming的key值为a的话，计算得到的索引总是1，其他也一样，这样就不用遍历整个数组，即可直接读取对应key的value。
		大致看了一下，字太多了，看的头大，有些还没理解先不写，留个链接：https://www.liaoxuefeng.com/wiki/1252599548343744/1265117217944672
			
		
	使用EnumMap：
		hashmap通过对key计算hashcode()，通过空间换时间的方式直接定位到value所在内部数组的索引，效率非常高。
		如果key对象是enum类型，那么可使用EnumMap，用非常紧凑的数组存储value，根据enum类型的key直接定位到内部数组的索引，
		并不需要计算hashcode()，效率高也不浪费空间。
		使用枚举类型的map如下：
			Map<DayOfWeek, String> map = new EnumMap<>(DayOfWeek.class);
			map.put(DayOfWeek.MONDAY, "星期一");
			System.out.println(map.get(DayOfWeek.MONDAY));
		使用EnumMap的时候，总是map接口引用它，实际上HashMap和EnumMap互换，在客户端看来没有任何区别。
		
		结：
			如果Map的key是enum类型，推荐使用EnumMap，既保证速度，也不浪费空间。

			使用EnumMap的时候，根据面向抽象编程的原则，应持有Map接口。
			
			
	使用TreeMap：https://www.liaoxuefeng.com/wiki/1252599548343744/1265117109276544
		hashmap空间换时间，实现原理决定了内部key是无序的，遍历hashmap的key时，顺序是不可预测的(每个key都会遍历一次仅一次)。
		SortedMap内部的对key进行排序，它是接口，实现类是TreeMap。
			   ┌───┐
			   │Map│
			   └───┘
				 ▲
			┌────┴─────┐
			│          │
		┌───────┐ ┌─────────┐
		│HashMap│ │SortedMap│
		└───────┘ └─────────┘
					   ▲
					   │
				  ┌─────────┐
				  │ TreeMap │
				  └─────────┘			
		SortedMap保证遍历时按照key的顺序进行遍历，String根据字母，int根据数字。
			类似：Map<Integer,String> m=new TreeMap<>();
		使用TreeMap时放入的Key必须！必须！实现Comparable接口。
		如果key的class没有实现Comparable接口，那么必须在创建TreeMap时同时指定一个自定义排序算法。
			类似：
				Map<Person, Integer> map = new TreeMap<>(new Comparator<Person>() {
					public int compare(Person p1, Person p2) {
						return p1.name.compareTo(p2.name);	将p1和p2对比然后排序。
					}
				});
		TreeMap时不会使用equals()和hashCode()的，所以class不用进行这两个方法的重写。
		
		结：
			SortedMap在遍历时严格按照Key的顺序遍历，最常用的实现类是TreeMap；

			作为SortedMap的Key必须实现Comparable接口，或者传入Comparator；

			要严格按照compare()规范实现比较逻辑，否则，TreeMap将不能正常工作。	
			
	使用Properties(属性)：
		编写程序的配置文件，它的key-value一般都是String-String类型的，所以可用Map<String,String>表示。
		配置文件非常常用，所以集合库提供了Properties表示一组配置，遗留原因，其内部本质上是Hashtable，
		但只需要用到Properties自身关于读写配置的接口。
		java默认配置文件以.Properties为扩展名，每行Key=value表示，#是注释。
		
		如：#setting.properties，最后打开的文件
			last_open_file=/data/hello.txt
		读取步骤：创建Properties实例。
				  调用load()读取文件。
				  调用getProperty()获取配置。
			读取例子：
				String f="setting.properties";	//先用字符串设置配置文件名
				Properties p=new Properties();	//创建Properties实例。
				p.load(new java.io.FileInputStream(f));		//给定指定配置文件，load方法不知道什么意思。
				String filepath=p.getProperty("last_open_file");	//其中的值是配置文件的Key。
				
				调用getProperty()获取配置时，key不存在将返回null。也可以提供默认值，当key不存在时返回默认值。
				也可从classpath读取.properties文件，因为load(InputStream)方法接收一个InputStream实例，
				表示一个字节流1，它不一定是文件流，也可以是从jar包中读取的资源流：
					Properties props = new Properties();
					props.load(getClass().getResourceAsStream("/common/setting.properties"));
				如果有多个.properties文件，可反复调用load()读取，后读取的key-value会覆盖已读取的key-value：
					Properties props = new Properties();
					props.load(getClass().getResourceAsStream("/common/setting.properties"));
					props.load(new FileInputStream("C:\\conf\\setting.properties"));
					以上的常用法是，将默认配置文件放入classpath中后，根据及其环境编写另一个配置文件，覆盖某些配置。
					使用Properties时不要调用从Hashtable继承下来的方法。
		写入配置文件：
			通过setProperty()修改了Properties实例，可将配置写入方法，方便下次启动获得最新配置，
			写入配置文件使用store()方法：
				Properties props = new Properties();
				props.setProperty("url", "http://www.liaoxuefeng.com");
				props.setProperty("language", "Java");
				props.store(new FileOutputStream("C:\\conf\\setting.properties"), "这是写入的properties注释");
		编码：
			早期的java.properties编码是ascii编码，从JDK9开始，java的.properties文件可使用UTF-8。
			由于load(InputStream)默认ASCII编码读取字节流，但是会读到乱码，需要用另一个重载方法load(Reader)读取：
				Properties props = new Properties();
				props.load(new FileReader("settings.properties", StandardCharsets.UTF_8));
				以上就能正常读取中文了，InputStream和Reader的区别是一个是字节流，一个是字符流。
				字符流在内存中已经可以char表示了，因此不涉及编码问题。
		结：
			Java集合库提供的Properties用于读写配置文件.properties。.properties文件可以使用UTF-8编码。

			可以从文件系统、classpath或其他任何地方读取.properties文件。

			读写Properties时，注意仅使用getProperty()和setProperty()方法，不要调用继承而来的get()和put()等方法。
			
	使用Set：
		set存储的是不重复的key和不需要存储映射的value。
			将元素添加进Set<E>：boolean add(E e)
			将元素从Set<E>删除：boolean remove(Object e)
			判断是否包含元素：boolean contains(Object e)
		set相当于只存储key不存value的map，可使用set去重元素。
		放入set的元素和map的key类似，要正确实现equals()和hashCode()方法，否则元素无法正常放入set。
		
		常用的Set实现类是HashSet，HashSet仅仅是HashMap的一个简单封装。
		set接口不保证有序，SortedSet接口保证元素有序：
			HashSet是无序的，因为它实现了Set接口，并没有实现SortedSet接口；
			TreeSet是有序的，因为它实现了SortedSet接口。
			   ┌───┐
			   │Set│
			   └───┘
				 ▲
			┌────┴─────┐
			│          │
		┌───────┐ ┌─────────┐
		│HashSet│ │SortedSet│
		└───────┘ └─────────┘
					   ▲
					   │
				  ┌─────────┐
				  │ TreeSet │
				  └─────────┘
		TreeSet和TreeMap要求一样，提娜佳元素必须正确实现Comparable接口，不实现的话，创建TreeSet时必须传入Comparator对象。
		
	使用Queue(队列)：
		队列，是一个先进先出的有序列表。和list的区别是：
			list可在任意位置删除增加元素。
			Queue只有两个操作：
				将元素添加到队列尾部。
				从队列头部取出元素。
		队列接口Queue以下的方法：
			List接口		Queue接口
			boolean add()	boolean fooer()	添加元素到队列末尾
			E remove()		E poll()	获取队首元素并从队列删除
			E element()		E peek()	获取队首元素但不删除
			int size()队列长度。
			list和queue的获取首元素方法好像不能通用。
			两个方法的行为是不同的：
								throw Exception		返回false或true
				add()			boolean offer()		添加元素到末尾
				E remove()		E poll()			取队首元素并删除
				E element()		E peek()			取队首元素但不删除
				比如add添加失败的话可以选择抛出异常，offer添加失败的话返回false。
				如果remove获取元素失败就会抛出异常，poll获取元素失败时就会返回null。
				以上两个例子就是使用场景不同，根据需求使用list或queue还有以下的方法。
				不要将null添加到队列中，否者pool时，很难确定取到了null还是队列为空返回的null。
		LinkedList实现了List也实现了Queue，使用时当作list就获取list的引用，
										   当作queue就获取queue的引用。
		廖雪峰老师原话：始终按照面向抽象编程的原则编写代码，可以大大提高代码的质量。								   
		结：
			队列Queue实现了一个先进先出（FIFO）的数据结构：

			通过add()/offer()方法将元素添加到队尾；
			通过remove()/poll()从队首获取元素并删除；
			通过element()/peek()从队首获取元素但不删除。
			要避免把null添加到队列。	
	
	
	使用PriorityQueue(优先队列)：
		queue是先进先出的队列，但是数据都是进入尾部，PriorityQueue给元素设置优先级，
		对此调用remove()或poll()，返回总是优先级高的元素，放入PriorityQueue元素要实现Comparable接口，
		priorityQueue根据元素排序顺序决定优先级。
		详细例子：https://www.liaoxuefeng.com/wiki/1252599548343744/1265120632401152
		结：
			PriorityQueue实现了一个优先队列：从队首获取元素时，总是获取优先级最高的元素。

			PriorityQueue默认按元素比较的顺序排序（必须实现Comparable接口），也可以通过Comparator自定义排序算法（元素就不必实现Comparable接口）。
			
	使用Deque(双队列)：
		双队列允许两头进，两头出，Deque接口实现双端队列：	
			既可以添加到队尾，也可以添加到队首；
			既可以从队首获取，又可以从队尾获取。
		
		Queue和Deque进出队列方法：
									Queue					Deque
				添加元素到队尾		add(E e) / offer(E e)	addLast(E e) / offerLast(E e)			添加队尾
				取队首元素并删除	E remove() / E poll()	E removeFirst() / E pollFirst()			取首并删除
				取队首元素但不删除	E element() / E peek()	E getFirst() / E peekFirst()			取首不删除
				添加元素到队首		无						addFirst(E e) / offerFirst(E e)			添加队首
				取队尾元素并删除	无						E removeLast() / E pollLast()			取尾并删除
				取队尾元素但不删除	无						E getLast() / E peekLast()				取首不删除
		例子：https://www.liaoxuefeng.com/wiki/1252599548343744/1265122668445536	
		Deque扩展自Queeu。
		所以Queue的add/offer方法Deque也能使用，但还是使用addFirst和offerFirst，因为能明确看出语句的作用。
		Deque是接口，实现类有ArrayDeque和LinkedList。
		LinkedLint是List、Queue、Deque。使用时用特定的接口引用，因为接口层次更高，并且接口本身定义方法代表特定用途。
		！！！面向接口编程一个原则就是：尽量持有接口，而不是具体实现类。
		
		结：
			Deque实现了一个双端队列（Double Ended Queue），它可以：
				将元素添加到队尾或队首：		addLast()/offerLast()/addFirst()/offerFirst()；
				从队首／队尾获取元素并删除：	removeFirst()/pollFirst()/removeLast()/pollLast()；
				从队首／队尾获取元素但不删除：	getFirst()/peekFirst()/getLast()/peekLast()；
				
				总是调用xxxFirst()/xxxLast()以便与Queue的方法区分开；
				避免把null添加到队列。
			
	使用Stack(堆栈)：
		栈最关键的方法：
			入栈	push()
			出栈	pop()
		栈方法：
			boolean empty()	判断栈是否为空
			E peek()	返回栈顶对象不移除
			E pop()		返回栈顶对象并移除
			E push(E item)	压入栈顶，添加数据
			int search(Object o)	返回对象在栈的位置
		search返回位置从栈顶开始计数，栈顶为1，不再栈顶元素返回-1，可通过此方法的返回值判断栈是否存在需要的元素。
		推荐使用Deque接口实现栈。
		
		栈是后进先出的数据结构。
		就像以下，和先进先出的区别就是将一段封死：
			           ───────────────────────────────┐
			  (\(\       (\(\    (\(\    (\(\    (\(\ │
			 (='.') <─> (='.')  (='.')  (='.')  (='.')│
			O(_")")    O(_")") O(_")") O(_")") O(_")")│
					   ───────────────────────────────┘
		数据是一直往栈中压入(push)，最后压入的元素最早弹出(pop)。
		stack栈只有入栈和出栈操作：
			把元素压栈：push(E)；
			把栈顶的元素“弹出”：pop(E)；
			取栈顶元素但不弹出：peek(E)。
			
		java中可用deque实现stack功能：
			把元素压栈：push(E)/addFirst(E)；
			把栈顶的元素“弹出”：pop(E)/removeFirst()；
			取栈顶元素但不弹出：peek(E)/peekFirst()。
			
		stack没有单独接口，因为有个遗留类也叫stack，只能用deque接口模拟stack。
		
		JVM创建方法调用栈，调用一个方法时，将参数压栈后执行对应方法，
		方法返回时，返回值压栈，调用方法通过出栈操作获得方法返回值。
		方法调用栈有容量限制，嵌套调用过多会造成栈溢出，引发StackOverflowError。
		
		栈进制转换：https://www.liaoxuefeng.com/wiki/1252599548343744/1265121668997888#0
	

	使用Iterator(迭代器)：
		迭代器就是在不知带具体内容的情况下能循环遍历集合的作用，我的理解。
		要迭代集合时该集合要实现Iterator接口，编写Iterator时可用一个内部类实现Iterator接口，
		此内部类可直接访问对应外部类的所有字段和方法。
		
		编写迭代器的例子：https://www.liaoxuefeng.com/wiki/1252599548343744/1265124784468736
		结：
			Iterator是一种抽象的数据访问模型。使用Iterator模式进行迭代的好处有：

			对任何集合都采用同一种访问模型；
			调用者对集合内部结构一无所知；
			集合类返回的Iterator对象知道如何迭代。
			Java提供了标准的迭代器模型，即集合类实现java.util.Iterable接口，返回java.util.Iterator实例。
			
			
	使用Collections(合类，集合类，工具类)：
		Collections是JDK提供的工具类，提供一些静态方法，能更方便操作各种集合。
		
		我们一般看方法名和参数就可以确认Collections提供的该方法的功能。例如，对于以下静态方法：
			public static boolean addAll(Collection<? super T> c, T... elements) { ... }	
			addAll()方法可以给一个Collection类型的集合添加若干元素。因为方法签名是Collection，所以我们可以传入List，Set等各种集合类型。
			
		创建空集合：
			Collections提供方法创建一个单元素集合。
				创建一个元素的List：List<T> singletonList(T o)
				创建一个元素的Map：	Map<K, V> singletonMap(K key, V value)
				创建一个元素的Set：	Set<T> singleton(T o)
			返回的单元素集合是不可变集合，无法香气中添加或删除元素。
			也能用各个集合接口提供的of(T...)方法创建单元素集合，以下方法效果一样：
				List<String> list1 = List.of("apple");
				List<String> list2 = Collections.singletonList("apple");
			实际上of更方便点，因为即可创建空集合，也能创建单元素集合，还可以创建任意个元素集合：
				List<String> list1 = List.of(); // empty list
				List<String> list2 = List.of("apple"); // 1 element
				List<String> list3 = List.of("apple", "pear"); // 2 elements
				依次类推，可创建任意的elements(元素)。
		排序(sort)：
			Collections可对List进行排序，排序会直接修改list元素位置，因此必须传入可变list：
				Collections.sort(集合);
		洗牌(shuffle)：
			Collections提供洗牌算法，传入个有序list，随机打乱内部元素，相当于洗牌效果：
				Collections.shoffle(集合);
		不可变集合：
			提供方法及那个可变集合封装成不可变集合：
				封装成不可变List：List<T> 	unmodifiableList(List<? extends T> list)
				封装成不可变Set： Set<T> 	unmodifiableSet(Set<? extends T> set)
				封装成不可变Map： Map<K, V> unmodifiableMap(Map<? extends K, ? extends V> m)
			这种封装是通过创建一个代理对象，拦截掉所有修改方法实现的：
				不可变集合是，不能对此集合进行删除添加，效果如下
				List<String> list = new ArrayList<>();
				List<String> immutable = Collections.unmodifiableList(list);
				immutable.add("orange"); // UnsupportedOperationException!
			对不可变集合做出增删改会报UnsupportedOperationException异常。
			但是对原始的可变集合进行增删是可以的，并且会直接影响封装后的不可变集合：
				List<String> mutable = new ArrayList<>();
				List<String> immutable = Collections.unmodifiableList(mutable);
				mutable.add("orange");
				直接对可变list进行添加删除就会影响不可变集合，而且查询可变还是不可变集合都能看到添加的信息。
			想将可变集合封装成不可变，so，返回集合后，立即扔掉可变集合引用以保证后续操作不会意外改变原始操作
			对象，从而造成不可变集合变化。

		线程安全集合：
			Collections还提供了一组方法，可以把线程不安全的集合变为线程安全的集合：
				变为线程安全的List：List<T>  synchronizedList(List<T> list)
				变为线程安全的Set： Set<T>   synchronizedSet(Set<T> s)
				变为线程安全的Map： Map<K,V> synchronizedMap(Map<K,V> m)
			从Java5开始引入更高效的并发集合类，所以上面几个方法没什么用了。
		
		结：
			Collections类提供了一组工具方法来方便使用集合类：
				创建空集合；
				创建单元素集合；
				创建不可变集合；
				排序／洗牌等操作。
	
	Collection和Collections的区别：
		Collection是集合体系最顶层，包含集合体系共性，简而言之就是集合上级接口，继承它的接口有List，Set等。
		Collections是工具类，方法都是用于操作Collection，提供静态方法实现对各集合的搜索、排序、线程安全等操作。
		
	

IO流：
		io流是数据从内存到硬盘的输入或输出的操作，
		input输入，将外部数据如硬盘中的文件读取到内存，或从网络读取数据到内存中。
		output输出，将数据从内存写入到文件中，或从内存输出到网络中。
		因为代码在内存中运行，数据也必须读到内存中，不论是byte数组又或是字符串等等。
		因为内存有易失性特点，所以处理后的代码要以某种方式输出，像写入到文件中进行保存。
		IO是一种顺序读写数据的模式，特点是单向流动，数据像自来水一样在水管中流动，所以称为IO流。
		
		IO的字节流(传输的自小单位是byte)：
			InputStream(字节输入流)：从外部将数据读入到内存中。
			OutputStream(字节输出流)：从内存中将数据输出到文件或网络中。
			
		IO的字符流(传输的自小单位是char)：
			Reader(字符输入流)：从外部将数据读入到内存中。
			Writer(字节输出流)：从内存中将数据输出到文件或网络中。
				
		Reader和Writer本质上是能自动编解码的InputStream和OutputStream。

			
		
		使用Reader，数据源虽然是字节，但我们读入的数据都是char类型的字符，原因是Reader内部把读入的byte做了解码，转换成了char。
		使用InputStream，我们读入的数据和原始二进制数据一模一样，是byte[]数组，但是我们可以自己把二进制byte[]数组按照某种编码转换为字符串。		
		
		同步异步：
			同步IO，读写时代码必须等待数据返回后才继续执行后续代码，有点是编写简单，缺点是CPU执行效率低。
			异步IO，读写时仅发出请求，后立即执行后续代码，有点是CPU执行效率高，缺点是代码复杂。
			java包，java.io提供同步，java.nio提供异步。
			InputStream、OutputStream、Reader、Writer都是同步IO的抽象类，具体实现类，文件为例，FileInputStream、FileOutputStream、FileReader、FileWrite。
			
			同步必须等待或主动询问IO是否完成，完成后才能继续执行其他操作。
			异步不需要等待结构就可以执行其他操作，如常见的中断。
			
			同步IO模型：
				阻塞：用户进程发起一个IO操作，必须等待IO操作的完成，当真正完成IO操作后，进程才能运行。
				非阻塞：用户进程发起IO操作后可返回做其他事情，但用户进程要时不时询问IO操作是否就绪，要求用户进程不停询问，从而引发不必要的CPU资源浪费。
			异步IO模型：
				阻塞：应用发起一个IO操作后，不等待内核IO操作完成，等内核完成IO操作后会通知应用程序。由于select函数本身的实现方式是阻塞的，所以该模型是阻塞IO型。
				非阻塞：用户进程需要发起一个IO操作后立即返回，IO操作真正完成后，应用程序会得到IO操作完成的同志，此时用户进程子要对数据进行处理即可，不需要进行
						实际的IO读写操作，因为真正的IO读写操作已经由内核完成了。
		
		javaIO分三个部分：
			流式：IO主体部分
			非流式：包含辅助流式部分类，file、RandomAccessFile、FileDescriptor等类。
			其他类：文件读取部分与安全相关类，SerializablePermission类，以及本地操作系统相关的文件系统类：
					FileSystem、Win32FileSystem和WinNTFlieSystem。
		
		IO中主要常用类：
			 1. File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等。

			 2. InputStream（二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征。

			 3. OutputStream（二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征。

			 4.Reader（文件格式操作）：抽象类，基于字符的输入操作。

			 5. Writer（文件格式操作）：抽象类，基于字符的输出操作。

			 6. RandomAccessFile（随机文件操作）：一个独立的类，直接继承至Object.它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作。
		
		IO详细参考：https://blog.csdn.net/weixin_38964895/article/details/80885275?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159549220519195162515173%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=159549220519195162515173&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-80885275.first_rank_ecpm_v3_pc_rank_v2&utm_term=IO&spm=1018.2118.3001.4187
		结：
			IO流是一种流式的数据输入/输出模型：

			二进制数据以byte为最小单位在InputStream/OutputStream中单向流动；

			字符数据以char为最小单位在Reader/Writer中单向流动。

			Java标准库的java.io包提供了同步IO功能：

			字节流接口：InputStream/OutputStream；

			字符流接口：Reader/Writer。		
				
				
	File对象：	
		各种例子：https://www.liaoxuefeng.com/wiki/1252599548343744/1298069154955297
		file对象主要用来操作文件和目录，对文件进行存储等待。
		创建file对象需要传入文件路径：
			File f = new File("C:\\Windows\\notepad.exe");
			路径是虚假的也不会报错。
		构造file对象时，可传入绝对路径，也可传入相对路径，绝对路径以根目录开头的完整路径。
		相对路径前加上当前目录jiu
			绝对路径：C:\\。。。。。。什么的。
			相对路径：.\\test\\tt	路径前加上当前目录如：C:\\test\\tt or C:\\faizi\\test\\tt
					  ..\\test\\tt
					  test\\tt
			可用.表示当前目录，..表示上级目录
		
		file对象3种路径形式：
			getPath()返回构造方法传入的路径。
			getAbsolutePath()返回绝对路径。
			getCanonicalPath()和绝对路径类似但返回规范路径，比如：
				C:\test\.\a转换成规范C:\test\a
		
		文件和目录：
			file对象既可以表示文件也可以表示目录，构建file对象不会导致任何磁盘操作所以，传入错误的文件或目录也没关系。
			只有调用file对象某些方法的时候，才真正进行磁盘操作。
			file方法：
				isFile()判断file对象是否是文件
				isDirectory()判断file对象是否是目录
			另外file对象获取到文件时，可判断文件权限和大小：
				boolean canRead()是否可读
				boolean canWrite()是否可写
				boolean canExecute()是否可执行
				long	length()文件字节大小
		
		创建删除文件：
			createNewFile()创建新文件。
			delete()删除该文件
			可创建临时文件：
				createTempFile()创建临时文件。
				deleteOnExit()JVM退出时自动删除该文件。
		
		遍历文件和目录：
			file表示目录时，可使用方法列出目录下的文件和子目录名，并且listFiles()提供一系列重载方法，
			可过滤不想要的文件和目录：
				listFile()列出所有文件和子目录。
			file表示一个目录的话可通过如下方法进行删除创建目录：
				boolean mkdir()创建当前File对象表示的目录。
				boolean mkdirs()创建当前file对象表示的目录，并将不存在的父目录也创建出来。
				boolean delete()删除当前File对象表示的目录，当前目录必须为空才能创建成功。
		Path：
			此对象位于java.nio.file包下，path和file类似但操作更简单。
			Paths.get(".", "project", "study");构造一个path对象此语句创建的路径是.\project\study。
			path也能使用file的方法：
				toAbsolutePath()	转为绝对路径
				normalize()			转为规范路径
				toFile()			转为File对象
				for(Path p : Paths.get("..").toAbsolutePath())	直接遍历Path但是还没看明白(..)作用。
			对目录进行复杂凭借、遍历等操作使用path对象更方便。
		结：
			Java标准库的java.io.File对象表示一个文件或者目录：

			创建File对象本身不涉及IO操作；
			可以获取路径／绝对路径／规范路径：getPath()/getAbsolutePath()/getCanonicalPath()；
			可以获取目录的文件和子目录：list()/listFiles()；
			可以创建或删除文件和目录。

		
	InputStream(输入流)：
		最基本的输入流，位于java.io，此包提供所有同步IO的功能。
		inputstream是抽象类，是所有输入流的超类。此抽象类最重要的方法就是read()(阅读)。
		
		此方法会读取输入流的下一个字节，并返回字节表示的int值(0~255)，如果已读到末尾则返回-1表示不能读取。
		FileInputStream是InputStream的一个子类，FileInputStream是从文件流读取数据：
			InputStream input = new FileInputStream("src/readme.txt");	创建一个fileinputstream对象
			for(;;){				使用循环通过read()方法反复读取文件字节
				int n=input.read();
				if(n==-1){			设置判断读取值为-1时停止循环。
					break;
				}
			}
			input.close();			为避免浪费资源，读取完成后关闭输入流。
			在计算机中，类似文件、网络端口这些资源，都是由操作系统统一管理的。应用程序在运行的过程中，如果打开了一个文件进行读写，
			完成后要及时地关闭，以便让操作系统把资源释放掉，否则，应用程序占用的资源会越来越多，不但白白占用内存，还会影响其他应用程序的运行。
		InputStream和OutputStream都是通过close()方法关闭流，关闭流就会释放对应的底层资源。
		
		读、写IO流的过程中可能发生错误，文件不存在导致无法读取，或是没有写权限导致写入失败等。这些错误有虚拟机自动封装成IOException异常抛出，
		所以，所有IO操作相关的代码都必须正确处理IOException。读取过程中发生IO错误，InputStream无法正常关闭，资源无法及时释放。
		所以使用try...finally保证其是否发生IO错误情况下都正常关闭流。
			try{
				可能发生IO错误的代码
			}fianlly{
				inputStream.close();	关闭流，finally是最后总是执行的意思，不管是否发生错误，其中的代码总是执行。
			}
		
		以上代码相较于Java7的新try(resource)语法稍显复杂，try(resource)只需要编写try，编译器自动关闭资源：
			try(InputStream input=new FileInputStream("read.txt")){		try()中创建输入流的语句。
				其中编写可能发生IO错误的语句
			}	编译器会在这个位置自动写入finally并调用close()。
			
			编译器不会特别为InputStream加上自动关闭，只看try(resource=....)中的对象是否实现java.lang.AutoCloseable接口，
			如果实现就自动加上finally并调用close()，inputstream、outputstream都实现了这个接口所以可用在try(resource)中。
	
		缓存：
			读取流通常是一次读取以字节并不高效，很多流支持一次性读取多个字节到缓冲区，对文件和网络来说，利用缓冲区一次性读取
			多个字节效率要高很多，inputstream提供2个重载方法支持读取多个字节：
				int read(byte[] b)		读取若干字节并填充到byte[]数组，返回读取的字节数。
				int read(byte[] b,int off,int len)	指定byte[]数组的偏移量和最大填充数。
			以上方法一次读取多个字节，要定义一个byte[]数组作为缓冲区，read()会尽可能多读取字节到缓冲区，但不会超过缓冲区大小，
			read()返回值不再是字节的int值，而是返回实际读取了多少个字节，为-1就是没有更多数据。
			例子：
				try (InputStream input = new FileInputStream("src/readme.txt")) {
					// 定义1000个字节大小的缓冲区:
					byte[] buffer = new byte[1000];
					int n;
					while ((n = input.read(buffer)) != -1) { // 读取到缓冲区
						System.out.println("read " + n + " bytes.");
					}
				}
				
		阻塞(Blocking)：
			inputstream的read()读取数据时，read()是堵塞的：
				int n;
				n=input.read();	必须等待read返回才能执行下一行代码。
				int m=n;
			必须等待read返回后才能继续，因为读取IO流相比执行普通代码，速度会慢很多，所以无法确定read方法调用会花费多长时间。
			
		InputStream实现类：
			FileInputStream可从文件获取输入流，它是inputstream常见一个实现类，此外ByteArrayInputStream可在内存中模拟一个InputStream：
			例子：
				byte[] data = { 72, 101, 108, 108, 111, 33 };	创建一个byte数组
				try (InputStream input = new ByteArrayInputStream(data)) {		创建一个字节数组输入流实例
					int n;															
					while ((n = input.read()) != -1) {		循环将读取的byte数组中的数据赋值到n中，并判断-1时终止循环。
						System.out.println((char)n);		将强转为char类型，输出结果为Hello！
					}
				}
			
			ByteArrayInoutStream时将一个Byte[]在内存中变为一个InputStream，实际应用不多，但测试时可用来构造一个InputStream。
			如从文件读取所有字节，转换成char拼成字符串：
				try (InputStream input = new FileInputStream("C:\\test\\README.txt")) {		创建一个文件输入流，并标记文件位置
					int n;			定义int变量
					StringBuilder sb = new StringBuilder();			创建stringbuilder实例
					while ((n = input.read()) != -1) {		循环读取文件字节并保存在int变量，同时判断读取受否为-1。
						sb.append((char) n);				通过stringbuilder的append拼接功能将读取到的字节强转为char，并进行拼接。
					}
					s = sb.toString();		将拼接好的stringbuilder通过toString转换为String类型输出即可。
				}
				
			分离方法：https://www.liaoxuefeng.com/wiki/1252599548343744/1298069163343905	
		
		结：
			Java标准库的java.io.InputStream定义了所有输入流的超类：

			FileInputStream实现了文件流输入；

			ByteArrayInputStream在内存中模拟一个字节流输入。

			总是使用try(resource)来保证InputStream正确关闭。		
	
		
	OutputStream(输出流)：
		outputstream也是抽象类，是所有输出流的超类，其定义最重要的方法就是write(int)。
		write()方法会写入一个字节到输出流，虽然传入的是int参数，但会只写入一个字节，仅写入int最低8位表示字节的部分。
		
		flush(写)：
			outputstream提供close关闭输出流，而且还提供了flush()，目的是将缓冲区的内容真正输出到目的地。
			因为向磁盘、网络写入数据时，处于效率问题，会将输出字节放到内存的缓冲区中(缓冲区本质时byte[]数组)，
			等到缓冲区写满了，在一次性写入文件或网络。很多IO设备一次写入一个或1000个字节花费的时间是一样的，
			所以flush，能强制将缓冲区内容输出。
			通常情况下是不需要调用flush的，因为缓冲区满了outputstream会自动调用，并且close关闭outputstream之前也会自动
			调用flush()。
			某些情况下必须手动调用flush方法，如在聊天功能中，发送方输出后，接收方没有收到信息：
				原因是写入网络流先写入内存缓冲区中缓冲区满了会一次性发送到网络，如果缓冲区大小4k，那么需要输入几千个字符，
				操作系统才会将缓冲区内容发送出去，此时接收方一次性接受大量消息。
				可以输入每句话后立刻调用flush(),不管当前缓冲区是否已满，强制将缓冲区内容发送出去。
	
		FileOutputStream(文件输出流)：	
			OutputStream output = new FileOutputStream("out/readme.txt");	创建输出流实例并标记写入文件位置
			output.write(72); // H		写入数据
			以上很麻烦所以使用一次性写入若干字节的outputstream的重载方法write(byte[])实现：
				OutputStream output = new FileOutputStream("out/readme.txt");
				output.write("hello".getBytes("UTF-8")); 		输出数据hello并规定编码格式utf-8
			
			和inputstream一样写入过程中可能发生IO错误，磁盘满了，无权先写入。还是用try(resource)保证无论什么时候
			发生什么IO错误outputstream都能正确关闭：
				try (OutputStream output = new FileOutputStream("out/readme.txt")) {
					output.write("Hello".getBytes("UTF-8")); // Hello
				} // 编译器在此自动为我们写入finally并调用close()
				用法和einputstream是一样的。		
		阻塞(Blocking)：
			outputstream的write()写入数据时，write()是堵塞的：
				int n;
				n=output.write(byte[]);	必须等待write返回才能执行下一行代码。
				int m=n;
			read和write都是阻塞的，必须等待返回才能执行下一步的代码。
				
		OutPutStream实现类：
			FileOutputStream是outputstream常用类可从文件获取输出流，ByteArrayOutputStream可在内存中模拟一个OutputStream。
			例子：	
				byte[] data;
				try (ByteArrayOutputStream output = new ByteArrayOutputStream()) {
					output.write("Hello ".getBytes("UTF-8"));
					output.write("world!".getBytes("UTF-8"));
					data = output.toByteArray();
				}
				System.out.println(new String(data, "UTF-8"));
			ByteArrayOutputStream实际将byte[]数组在内存中变成一个OutputStream，实际应用不多，测试可构造一个	OutputStream。
			同时操作多个AutoCloseable资源时，try(reource){},可同时写出多个资源，用;隔开，如：	
				// 读取input.txt，写入output.txt:
				try (InputStream input = new FileInputStream("input.txt");
					 OutputStream output = new FileOutputStream("output.txt"))
				{
					input.transferTo(output); // transferTo的作用是将input文件中的数据复制到output文件中。
		结：
			Java标准库的java.io.OutputStream定义了所有输出流的超类：

			FileOutputStream实现了文件流输出；

			ByteArrayOutputStream在内存中模拟一个字节流输出。

			某些情况下需要手动调用OutputStream的flush()方法来强制输出缓冲区。

			总是使用try(resource)来保证OutputStream正确关闭。	
			

	Filter模式(过滤器)：
		IO提供的InputStream根据来源包括：
			FileInputStream：从文件读取数据是最终数据源。
			ServletInputStream：从HTTP请求读取数据，是最终数据源	servlet(控制器)。
			Socket.getInputStream()：从TCP链接读取数据，是最终数据源。
		
		为FileInputStream添加缓冲功能，从FileInputStream派生一个类：
			BufferedFileInputStream extends FileInputStream		Buffered(缓冲)
		为FileInputStream添加计算签名功能，从FileInputStream派生一个类：	
			DigestFileInputStream extends FileInputStream		Digest(摘要)
		为FileInputStream添加加密/解密功能，从FileInputStream派生一个类：	
			CipherFileInputStream extends FileInputStream		Cipher(密码)
		为FileInputStream添加缓冲和签名功能，派生BufferedDigestFileInputStream，
		为FileInputStream添加缓冲和加解密功能，派生BufferedCipherFileInputStream。
			
			
		给FileInputStream添加3种功能，至少需要3个子类。这3种功能的组合，又需要更多的子类：

								  ┌─────────────────┐
								  │ FileInputStream │
								  └─────────────────┘
										   ▲
					 ┌───────────┬─────────┼─────────┬───────────┐
					 │           │         │         │           │
		┌───────────────────────┐│┌─────────────────┐│┌─────────────────────┐
		│BufferedFileInputStream│││DigestInputStream│││CipherFileInputStream│
		└───────────────────────┘│└─────────────────┘│└─────────────────────┘
								 │                   │
			┌─────────────────────────────┐ ┌─────────────────────────────┐
			│BufferedDigestFileInputStream│ │BufferedCipherFileInputStream│
			└─────────────────────────────┘ └─────────────────────────────┘	
			
		以上直接使用继承的话为各种inputstream附加更多功能，是无法控制代码的负责度，很快就会失控。	
		为解决依赖继承导致子类数量失控问题	，JDK将inputstream分为2大类：
			1是直接提供数据的基础InputStream：
				FileInputStream
				ByteArrayInputStream
				ServletInputStream
			2是提供额外附加功能InputStream：
				BufferedInputStream
				DigestInputStream
				CipherInputStream
		为一个基础InputStream附加各种功能例子和编写FilterInputStream参考以下链接：
			https://www.liaoxuefeng.com/wiki/1252599548343744/1298364142452770
			
			
		结：
			Java的IO标准库使用Filter模式为InputStream和OutputStream增加功能：

			可以把一个InputStream和任意个FilterInputStream组合；

			可以把一个OutputStream和任意个FilterOutputStream组合。

			Filter模式可以在运行期动态增加功能（又称Decorator模式）。	
						
			
	操作Zip：
		ZipInputStream是一种FileInputStream可直接读取zip保重的内容。
		┌───────────────────┐
		│    InputStream    │
		└───────────────────┘
				  ▲
				  │
		┌───────────────────┐
		│ FilterInputStream │
		└───────────────────┘
				  ▲
				  │
		┌───────────────────┐
		│InflaterInputStream│
		└───────────────────┘
				  ▲
				  │
		┌───────────────────┐
		│  ZipInputStream   │
		└───────────────────┘
				  ▲
				  │
		┌───────────────────┐
		│  JarInputStream   │
		└───────────────────┘
		JarInputStream是从ZipInputStream中派生的，增加的只要功能直接读取jar文件中的MANIFEST.MF文件(表明)。
		本质上jar包是zip包，只是额外附加一些固定的描述文件如上面的表明文件(此文件应该是说明jar包作用和其他信息的文件)。
		
		读取zip包：
			流程一般是，创建一个ZipInputStream，传入一个FileInputStream为数据源，然后循环调用getNextEntry()，直到返回null，表示zip流结束。
			try (ZipInputStream zip = new ZipInputStream(new FileInputStream(...))) {
			ZipEntry entry = null;
			while ((entry = zip.getNextEntry()) != null) {
				String name = entry.getName();
				if (!entry.isDirectory()) {
					int n;
					while ((n = zip.read()) != -1) {
						...
		
		写入zip包：
			ZipOutputStream是一种FileOutputStream，可直接写入内容到zip包，先创建一个ZipOutputStream，通常是包装一个FileOutputStream，
			然后每写入一个文件前，先调用putNextEntry()，然后用write()写入byte[]数据，写入完成后调用closeEntry()结束这个文件的打包。
			try (ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(...))) {
			File[] files = ...
			for (File file : files) {
				zip.putNextEntry(new ZipEntry(file.getName()));
				zip.write(getFileDataAsBytes(file));
				zip.closeEntry();
	
		上面的代码没有考虑文件的目录结构。如果要实现目录层次结构，new ZipEntry(name)传入的name要用相对路径。

		结：
			ZipInputStream可以读取zip格式的流，ZipOutputStream可以把多份数据写入zip包；

			配合FileInputStream和FileOutputStream就可以读写zip文件。			
				
			
	读取classpath资源：
		程序都需要读取配置文件，比如从.properties文件中读取。
		为了避免不同环境下文件路径不一致问题，选择从classpath读取文件。将default.properties文件放到classpath中，而不去关心实际存放路径。
		classpath中的资源文件，路径总是/开头，可获取当前class对象，再调用getResourceAsStream()可直接从classpath读取任意的资源文件。
		try (InputStream input = getClass().getResourceAsStream("/default.properties")) {
			但是getClass的时候会爆出无法引用不是static静态方法的问题。
			getResourceAsStream如果文件不存在就会返回null，可以再try中做出判断以确定文件是否存在。
		
		如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：
			Properties props = new Properties();
			props.load(inputStreamFromClassPath("/default.properties"));
			props.load(inputStreamFromFile("./conf.properties"));
		结：
			把资源存储在classpath中可以避免文件路径依赖；

			Class对象的getResourceAsStream()可以从classpath中读取指定资源；

			根据classpath读取资源时，需要检查返回的InputStream是否为null。	
			
			
	序列化：
		序列化也叫串行化，是将一个java对象变为二进制内容，其本质上是一个byte[]数组。
		对象序列化后可将byte[]保存到文件中，或将其通过网络传输到远程，相当于将java对象存储到文件或通过网络传输出去。
		序列化相反的是反序列化，将一个二进制内容(byte[])变为java对象，以此保存到文件中的byte可变回java对象，或从网络上读取
		byte并变回java对象。
		java对象要序列化，必须实现特殊的java.io.Serializable接口：
			public interface Serializable {
			此接口没有定义任何方法，是一个空接口，这种空接口称为标记接口(Marker Interface)，实现了标记接口的类只是贴了标记，并不增加
			任何方法。
		
		序列化：
			写入方法：
				write后根据类型选择对应方法：
					wirteInt();		写入int类型
					wirteUTF();		写入String类型
					wirteObject();	写入object类型
			将一个java对象变为一个byte[]数组(字节数组)，需要使用ObjectOutputStream，负责将一个java对象写入一个字节流：
				ByteArrayOutputStream buffer = new ByteArrayOutputStream();		创建一个字节数组输入流对象。
				try (ObjectOutputStream output = new ObjectOutputStream(buffer)) {		创建object类型的输入流
					// 写入int:
					output.writeInt(12345);		写入int类型数据
					// 写入String:
					output.writeUTF("Hello");		写入String类型数据(但是这里为什么不写String而是UTF？？？)
					// 写入Object:
					output.writeObject(Double.valueOf(123.456));		写入object类型
				}
				System.out.println(Arrays.toString(buffer.toByteArray()));		数组数据先转为字节数组类型在转化为string类型进行输出。
			
			ObjectOutputStream可写入基本类型，也可写入以UTF-8的形式的String，也可以实现Serializable接口的Object。
			因为写入Object需要大量类型信息，所以写入的内容很大。
			
		反序列化：
			读取方法：
				read后根据需要读取的数据进行选择对应方法：
					readInt();		读取int类型
					readUTF();		读取String类型
					readObject();	读取Object类型
			和ObjectOutputStream相反ObjectInputStream从一个字节流读取Java对象。
				try (ObjectInputStream input = new ObjectInputStream(...)) {
					int n = input.readInt();
					String s = input.readUTF();
					Double d = (Double) input.readObject();
			
			调用readObject()可直接返回一个Object对象，但是将其办成一个特定对象必须对它进行强制转型。
			读取Object可能抛出异常(readObject)：
				ClassNotFoundException：找不到对应的Class。
				InvalidClassException：Class不匹配。
				
				ClassNotFoundException常见于一台电脑上将一个java对象通过网络传输给另一台电脑上的另一个java程序，但是
				并没有定义Person所以无法反序列化，也就是无法成功读取数据。
				InvalidClassException常见于序列化的Person对象定义ing的age字段，但是反序列化时类型被改为long，导致Class不兼容。
				
				为避免ckass定义变动导致不兼容问题，序列化允许class定义特殊的serialVersionUID静态变量，用于标识序列化版本，
				通常由IDE自动生成，如果增加或就该字段，可改变serialVersionUID的值，就可自动组织不匹配的class版本：
					public class Person implements Serializable {
						private static final long serialVersionUID = 2709425275741743919L;
				反序列化的特点：
					反序列化时，由JVM直接构造java对象，不调用构造方法，构造方法内部代码，反序列化时不会执行。
		安全性：
			因为序列化导致实例直接从byte[]数组创建，不经过构造方法，所以存在安全隐患，一个精心构造的byte[]数组被反序列化后
			可以执行特定的java代码，从而导致严重的安全漏洞。
		
		实际上基于对象的反序列化和序列化都存在安全性和兼容性问题，更好的序列化方法是通过JSON的通用数据结构，只输出基本类型
		(包括String)的内容，而不存储任何与代码相关的信息。
		
		结：
			可序列化的Java对象必须实现java.io.Serializable接口，类似Serializable这样的空接口被称为“标记接口”（Marker Interface）；

			反序列化时不调用构造方法，可设置serialVersionUID作为版本号（非必需）；

			Java的序列化机制仅适用于Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON。
	
	Reader(阅读器)：
		Reader是IO提供另一个输入流接口，和InputStream的区别是，InputStream是字节流(byte)，Reader是字符流(char)。
		
		InputStream							Reader
		字节流，以byte为单位				字符流，以char为单位
		读取字节（-1，0~255）：int read()	读取字符（-1，0~65535）：int read()
		读到字节数组：int read(byte[] b)	读到字符数组：int read(char[] c)
		
		java.io.Reader是所有字符输入流的超类，主要方法就是read()
		此方法返回字符int范围是0~65535，都到末尾返回-1。
		
		FileReader(文件阅读器)：
			FileReader是Reader的子类，可以打开文件并获取Reader，一下演示完整读取FileReader字符：
			 // 创建一个FileReader对象:
				Reader reader = new FileReader("src/readme.txt"); // 字符编码是???
				for (;;) {
					int n = reader.read(); // 反复调用read()方法，直到返回-1
					if (n == -1) {
						break;
					}
					System.out.println((char)n); // 打印char
				}
				reader.close(); // 关闭流
			因为编码不一样所以，读取一个utf-8的文件会出现乱码。
			需要指定编码：
				Reader r = new FileReader("文件路径"，StandardCharsets.UTF-8);
				
			Reader也是资源使用try(resource)保证Reader无论有无IO错误都正常关闭：
				try(Reader r = new FileReader("文件路径"，StandardCharsets.UTF-8)){}
			
			也能使用read(char[] c)方法一次读取多个字符并填充到char[]数组，它返回实际读入个数，最大不超过数组长度，返回-1表示流结束。
			可添加缓冲区，每次尽可能的填充缓冲区：
				try (Reader reader = new FileReader("src/readme.txt", StandardCharsets.UTF_8)) {
				char[] buffer = new char[1000];
				int n;
				while ((n = reader.read(buffer)) != -1) {
					System.out.println("read " + n + " chars.");
			
		CharArrayReader(字符数组阅读器)：
			CharArrayReader可在内存中模拟一个Reader，为了将一个char[]数组变为一个Reader,和ByteArrayInputStream类似：
				try (Reader reader = new CharArrayReader("Hello".toCharArray())) {}
		
		StringReader：
			和CharArrayReader几乎一样，StringReader可直接将String作为数据源：
				try (Reader reader = new StringReader("Hello")) {}
		
		InputStreamReader(输入流阅读器)：
			Reader本质上是基于InputStream的byte到char的转换器，如果将InputStream转换为Reader是可行的。
			InputStreamReader就是这样的转换器，可将任何InputStream转换为Reader：
				// 持有InputStream:
				InputStream input = new FileInputStream("src/readme.txt");
				// 变换为Reader:
				Reader reader = new InputStreamReader(input, "UTF-8");
			
			以上可简写：
				try(Reader reader = new InputStreamReader(new FileInputStream("文件地址", "UTF-8"))){}
				这是FileReader的一种方式。
				使用try(resource)结构时，关闭Reader，会在内部调用InputStream的close方法，我们只需要关闭最外层的Reader对象。
		使用InputStreamReader可将InputStream转换成Reader。
		
		结：
			Reader定义了所有字符输入流的超类：

			FileReader实现了文件字符流输入，使用时需要指定编码；
			CharArrayReader和StringReader可以在内存中模拟一个字符流输入。
			Reader是基于InputStream构造的：可以通过InputStreamReader在指定编码的同时将任何InputStream转换为Reader。

			总是使用try (resource)保证Reader正确关闭。
	
	
	Writer(写)：
	
		Reader是带编码转换器的InputStream，将byte转换成char，
		Write是带编码转换器的OutputStream，将char转换成byte并输出。
		
		wirter和OutputStream的区别：
			OutputStream							Writer
			字节流，以byte为单位					字符流，以char为单位
			写入字节（0~255）：void write(int b)	写入字符（0~65535）：void write(int c)
			写入字节数组：void write(byte[] b)		写入字符数组：void write(char[] c)
			无对应方法								写入String：void write(String s)
			
			Writer是所有字符输出流的超类，它提供的方法主要有：
				写入一个字符（0~65535）：void write(int c)；
				写入字符数组的所有字符：void write(char[] c)；
				写入String表示的所有字符：void write(String s)。		
			
			
		FileWriter(文件写)：
			这是向文件中写入字符流的Writer，使用方法和FileReader类似：
				try (Writer writer = new FileWriter("readme.txt", StandardCharsets.UTF_8)) {
					writer.write('H'); // 写入单个字符
					writer.write("Hello".toCharArray()); // 写入char[]
					writer.write("Hello"); // 写入String
			
		CharArrayWriter(字符数组输出)：
			可在内存中创建一个Writer，其实际上是构造一个缓冲区，可写入char，最后写入的char[]数组，
			和ByteArrayOutputStream类似：
				
		
		StringWriter(字符串写入器)：
			基于内存的Writer，它和CharArrayWriter类似。StringWriter内部维护一个StringBuffer，并对外提供Writer接口。
		
		OutputStreamWriter(输出输出流写入器)：
			普通Writer基于OutputStream构造的，接收char，内部自动转换一个或多个byte，并写入OutputStream。
			所以这个写入器就是一个将任意OutputStream转换成Writer的转换器：
				try (Writer writer = new OutputStreamWriter(new FileOutputStream("readme.txt"), "UTF-8")) {}
				以上代码是FileWriter一种实现方式，和上一节的InputStreamReader是一样的。
		
		结：
			Writer定义了所有字符输出流的超类：

			FileWriter实现了文件字符流输出；

			CharArrayWriter和StringWriter在内存中模拟一个字符流输出。

			使用try (resource)保证Writer正确关闭。

			Writer是基于OutputStream构造的，可以通过OutputStreamWriter将OutputStream转换为Writer，转换时需要指定编码。
			
			
	
	PrintStream和PrintWriter(打印流和打印写入器)：
		PrintStream是一种FileOutputStream，在OutputStream的接口上，额外提供了各种数据类型方法：
		print()中可传入int、boolean、String、Object类型，Object相当于object.toString()。
		加上ln实现输出并换行。
		常使用的System.out.println()实际上就是PrintStream打印各种数据。System.out是系统默认提供的PrintStream：
			System.out.print(12345); // 输出12345
			System.out.print(new Object()); // 输出类似java.lang.Object@3c7a835a
			System.out.println("Hello"); // 输出Hello并换行
		System.err是系统默认提供的标准错误输出。
		PrintStream和OutputStream相比，除了print和println方法，可打印各种数据类型，还不会抛出IOException，
		在编写代码的时候就不用捕获IOException。
		
		PrintWriter：
			PrintStream最终输出是byte数据，PrintWriter是扩展Writer接口，print/println方法最终输出是char数据。
			两者使用一样。
			StringWriter buffer = new StringWriter();
			try (PrintWriter pw = new PrintWriter(buffer)) {
				pw.println("Hello");
				pw.println(12345);
				pw.println(true);
			}
			System.out.println(buffer.toString());
		
		结：
			PrintStream是一种能接收各种数据类型的输出，打印数据时比较方便：

			System.out是标准输出；
			System.err是标准错误输出。
			PrintWriter是基于Writer的输出。
			
			
			
日期与时间：
	
	基本概念：
		日期和时间是不同的，
			2020-1-12是日期，
			12：30：59 and 2020-1-12 20：12：21是时间
		日期是指某一天，不是连续变化，而是离散的。
		时间两种概念，带日期和不带日期的，带日期的才能确定唯一某时某刻，不带日期的无法确定唯一时刻。
		
		本地时间：
			全球不同地区本地时间是不同的。
			全球一共24个时区，伦敦为标准时区，其他时区按东/西偏移小时区分，北京所在时区为东八区。
			
		时区：
			只有本地时间无法确定一个准确的时刻，需要给本地时间加上一个时区，时区表达方式有好几种。
			
			一种是以GMT或UTC加时区偏移表示：GMT+08:00或者UTC+08:00表示东八区。
			GMT和UTC是基本等价的，只是UTC使用更精准的原子钟计时，每隔几年会有一个闰秒，但是在开发程序时会忽略两者的误差，
			因为计算机时钟在联网时会自动与时间服务器同步时间。
			
			一种是缩写，CST表示China Standard Time，也就是中国标准时间。但是CST也可以表示美国中部时间Central Standard Time USA，
			因此，缩写容易产生混淆，我们尽量不要使用缩写。
			
			还有一种是洲/城市表示的，Asia/Shanghai，表示上海所在地的时区。特别注意城市名称不是任意的城市，而是由国际标准组织规定的城市。
			
			因为时区存在，东八区2019.11.20早上8：15和西五区2019.11.19晚上19：15，这两个的时刻是相同的。
			
			时刻相同意思是，在不同时区的两人，在通话时候，各自说出自身手表上时间，虽然本地时间不同，但两个时间表示的时刻相同。
	
			
		夏令时：
			夏令时比时区更为复杂。夏令时是从夏天开始的额时候，将时间往后拨一个小时，夏天结束的时候再把时间往前拨一个小时。
			中国实行过一段时间但是因为国情被废除了，美国还在使用。
			
			时区				2019-11-20		2019-6-20
			GMT-05:00			19:00			19:00
			UTC-05:00			19:00			19:00
			America/New_York	19:00			20:00
			实行夏令时的不同地区，进入和退出夏令时的时间很可能是不同的。同一个地区，根据历史上是否实行过夏令时，
			标准时间在不同年份换算成当地时间也是不同的。因此，计算夏令时，没有统一的公式，必须按照一组给定的规则来算，
			并且，该规则要定期更新。
			
			夏令时不需要自己进行计算，可调用标准库提供的相关类。
			
		
		本地化：
			在计算机中，通常使用Locale表示一个国家或地区的日期、时间、数字、货币等格式。Locale由语言_国家的字母缩写构成，
			例如，zh_CN表示中文+中国，en_US表示英文+美国。语言使用小写，国家使用大写。
			不同日期，不同的Locale(区域)，中、美表示方式：
				zh_CN：2016-11-30
				en_US：11/30/2016
			
		结：
			在编写日期和时间的程序前，我们要准确理解日期、时间和时刻的概念。

			由于存在本地时间，我们需要理解时区的概念，并且必须牢记由于夏令时的存在，同一地区用GMT/UTC和城市表示的时区可能导致时间不同。

			计算机通过Locale来针对当地用户习惯格式化日期、时间、数字、货币等。	
			
	

	Date和Calendar(日期和日历)：
		(Epoch time)时刻是计算1940年1月1日零点到现在所经历的秒数：
		1574208900表示从1970年1月1日零点GMT时区到高时刻一共经历的秒数，换成伦敦、北京、纽约的时间分别是：
		1574208900	= 北京时间2019-11-20 8:15:00
					= 伦敦时间2019-11-20 0:15:00
					= 纽约时间2019-11-19 19:15:00
		Epoch Time又称为时间戳，在不同的编程语言中，会有几种存储方式：
			以秒为单位的整数：1574208900，缺点是精度只能到秒；
			以毫秒为单位的整数：1574208900123，最后3位表示毫秒数；
			以秒为单位的浮点数：1574208900.123，小数点后面表示零点几秒。	
			
			它们之间转换很简单，java程序中，时间戳通常使用long进行表示的毫秒数：
				long t = 1574208900123L;
			使用System.currentTimeMillis()这是java获取时间戳最常用的方式。
			
		标砖库API：
			标准库中有两套处理日期和时间的API，因为历史遗留原因，旧的API存在很多问题，所以引入新的API：
				旧的在java.util包中，主要包括Date、Calendar和TimeZone类。
				新的从java8引入，java.time包中，包括LocalDateTime、ZonedDateTime、ZoneId等。
				要在需要时在新旧API之间进行切换。
		
		Date(日期)：
			java.util.Date用于表示一个日期和时间的对象，java.sql.Date是作用于数据库中。
			Date的基本用法：
				// 获取当前时间:
				Date date = new Date();
				System.out.println(date.getYear() + 1900); // 必须加上1900
				System.out.println(date.getMonth() + 1); // 0~11，必须加上1
				System.out.println(date.getDate()); // 1~31，不能加1
				// 转换为String:
				System.out.println(date.toString());
				// 转换为GMT时区:
				System.out.println(date.toGMTString());
				// 转换为本地时区:
				System.out.println(date.toLocaleString());
				输出结果：
					2020
					8
					8
					Sat Aug 08 14:45:55 HKT 2020
					8 Aug 2020 06:45:55 GMT
					2020年8月8日 下午2:45:55
			
			getYear()返回的年份必须加上1900，getMonth()返回月份是0-11所以要+1，getDate()返回日期范围是1-31.
				//y=年	 	year
				//M=月 	 	Month
				//d=日	 	day
				//H=小时	hour
				//m=分钟	minute
				//s=秒	 	second
				
			
			// 获取当前时间:
			Date date = new Date();
			var sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
			System.out.println(sdf.format(date));
			SimpleDateFormat()中指定日期格式：2020-08-08 07:45:40
			一般来说字母越长输出越长如果d是日的话：
				d输入1 一号
				dd输出01
				ddd输出001
				dddd输出0001
			
			Date很严重的问题是不能转换时区，除了toGMTString()可以按GMT+0:00输出外，Date总是以当前计算机默认时区进行输出，
			并且我们很难弄对日期和时间进行加减，计算两个日期差多少天，计算某个月第一个星期一的日期等。
		
		Calendar(日历)：	
			可用于获取并设置年月日时分秒(Y M D H M S)，和Date相比，主要多了可做简单日期和时间运算的功能。
			例子：
				// 获取当前时间:
				Calendar c = Calendar.getInstance();
				int y = c.get(Calendar.YEAR);	年
				int m = 1 + c.get(Calendar.MONTH);	月
				int d = c.get(Calendar.DAY_OF_MONTH);	日
				int w = c.get(Calendar.DAY_OF_WEEK);	周
				int hh = c.get(Calendar.HOUR_OF_DAY);	小时
				int mm = c.get(Calendar.MINUTE);	分钟
				int ss = c.get(Calendar.SECOND);	秒
				int ms = c.get(Calendar.MILLISECOND);	毫秒
				效果：2020-8-8 7 8:25:51.547
				其返回的年份不转换，返回月份+1，星期1-7表示周日、周一...周六，
				Calendar只有一种方式获取，Clendar.getInstance(),并且直接就获取到当前时间，如果像设定
				指定时间和日期，必须清楚所有字段。
			
			使用Calendar设置指定日期如下：
				Calendar c=Calendar.getInstance();	获取当前时间
				c.lear();	清楚所有日期数据
				c.set(Calendar.YEAR, 2020);		设置年份为2020年
				c.set(Calendar.MONTH, 8);		月份设置为8月
				c.set(Calendar.DATE, 2);		日期设置为2号
				c.set(Calendar.HOUR_OF_DAY, 21);设置时间为21点
				c.set(Calendar.MINUTE, 22);		分钟设置为22
				c.set(Calendar.SECOND, 23);		秒数设置为23
				System.out.println(new SimpleDateFormat("yyyy-MM-dd HH::mm:ss").format(c.getTime()));
				设置日期格式，利用Calendar.getTime()将一个Calendar对象转换成Date对象，可用SimpleDateFormat进行格式化。
			
		TimeZone(时区)：
			Calendar和Date相比，它提供了时区转换的功能;
				TimeZone tzDefault = TimeZone.getDefault(); 				// 当前时区
				TimeZone tzGMT9 = TimeZone.getTimeZone("GMT+09:00"); 		// GMT+9:00时区
				TimeZone tzNY = TimeZone.getTimeZone("America/New_York");	// 纽约时区
				System.out.println(tzDefault.getID()); 						// Asia/Shanghai
				System.out.println(tzGMT9.getID()); 						// GMT+09:00
				System.out.println(tzNY.getID()); 							// America/New_York
			时区的唯一标识时以字符串表表示的ID，获取指定TimeZone对象也是以这个ID为参数获取，GMT+09:00和America/New_York都是
			有效的时区ID，要列出系统支持的所有ID，使用TimeZone.getAvailableIDs()。
			通过指定时区可对该时区进行转换：
				// 当前时间:
				Calendar c = Calendar.getInstance();
				// 清除所有:
				c.clear();
				// 设置为北京时区:
				c.setTimeZone(TimeZone.getTimeZone("Asia/Shanghai"));
				// 设置年月日时分秒:
				c.set(2019, 10 /* 11月 */, 20, 8, 15, 0);
				// 显示时间:
				var sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
				sdf.setTimeZone(TimeZone.getTimeZone("America/New_York"));
				System.out.println(sdf.format(c.getTime()));
				// 2019-11-19 19:15:00
			
			利用时区Calendar进行时区转换的步骤：
				1.清楚所有字段。
				2.设定指定时区。
				3.设定日期和时间。
				4.创建SimpkeDateFormat并设定目标时区。
				5.格式化获取的Date对象(注意Date对象无时区信息，时区信息存储在SimpleDateFormat中)。
				所以本质上时区转换只能通过SimpleDateFormat在显示的时候完成。
				
			Calendar可对日期和时间进行间的的加减：
				 // 当前时间:
				Calendar c = Calendar.getInstance();
				// 清除所有:
				c.clear();
				// 设置年月日时分秒:
				c.set(2019, 10 /* 11月 */, 20, 8, 15, 0);
				// 加5天并减去2小时:
				c.add(Calendar.DAY_OF_MONTH, 5);
				c.add(Calendar.HOUR_OF_DAY, -2);
				// 显示时间:
				var sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
				Date d = c.getTime();
				System.out.println(sdf.format(d));
				// 2019-11-25 6:15:00
				时先设置一个时间在对年月日时分秒进行单独的加减操作。
			
		结：
			计算机表示的时间是以整数表示的时间戳存储的，即Epoch Time，Java使用long型来表示以毫秒为单位的时间戳，
			通过System.currentTimeMillis()获取当前时间戳。

			Java有两套日期和时间的API：

			旧的Date、Calendar和TimeZone；
			新的LocalDateTime、ZonedDateTime、ZoneId等。
			分别位于java.util和java.time包中。	
			
	
	
	LocalDateTime(本地日期时间)：
		java8，java.time提供新的日期和时间API：
			本地日期和时间：LocalDateTime、LocalDate，LocalTime。
			带时区的日期和时间：ZonedDateTime。
			时刻：Instant。
			时区：ZoneId，ZoneOffset。
			时间间隔：Duration。
		用于取代SimpleDateFormat的格式化类型DateTimeFormatter。
		新的API严格区分时刻、本地日期、本地时间和带时区的日期时间，并且日期和时间运算更方便。
		还修正了不合理的常量设计：
			现Month范围用1~12表示1-12个月。
			线Week范围用1~7表示周一到周日。
		新的API几乎全是不可变类型(和String类似)，可放心使用不担心修改。
		
		LocalDateTime(本地日期时间)：
			这是最常用的，用于表示本地日期和时间。
			LocalDate()		当前日期
			LocalTime()		当前时间
			LocalDateTime() 当前日期和时间
			严格按照ISO 8601标准格式打印
			每行代码打印会消耗时间，所以三个时期可能对应不上，毫秒数不同，改如下：
				LocalDateTime dt=LocalDateTime.now();	获取到当前时间
				dt.toLocalDate();	转换到当前日期
				dt.toLocalTime();	转换到当前时间
			通过指定日期创建LocalDateTime通过of()方法：
				LocalDate d2 = LocalDate.of(2019, 11, 30); // 2019-11-30, 注意11=11月
				LocalTime t2 = LocalTime.of(15, 16, 17); // 15:16:17
				LocalDateTime dt2 = LocalDateTime.of(2019, 11, 30, 15, 16, 17);
				LocalDateTime dt3 = LocalDateTime.of(d2, t2);
			
			注意ISO 8601规定的日期和时间分隔符是T。标准格式如下：
				日期：yyyy-MM-dd
				时间：HH:mm:ss
				带毫秒的时间：HH:mm:ss.SSS
				日期和时间：yyyy-MM-dd'T'HH:mm:ss
				带毫秒的日期和时间：yyyy-MM-dd'T'HH:mm:ss.SSS	
			
		DateTimeFormatter(日期时间格式化程序)：
			自定义输出将非ISO8601字符串解析成LocalDateTime，使用DateTimeFormatter：
				 // 自定义格式化:
				DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
				System.out.println(dtf.format(LocalDateTime.now()));

				// 用自定义格式解析:
				LocalDateTime dt2 = LocalDateTime.parse("2019/11/30 15:16:17", dtf);
			
			localDateTime提供对日期和时间进行加减的简单链式调用：
				LocalDateTime dt = LocalDateTime.of(2019, 10, 26, 20, 30, 59);
				// 加5天减3小时:
				LocalDateTime dt2 = dt.plusDays(5).minusHours(3);
				System.out.println(dt2); // 2019-10-31T17:30:59
				// 减1月:
				LocalDateTime dt3 = dt2.minusMonths(1);
				System.out.println(dt3); // 2019-09-30T17:30:59
			
			对日期和时间进行调整则使用withXxx()方法，例如：withHour(15)会把10:11:12变为15:11:12：	
				调整年：withYear()
				调整月：withMonth()
				调整日：withDayOfMonth()
				调整时：withHour()
				调整分：withMinute()
				调整秒：withSecond()
			
				LocalDateTime dt = LocalDateTime.of(2019, 10, 26, 20, 30, 59);
				System.out.println(dt);
				// 日期变为31日:
				LocalDateTime dt2 = dt.withDayOfMonth(31);
				System.out.println(dt2); // 2019-10-31T20:30:59
				// 月份变为9:
				LocalDateTime dt3 = dt2.withMonth(9);
				System.out.println(dt3); // 2019-09-30T20:30:59
			
			相应的10-31调整为9月的时候日期也自动变为30。
			
				localDateTime的通用Witch方法允许做复杂的运算：
					 // 本月第一天0:00时刻:
				LocalDateTime firstDay = LocalDate.now().withDayOfMonth(1).atStartOfDay();
				System.out.println(firstDay);

				// 本月最后1天:
				LocalDate lastDay = LocalDate.now().with(TemporalAdjusters.lastDayOfMonth());
				System.out.println(lastDay);

				// 下月第1天:
				LocalDate nextMonthFirstDay = LocalDate.now().with(TemporalAdjusters.firstDayOfNextMonth());
				System.out.println(nextMonthFirstDay);

				// 本月第1个周一:
				LocalDate firstWeekday = LocalDate.now().with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));
				System.out.println(firstWeekday);
			
			
			要判断两个LocalDateTime的先后，可以使用isBefore()、isAfter()方法，对于LocalDate和LocalTime类似：
				ocalDateTime now = LocalDateTime.now();
				LocalDateTime target = LocalDateTime.of(2019, 11, 19, 8, 15, 0);
				System.out.println(now.isBefore(target));
				System.out.println(LocalDate.now().isBefore(LocalDate.of(2019, 11, 19)));
				System.out.println(LocalTime.now().isAfter(LocalTime.parse("08:15:00")));
			
			
			注意到LocalDateTime无法与时间戳进行转换，因为LocalDateTime没有时区，无法确定某一时刻。ZonedDateTime相当于LocalDateTime加时区的组合，它具有时区，可以与long表示的时间戳进行转换。
			
						
			
		Duration和Period(时长和周期)：	
			Duration表示两个时刻之间的时间间隔，Period表示两个日期之间的天数：
				LocalDateTime start = LocalDateTime.of(2019, 11, 19, 8, 15, 0);
				LocalDateTime end = LocalDateTime.of(2020, 1, 9, 19, 25, 30);
				Duration d = Duration.between(start, end);
				System.out.println(d); // PT1235H10M30S
				Period p = LocalDate.of(2019, 11, 19).until(LocalDate.of(2020, 1, 9));
				System.out.println(p); // P1M21D
				
				PT1235H10M30S 表示1235小时10分钟30秒
				P1M21D 表示1个月21天
				
			Duration和Period，P...T...形式表示，P...T...表示日期间隔，T后表示时间间隔，PT表示只有时间间隔。
			ofXXX()和parse()方法可直接创建Duration
			
		
		结：
			Java 8引入了新的日期和时间API，它们是不变类，默认按ISO 8601标准格式化和解析；

			使用LocalDateTime可以非常方便地对日期和时间进行加减，或者调整日期和时间，它总是返回新对象；

			使用isBefore()和isAfter()可以判断日期和时间的先后；

			使用Duration和Period可以表示两个日期和时间的“区间间隔”。	
			
			
	ZonedDateTime(时区日期时间)：		
		LocalDateTime表示本地日期时间，ZoneDateTime表示带时区的日期时间。
		可简单将ZonedDateTime理解成LocalDateTime加ZoneId,Zoneid是Java.time引入新的时区类。

		创建ZonedDateTime对象方法：
		
			通过now()方法返回当前时间：
				ZonedDateTime zbj = ZonedDateTime.now(); // 默认时区
				ZonedDateTime zny = ZonedDateTime.now(ZoneId.of("America/New_York")); // 用指定时区获取当前时间
				输出结果：
					2020-08-11T06:01:25.595922Z[Etc/UTC]
					2020-08-11T02:01:25.617807-04:00[America/New_York]
					结果除了时区不同时间却是同一时刻，毫秒不同是执行语句的时间差。
				
			通过LocalDateTime附加一个ZoneId，变成ZonedDateTime：
				LocalDateTime ldt = LocalDateTime.of(2019, 9, 15, 15, 16, 17);
				ZonedDateTime zbj = ldt.atZone(ZoneId.systemDefault());
				ZonedDateTime zny = ldt.atZone(ZoneId.of("America/New_York"));
				输出结果：
					2019-09-15T15:16:17+08:00[Asia/Shanghai]
					2019-09-15T15:16:17-04:00[America/New_York]
					日期和时间与LocalDateTime相同，附加的时区不同，所以是两个不同的时刻。
		
		
		时区转换：
			转换时区需要ZonedDateTime对象，通过withZoneSameInstant()将关联时区转移到另一个时区，转换后日期和时间会相应调整。
			日期转换的时候可能会有夏令时，文中原话：
				 涉及到时区时，千万不要自己计算时差，否则难以正确处理夏令时。
			将北京时间转换为纽约时间：
				 // 以中国时区获取当前时间:
				ZonedDateTime zbj = ZonedDateTime.now(ZoneId.of("Asia/Shanghai"));
				// 转换为纽约时间:
				ZonedDateTime zny = zbj.withZoneSameInstant(ZoneId.of("America/New_York"));
				输出结果：
					2020-08-11T16:52:53.049556+08:00[Asia/Shanghai]
					2020-08-11T04:52:53.049556-04:00[America/New_York]
					输出结果可能由于夏令时原因有所区别，夏令时纽约会比正常的多一个小时。
			
			使用ZonedDateTime将其转换为本地时间就很简单：
				ZonedDateTime zdt = ...
				LocalDateTime ldt = zdt.toLocalDateTime();
				转换为LocalDateTime时，直接丢弃了时区信息。
			
			
		结：
			ZonedDateTime是带时区的日期和时间，可用于时区转换；

			ZonedDateTime和LocalDateTime可以相互转换。	
						
			
			
	DateTimeFormatter(日期时间格式化)：		
		旧Date对象使用，SimpleDateFormat进行格式化显示。
		使用新的LocalDateTime和ZonedLocalDateTime，使用DateTimeFormatter进行格式化显示。
		DateTimeFormatter是不变对象，而且线程安全，可只创建一个实例，到处引用。
		SimpleDateFormat不是线程安全的，使用时，只能在方法内部创建新的局部变量。
		
		创建DateTimeFormatter时，可通过格式化字符串实现：
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
			
		按照Locale默认习惯格式化：	
			ZonedDateTime zdt = ZonedDateTime.now();	
			var formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm ZZZZ");
			var zhFormatter = DateTimeFormatter.ofPattern("yyyy MMM dd EE HH:mm", Locale.CHINA);
			var usFormatter = DateTimeFormatter.ofPattern("E, MMMM/dd/yyyy HH:mm", Locale.US);
			
			输出结果：
				2020-08-11T09:12 GMT
				2020 8月 11 周二 09:12
				Tue, August/11/2020 09:12
			
			直接调用System.out.println对ZonedDateTime或LocalDateTime实例进行打印时，实际上调用的是其的toString()方法，
			默认toString()按照ISO8601显示。通过DateTimeFormatter预定义的几个静态变量引用：
				var ldt = LocalDateTime.now();
				System.out.println(DateTimeFormatter.ISO_DATE.format(ldt));
				System.out.println(DateTimeFormatter.ISO_DATE_TIME.format(ldt));
				
				输出结果和toString()类似：
					2019-09-15
					2019-09-15T23:16:51.56217
			
		结：
			对ZonedDateTime或LocalDateTime进行格式化，需要使用DateTimeFormatter类；

			DateTimeFormatter可以通过格式化字符串和Locale对日期和时间进行定制输出。			
			
			
			
	Instant(当前时间)：		
		计算机存储时间本质是一个不断递增的整数，Java提供的System.currentTimeMills()返回以毫秒表示当前时间戳。
		当前时间戳以java.time中Instant表示，使用Instant.now()获取当前时间戳，效果和System.currentTimeMills()类似。
		Instant now = Instant.now();
        System.out.println(now.getEpochSecond()); // 秒
        System.out.println(now.toEpochMilli()); // 毫秒
		
		Instant内部只有两个核心字段：		
			public final class Instant implements ... {
				private final long seconds;
				private final int nanos;
			}
			
		一个是以秒为单位的时间戳，一个是更精确的纳秒精度。它和System.currentTimeMillis()返回的long相比，只是多了更高精度的纳秒。	
			
		因为Instant是时间戳，给它附上时区，就可创建出ZonedDateTime。
		// 以指定时间戳创建Instant:
		Instant ins = Instant.ofEpochSecond(1568568760);
		ZonedDateTime zdt = ins.atZone(ZoneId.systemDefault());
			输出结果：
				2019-09-16T01:32:40+08:00[Asia/Shanghai]
			
			
		对某时间戳，关联上指定的ZoneId，就能得到ZonedDateTime，继而获得对应时区的LocalDateTime。	
		所以，LocalDateTime，ZoneId，Instant，ZonedDateTime和long都可以互相转换：	
			┌─────────────┐
			│LocalDateTime│────┐
			└─────────────┘    │    ┌─────────────┐
							   ├───>│ZonedDateTime│
			┌─────────────┐    │    └─────────────┘
			│   ZoneId    │────┘           ▲
			└─────────────┘      ┌─────────┴─────────┐
								 │                   │
								 ▼                   ▼
						  ┌─────────────┐     ┌─────────────┐
						  │   Instant   │<───>│    long     │
						  └─────────────┘     └─────────────┘
			转换时只用留意long类型以毫秒还是秒为单位即可。
			
		结：
			Instant表示高精度时间戳，它可以和ZonedDateTime以及long互相转换。	
			
			
			
	最佳实践：
		有新旧API，除非涉及遗留代码，否则使用新的。
		
		旧API转新API：
			旧式Date或Calendar转为新的API对象，可通过toInstant()方法转为Instant对象，再转换为ZonedDateTime：
				// Date -> Instant:
				Instant ins1 = new Date().toInstant();

				// Calendar -> Instant -> ZonedDateTime:
				Calendar calendar = Calendar.getInstance();
				Instant ins2 = Calendar.getInstance().toInstant();
				ZonedDateTime zdt = ins2.atZone(calendar.getTimeZone().toZoneId());
				旧的TimeZone提供了toZoneId()，将自己变成新的ZoneId。
		
		
		新API转旧API：
			新ZonedDateTime转旧API，只能借助long时间戳做中转：
				// ZonedDateTime -> long:
				ZonedDateTime zdt = ZonedDateTime.now();
				long ts = zdt.toEpochSecond() * 1000;

				// long -> Date:
				Date date = new Date(ts);

				// long -> Calendar:
				Calendar calendar = Calendar.getInstance();
				calendar.clear();
				calendar.setTimeZone(TimeZone.getTimeZone(zdt.getZone().getId()));
				calendar.setTimeInMillis(zdt.toEpochSecond() * 1000);
				新ZoneId转为旧TimeZone，需要ZoneId.getId()返回String完成。
		
		数据库中存储日期和时间：
			在数据库中，也存在几种日期和时间类型：

				DATETIME：表示日期和时间；
				DATE：仅表示日期；
				TIME：仅表示时间；
				TIMESTAMP：和DATETIME类似，但是数据库会在创建或者更新记录的时候同时修改TIMESTAMP。
			
					
			在使用Java程序操作数据库时，我们需要把数据库类型与Java类型映射起来。下表是数据库类型与Java新旧API的映射关系：

				数据库			对应Java类（旧）	对应Java类（新）
				DATETIME		java.util.Date		LocalDateTime
				DATE			java.sql.Date		LocalDate
				TIME			java.sql.Time		LocalTime
				TIMESTAMP		java.sql.Timestamp	LocalDateTime
			数据库中存储最常用的是时刻(Instant)，因为有时刻信息，可根据用户自己选择的时区，显示正确的本地实际那，最好用long表示，
			数据库存储为BigInt类型。
		
			通过long时间戳，编写timestampToString()方法，为不同用户不同偏好显示不同的本地时间：
				 long ts = 1574208900000L;
					System.out.println(timestampToString(ts, Locale.CHINA, "Asia/Shanghai"));
					System.out.println(timestampToString(ts, Locale.US, "America/New_York"));
				}

				static String timestampToString(long epochMilli, Locale lo, String zoneId) {
					Instant ins = Instant.ofEpochMilli(epochMilli);
					DateTimeFormatter f = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM, FormatStyle.SHORT);
					return f.withLocale(lo).format(ZonedDateTime.ofInstant(ins, ZoneId.of(zoneId)));
				}
				输出结果：	2019年11月20日 上午8:15
							Nov 19, 2019, 7:15 PM
			
		结：
			处理日期和时间时，尽量使用新的java.time包；

			在数据库中存储时间戳时，尽量使用long型时间戳，它具有省空间，效率高，不依赖数据库的优点。	




单元测试(JUnit)：			
	介绍java最常用测试框架JUnit，介绍如何编写单元测试。
	
	编写JUnit测试：
		测试驱动开发，先编写接口，再编写测试。
		然后进行真正编写实现代码，一边写一边测，测试全通过表示编写实现完成：
			编写接口
			 │
			 ▼
			编写测试
			 │
			 ▼
		┌─> 编写实现
		│    │
		│ N  ▼
		└── 运行测试
			 │ Y
			 ▼
			任务完成
		这就是TDD：https://baike.baidu.com/item/TDD/9064369?fr=aladdin
		
		一般都是编写实现代码，需要对已有代码进行测试。
		测试例子：https://www.liaoxuefeng.com/wiki/1252599548343744/1304048154181666
		测试的时候使用main方法则有很多缺点，一次只有一个main方法，不能将测试代码分离，再是没有打印出测试结果和期望结果。
		
		JUnit(测试框架)：
			是哟个开源java单元测试框架，针对java设计使用广泛，是单元测试的标准框架。
			好处是可以简单组织测试代码，随时运行JUnit给出成功的测试和失败测试，并可以生成测试报告，出了测试成功率，
			也能统计测试代码覆盖率，高质量代码覆盖率在80%以上。
			
			测试用例可能有多个，当有多个时则需要选择用例上的@Test单独运行用例。
			只有一个用例的话则可直接运行。
			
		单元测试好处：
			可以保证单个方法按正确预期运行，修改某方法代码，只要其对应单元测试通过就认为正确。并且测试代码可作为示例代码，
			演示如何调用该方法。
			
			使用JUnit进行单元测试可使用断言(Assertion)测试期望结果，方便组织和运行测试，并方便查看结果。Junit可直接在IDE运行，
			方便集成到Maven自动化工具中运行。
			
			测试单元时遵循一定规范。
			单元测试代码必须非常简单，能一下明白，不能再为测试代码编写测试。
			每单元测试相互独立，不依赖运行顺序。
			测试时覆盖常用测试用例，并注意测试边界条件，如输入为0、bull、空字符串""等等。
		
		结：
			JUnit是一个单元测试框架，专门用于运行我们编写的单元测试：

			一个JUnit测试包含若干@Test方法，并使用Assertions进行断言，注意浮点数assertEquals()要指定delta。
			
	

	使用Fixture(固定代码)：
		JUnit提供编写测试前的准备，测试后清理的固定代码，称为Fixture。
			@BeforeEach
			public void setUp() {
				this.calculator = new Calculator();
			}
		
			@AfterEach
			public void tearDown() {
				this.calculator = null;
			}
			
			@Test
			void testAdd() {
				assertEquals(100, this.calculator.add(100));
				assertEquals(150, this.calculator.add(50));
				assertEquals(130, this.calculator.add(-20));
			}
			
			@BeforeEach注解是测试前的准备方法。
			@AfterEach注解是测试后的清理方法。
			以上两个注解的方法会在每个@Test注解方法前后自动运行：
				for (Method testMethod : findTestMethods(CalculatorTest.class)) {
					var test = new CalculatorTest(); // 创建Test实例
					invokeBeforeEach(test);
						invokeTestMethod(test, testMethod);
					invokeAfterEach(test);
				}
			
			
			有些资源初始化或清理很繁琐，时间长。JUnit提供了@BeforeAll和@AfterAll，再运送所有@Test前后运行。
				invokeBeforeAll(CalculatorTest.class);
				for (Method testMethod : findTestMethods(CalculatorTest.class)) {
					var test = new CalculatorTest(); // 创建Test实例
					invokeBeforeEach(test);
						invokeTestMethod(test, testMethod);
					invokeAfterEach(test);
				}
				invokeAfterAll(CalculatorTest.class);
			
			
		@BeforeAll和@AfterAll再所有@Test方法运行前后只运行一次，因此只能初始化静态变量：
			@BeforeAll
			public static void initDatabase() {}
			@AfterAll
			public static void dropDatabase() {}
			
			
		编写Fixture方法：
			1.实例变量，再@BeforeEach中初始化，@AfterEach中清理，在各个@Test方法中互不影响，因为是不同实例。
			2.静态变量，在@BeforeEach中初始化，@AfterAll清理，在各个@Test方法中均是唯一实例，会影响各个Test方法。
		
		大多数情况下，使用@BeforeEach和AfterEach就够了。只是某些资源初始化时间过长不得不复用时才会使用@BeforeAll和@AfterAll。
		
		每次运行一个@Test方法前，JUnit首先创建一个XxxTest实例，每个@Test方法内部的成员变量都是独立的，不能也无法将成员变量的
		状态从@Test方法带到另一个@Test方法。
		
		结：
			编写Fixture是指针对每个@Test方法，编写@BeforeEach方法用于初始化测试资源，编写@AfterEach用于清理测试资源；

			必要时，可以编写@BeforeAll和@AfterAll，使用静态变量来初始化耗时的资源，并且在所有@Test方法的运行前后仅执行一次。	
						
			
	
	异常测试：
		对可能抛出的异常进行测试，是很重要的环节，要针对可能导致异常的情况进行测试。
		对参数n进行判断，小于0就抛出异常。
			if (n < 0) {
				throw new IllegalArgumentException();
			}
		循环一次*一次变量
			long r = 1;
			for (long i = 1; i <= n; i++) {
				r = r * i;
			}
			return r;
			
		如果n值为负数则，直接抛出IllegalArgumentException异常。
		JUnit测试@Test方法：
			@Test
			void testNegative() {
				assertThrows(IllegalArgumentException.class, new Executable() {
					@Override
					public void execute() throws Throwable {
						Factorial.fact(-1);
					}
				});
			}
			
			JUnit提供assertThrows()来期望捕获一个指定的异常。第二个参数Executable封装了我们要执行的会产生异常的代码。
			当我们执行Factorial.fact(-1)时，必定抛出IllegalArgumentException。assertThrows()在捕获到指定异常时表示通
			过测试，未捕获到异常，或者捕获到的异常类型不对，均表示测试失败。
			
			Executeble匿名类比较繁琐，Java8引入函数式编程，简写如下：
				@Test
				void testNegative() {
					assertThrows(IllegalArgumentException.class, () -> {
						Factorial.fact(-1);
					});
				}
				->语法就是函数式接口的实现代码，通过这种固定代码编写能抛出异常的语句。
			
			
		结：
			测试异常可以使用assertThrows()，期待捕获到指定类型的异常；

			对可能发生的每种类型的异常都必须进行测试。	
			
			
	条件测试：
		某些方法不需要运行可标记@Disabled，被此注释标记的方法测试时不会运行。
		@Disabled这种注解称为条件测试，JUnit根据不同条件注解，解决是否运行当前的@Test方法。
		例子：
			public String getConfigFile(String filename) {
				String os = System.getProperty("os.name").toLowerCase();
				if (os.contains("win")) {
					return "C:\\" + filename;
				}
				if (os.contains("mac") || os.contains("linux") || os.contains("unix")) {
					return "/usr/local/" + filename;
				}
				throw new UnsupportedOperationException();
			}
			
			如果测试这个方法在Windows上运行，但是Windows和Linux路径不同，分别作两个测试方法：
				@Test
				@EnabledOnOs(OS.WINDOWS)
				void testWindows() {
					assertEquals("C:\\test.ini", config.getConfigFile("test.ini"));
				}

				@Test
				@EnabledOnOs({ OS.LINUX, OS.MAC })
				void testLinuxAndMac() {
					assertEquals("/usr/local/test.cfg", config.getConfigFile("test.cfg"));
				}
			
			@EnableOnOs就是一个条件测试判断。
			如果某方法不用再Windows上运行使用@DisabledOnOs(OS.WINDOWS)注解，将其改为OS.LINUX就是不在Linux上运行。
			在java9以上版本执行测试，加上@DisabledOnJre(JRE.JAVA_8)。
			只在64位操作系统上运行，使用@EnabledIfSystemProperty(named = "os.arch", matches = ".*64.*")。
			传入环境变量DEBUG=true才能测试，使用@EnabledIfEnvironmentVariable(named = "DEBUG", matches = "true")。
		
		结：
			条件测试是根据某些注解在运行期让JUnit自动忽略某些测试。		
			
			
	
	参数化测试：
		待测试的输入和输出是一组数据：将测试数据组织起来，用不同的测试数据调用相同的测试方式。
		参数测试和普通测试区别，测试方法需要接受至少一个参数，后，传入一组参数反复测试。
		JUnit提供一个@ParameterizedTest注解，用以进行参数化测试。
		
		对Math.abs()进行测试，测试：
			@ParameterizedTest
			@ValueSource(ints = { 0, 1, 5, 100 })
			void testAbs(int x) {
				assertEquals(x, Math.abs(x));
			}
			再将数据换成负数进行测试。
			@ParameterizedTest是参数化测试的注解，而不是@Test。
		
		
		如果编写StringUtils.capitalize()方法，会将字符串第一字母变为大写，后续变为小写：
			 if (s.length() == 0) {
				return s;
			}
			return Character.toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
			参数化测试，不但给输出还要预期输出，测试方法接受两个参数：
				@ParameterizedTest
				void testCapitalize(String input, String result) {
					assertEquals(result, StringUtils.capitalize(input));
				}
			最合适的方式使用@MethodSource注解，允许编写同名的静态方法提供测试参数：
				static List<Arguments> testCapitalize() {
					return List.of( // arguments:
							Arguments.arguments("abc", "Abc"), //
							Arguments.arguments("APPLE", "Apple"), //
							Arguments.arguments("gooD", "Good"));
				}
				提供一个静态方法，返回一组测试数据，每个参数包含两个String，正好对应测试方法两个参数传入。
			
			另一种传入方式使用@CsvSource，每一字符串表示一行，一行包含的若干参数使用，分割：
				@ParameterizedTest
				@CsvSource({ "abc, Abc", "APPLE, Apple", "gooD, Good" })
				void testCapitalize(String input, String result) {
					assertEquals(result, StringUtils.capitalize(input));
				}
			
			如果测试数据过多，@CsvSource很不方便，此时将测试数据放入独立的CSV文件下，标注上@CsvFileSource：
				@ParameterizedTest
				@CsvFileSource(resources = { "/test-capitalize.csv" })
				void testCapitalizeUsingCsvFile(String input, String result) {
					assertEquals(result, StringUtils.capitalize(input));
				}
				JUnit只在classpath中查找指定的CSV文件，因此，test-capitalize.csv文件放入test目录下：
				文件实例内容：
					apple, Apple
					HELLO, Hello
					JUnit, Junit
					reSource, Resource
						
		结：
			使用参数化测试，可以提供一组测试数据，对一个测试方法反复测试。

			参数既可以在测试代码中写死，也可以通过@CsvFileSource放到外部的CSV文件中。	
			
			

正则表达式：
	是用来匹配字符串的有力工具，Java内置了强大的表达式支持。
	
	正则表达式简介：
		判断字符串是否为电话号码、邮箱、时间等等，都要为其创建单独规则。
		判断手机号码实例(粗略判断)：
			boolean isValidMobileNumber(String s) {
				// 是否是11位？
				//判断字符串长度是否符合手机号的长度，如果不符合返回false
				if (s.length() != 11) {
					return false;
				}
				// 每一位都是0~9：
				//字符串长度为限制进行循环，使用当此循环的字符进行判断，时候小于0或大于9，符合条件则返回false。
				for (int i=0; i<s.length(); i++) {
					char c = s.charAt(i);
					if (c < '0' || c > '9') {
						return false;
					}
				}
				return true;
			}
		以上判断太过繁琐，使用正则表达式更为简便。
		如判断手机号长度使用：
			\d{11}。
		
		正则表达式的好处，一个正则表达式就是一个描述规则的字符串，只要编写正确的规则，就能让正则表达式引擎判断字符串是否符合规则。
		正则是一套规则，可用于任何语言，Java标准库java.util.regex包内置正则表达式引擎。
		判断年份是否是20XX年：
			正则为20\d\d，\d表示0~9任意一个数字
			正则在java中表示20\\d\\d，java字符串中\\表示\。
			字符串.matches(regex) 比较方法。
		.matches();	用于检测字符串是否匹配给定的正则表达式。	
			
		结：
			正则表达式是用字符串描述的一个匹配规则，使用正则表达式可以快速判断给定的字符串是否符合匹配规则。
			Java标准库java.util.regex内建了正则表达式引擎。	
						
			
			
	匹配规则：
		正则表达式从左到右匹配。
		如果其中有特殊字符，需要使用\转义，如，a\&c其中\&用来匹配特殊字符&的，只能匹配a&c。
		使用字符串.matches(匹配标准字符串)方法比较字符串是否一致。
		
		\&		匹配特殊字符&，Java中表示为\\&。
		\.		匹配任意字符，只匹配一个字符，java表示为\\。
		\d		匹配0~9任意数字，java表示为\\d。
		\D		匹配非数字，如A、#等等\d不能匹配的。
		\w		匹配一个字母、下划线、数字，但是不能匹配#和空格等字符。java表示为\\w。
		\W		匹配\w不能匹配的字符。
		\s		匹配空格字符还有tab字符(java中表示\t)，java表示为\\s。
		\S		匹配\不能匹配的字符。
		重复匹配：
			*可以匹配任意字符包括0:
				A：因为\d*可以匹配0个数字；
				A0：因为\d*可以匹配1个数字0；
				A380：因为\d*可以匹配多个数字380
			+匹配至少一个数字：
				\d+可以匹配一个数字0，也可以匹配多个数字123..等等，但是必须要匹配至少一个数字。
			？匹配0或1个字符，超过一个就不能匹配：
				A：因为\d?可以匹配0个数字；
				A0：因为\d+可以匹配1个数字0
			{n}精准指定n个字符，A\d{3}可以精确匹配：
				A380：因为\d{3}可以匹配3个数字380。
			{n~m}指定n~m个字符，A\d{3,5}可以精确匹配：
				A380：因为\d{3,5}可以匹配3个数字380；
				A3800：因为\d{3,5}可以匹配4个数字3800；
				A38000：因为\d{3,5}可以匹配5个数字38000。
					
			
		结：
			单个字符的匹配规则如下：
	
				正则表达式			规则						可以匹配
				A					指定字符					A
				\u548c				指定Unicode字符				和
				.					任意字符					a，b，&，0
				\d					数字0~9						0~9
				\w					大小写字母，数字和下划线	a~z，A~Z，0~9，_
				\s					空格、Tab键					空格，Tab
				\D					非数字						a，A，&，_，……
				\W					非\w						&，@，中，……
				\S					非\s						a，A，&，_，……
				
			多个字符的匹配规则如下：

				正则表达式			规则						可以匹配
				A*					任意个数字符				空，A，AA，AAA，……
				A+					至少1个字符					A，AA，AAA，……
				A?					0个或1个字符				空，A
				A{3}				指定个数字符				AAA
				A{2,3}				指定范围个数字符			AA，AAA
				A{2,}				至少n个字符					AA，AAA，AAAA，……
				A{0,3}				最多n个字符					空，A，AA，AAA	
			
			
			
	复杂匹配规则：
	
		匹配开头和结尾：
			正则表达式进行多行匹配时，^表示开头，$表示结尾。例如，^A\d{3}$，可以匹配"A001"、"A380"。
		匹配指定范围：
			[....]中可匹配范围内的字符，如[123456789]可匹配到1~9，同样的效果使用[1-9]也行。
			匹配大小写不限的十六进制数，如1Ab3c，可写成[0-9a-fA-F]，表示一共可匹配到一下任意范围的字符。
				0-9：字符0~9；
				a-f：字符a~f；
				A-F：字符A~F。
			如果要匹配6位十六进制数，前面讲过的{n}仍然可以继续配合使用：[0-9a-fA-F]{6}。
			[...]还有一种排除法，即不包含指定范围的字符。假设我们要匹配任意字符，但不包括数字，可以写[^1-9]{3}
				可以匹配"ABC"，因为不包含字符1~9；
				可以匹配"A00"，因为不包含字符1~9；
				不能匹配"A01"，因为包含字符1；
				不能匹配"A05"，因为包含字符5。
			
		或规则匹配：
			|链接的两个正则规则 是 或规则，AB|CD表示可以匹配AB或CD，也可以AB|CD|EF|....。
		
		使用括号：
			同时指定规则learn java、learn php、和learn go，简单的规则learn\sjava|learn\sphp|learn\sgo，但是比较复杂，
			可将部分提取使用(...)将子规则在其中进行表示learn\\s(java|php|go)，这里的话因为\\s是空格。
			
			
		结：
			复杂匹配规则主要有：
				正则表达式		规则					可以匹配
				^				开头					字符串开头
				$				结尾					字符串结束
				[ABC]			[…]内任意字符			A，B，C
				[A-F0-9xy]		指定范围的字符			A，……，F，0，……，9，x，y
				[^A-F]			指定范围外的任意字符	非A~F
				AB|CD|EF		AB或CD或EF				AB，CD，EF				
			
	
	
	分组匹配：
		(...)中写入子规则，如，learn\s(java|php|go)就可以更方便地匹配长字符串了。
		并且(...)更重要的分组匹配。
		String提供的indexOf()和substring()方法，从正则表达式匹配的字符串中提取字串没有通用性。
		需要引入java.util.regex包，用Pattern对象匹配，匹配后获得一个Matcher对象，匹配成功就能直接从Matcher.group(index)返回子串。
			Pattern p = Pattern.compile("(\\d{3,4})\\-(\\d{7,8})");
			Matcher m = p.matcher("010-12345678");
			if (m.matches()) {
				String g1 = m.group(1);
				String g2 = m.group(2);
			Matcher.group(index)方法参数用1表示第一个字串，2表示第二个，传入0表示获得整个正则表达式匹配的字符串。
			
		Pattern(模式)：
			分组提取的代码用的是java.util.regex包里面的Pattern类和Matcher类，这两种本质一样，String.matches()方法内部就是调用Pattern和Matcher类的方法。
			反复使用String.matches()对同一个正则表达式进行多次匹配效率低，因为每次都会创建一样的Pattern对象，完全可以创建出Pattern对象，反复使用，
			实现编译一次，多次匹配。
			
			Pattern pattern = Pattern.compile("(\\d{3,4})\\-(\\d{7,8})");
			pattern.matcher("010-12345678").matches(); // true
			pattern.matcher("021-123456").matches(); // true
			pattern.matcher("022#1234567").matches(); // false
			// 获得Matcher对象:
			Matcher matcher = pattern.matcher("010-12345678");
			if (matcher.matches()) {
				String whole = matcher.group(0); // "010-12345678", 0表示匹配的整个字符串
				String area = matcher.group(1); // "010", 1表示匹配的第1个子串
				String tel = matcher.group(2); // "12345678", 2表示匹配的第2个子串
				System.out.println(area);
				System.out.println(tel);
			}
				
			使用Matcher时，首先调用matches()判断是否匹配成功，匹配成功后，才能调用group()提取字符串。
			利用提取字符串功能，获取区号和号码两部分。
			
		
		结：
			正则表达式用(...)分组可以通过Matcher对象快速提取子串：

				group(0)表示匹配的整个字符串；
				group(1)表示第1个子串，group(2)表示第2个子串，以此类推。
			
			
			
			
	非贪婪匹配：
		给定字符串表示的数字，判断该数字末尾0的个数：
			"123000"：3个0
			"10100"：2个0
			"1001"：0个0
		正则表达式：(\d+)(0*)；
			Pattern pattern = Pattern.compile("(\\d+)(0*)");
			Matcher matcher = pattern.matcher("1230000");
			if (matcher.matches()) {
				System.out.println("group1=" + matcher.group(1)); // "1230000"
				System.out.println("group2=" + matcher.group(2)); // ""
			}
			第二字符串是空的。
			
			实际上，我们期望分组匹配结果是：

				input	\d+		0*
				123000	"123"	"000"
				10100	"101"	"00"
				1001	"1001"	""
			但实际的分组匹配结果是这样的：

				input	\d+			0*
				123000	"123000"	""
				10100	"10100"		""
				1001	"1001"		""
			
		因为\d+确实可以匹配后面任意个0。
		因为正则表达式默认使用贪婪匹配：任何规则，总是尽可能多向后匹配，因此\d+总是会将后面的0包含进来。
		为了\d+减少,0*多匹配，必须\d+使用非贪婪匹配，在规则\d+后加上？表示非贪婪匹配：
			Pattern pattern = Pattern.compile("(\\d+?)(0*)");
			Matcher matcher = pattern.matcher("1230000");
			if (matcher.matches()) {
				System.out.println("group1=" + matcher.group(1)); // "123"
				System.out.println("group2=" + matcher.group(2)); // "0000"
			}
			
		(\d??)(9*)，\d?表示匹配0或1个数字，后面第二个？表示非贪婪匹配，给定字符串"9999"，匹配两个子串分别是“”，“9999”
		因此\d?来说，匹配1个9，也可以匹配0个9，但是因为？表示非贪婪匹配，会尽量减少匹配，说以匹配0个9。
		
		
		结：
			正则表达式匹配默认使用贪婪匹配，可以使用?表示对某一规则进行非贪婪匹配。

			注意区分?的含义：\d??。
			
			
			
	搜索和替换：
		分割字符串：
			使用正则表达式分割字符串可实现更加灵活的功能，String.split()方法传入真是正则表达式：
			"a b c".split("\\s"); // { "a", "b", "c" }
			"a b  c".split("\\s"); // { "a", "b", "", "c" }
			"a, b ;; c".split("[\\,\\;\\s]+"); // { "a", "b", "c" }
			因为输入往往不规范，所以将标签提出来，使用合适的正则表达式，可消除多个空格、混合，和；这些不规范输入，提取出规范的字符串。
			
		搜索字符串：
			String s = "the quick brown fox jumps over the lazy dog.";
			Pattern p = Pattern.compile("\\wo\\w");
			Matcher m = p.matcher(s);
			while (m.find()) {
				String sub = s.substring(m.start(), m.end());
				System.out.println(sub);
			}
			返回结果：	row
						fox
						dog
			获取到Matcher对象后，不用调用matches()方法(因为匹配整个串定当返回false)，而是反复调用find()方法，整个串中搜索能匹配上\\wo\\w规则的子串，
			并打印出来。比String.indexOf()灵活，因为搜索规则是3个字符：中间必须是o，前后两个必须是字符[A-Za-z0-9]。
			
		替换字符串：
			正则表达式替换字符串直接调用String.replaceAll，第一个参数是正则表达式，第二个参数是待替换的字符串：
				String s = "The     quick\t\t brown   fox  jumps   over the  lazy dog.";
				String r = s.replaceAll("\\s+", " ");
				System.out.println(r); // "The quick brown fox jumps over the lazy dog."
				将不规则的连续空格分割句子按规则进行替换编程规范的句子。
		
		反向引用：
			将搜索的指定字符串按规则进行替换比如前后各加一个<b>xxxx</b>，这个时候，使用replaceAll()的时候，
			我们传入的第二个参数可以使用$1、$2来反向引用匹配到的子串。例如：
				String s = "the quick brown fox jumps over the lazy dog.";
				String r = s.replaceAll("\\s([a-z]{4})\\s", " <b>$1</b> ");
				System.out.println(r);
				输出结果：the quick brown fox jumps <b>over</b> the <b>lazy</b> dog.
				效果是将任何4字符单词前后用<b>xxxx</b>括起来。实现替换的关键就在于" <b>$1</b> "，它用匹配的分组子串([a-z]{4})替换了$1。
			
			
			
		结：
			使用正则表达式可以：
				分割字符串：String.split()
				搜索子串：	Matcher.find()
				替换字符串：String.replaceAll()	
			
			
			
			
加密与安全：
	加密和安全的定义是a给b发了邮件，传输过程中，黑客可能会窃取到邮件内容，需要防监听。黑客还会篡改邮件内容，b要有能力识别邮件是否被篡改。
	黑客可能假冒a给b发邮件，b要有能力识别出伪造邮件。
	
	应对潜在的安全威胁，需三防：
		防窃听
		防篡改
		防伪造
	
	加密技术为了实现上述目标，计算机密码学理论是建立在严格数学理论基础上，密码学发展成一门科学。设计一个安全的加密算法非常困难，验证加密算法是否安全更困难，
	目前被认为安全的加密算法仅仅是还未被攻破，so，涉及安全的计算机程序，需要：
		不要自己设计山寨的加密算法
		不要自己实现已有的加密算法
		不要自己修改已有的加密算法
	
	
	编码算法：
		ASCII就是一种编码，字母A的编码是十六进制的0x41，B是0x42，以此类推：	
			字母	ASCII编码
			A		0x41
			B		0x42
			C		0x43
			D		0x44
		因为ASCII编码最多只能有127个字符，想对更多的文字进行编码，需用到Unicode。中文的中使用Unicode编码是0x4e2d，UTF-8需要3个字节编码：
			
			汉字	Unicode编码		UTF-8编码
			中		0x4e2d			0xe4b8ad
			文		0x6587			0xe69687
			编		0x7f16			0xe7bc96
			码		0x7801			0xe7a081
		因此最简单的编码直接给每个字符指定若干字节表示的整数，复杂的就需要根据已有的编码进行推算。
		UTF-8是一种不定长编码，但可以给定字符的Unicode编码推算出来。
		
		URL编码：
			是浏览器法索那个数据给服务器时使用的编码，通常附加在URL参数部分：
			https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87		wd后。
			
			需要URL编码，是因为兼容性考虑，很多服务器只识别ASCII字符，如果URL包含中文，日字非ASCII字符怎么办，URL规则：
				如果字符是A~Z，a~z，0~9以及-、_、.、*，则保持不变；
				如果是其他字符，先转换为UTF-8编码，然后对每个字节以%XX表示。
			
			字符中的UTF-8编码是0xe4b8ad，因此，它的URL编码是%E4%B8%AD。URL编码总是大写。
			Java标准库提供了一个URLEncoder类来对任意字符串进行URL编码：
				String encoded = URLEncoder.encode("中文!", StandardCharsets.UTF_8);
				System.out.println(encoded);
				输出结果：%E4%B8%AD%E6%96%87%21
			
			上述代码的运行结果是%E4%B8%AD%E6%96%87%21，中的URL编码是%E4%B8%AD，文的URL编码是%E6%96%87，!虽然是ASCII字符，也要对其编码为%21。
			和标准的URL编码稍有不同，URLEncoder把空格字符编码成+，而现在的URL编码标准要求空格被编码为%20，不过，服务器都可以处理这两种情况。
			如果服务器收到URL编码的字符串，就可以对其进行解码，还原成原始字符串。Java标准库的URLDecoder就可以解码：
				String decoded = URLDecoder.decode("%E4%B8%AD%E6%96%87%21", StandardCharsets.UTF_8);
				System.out.println(decoded);		
				输出结果：中文!
				
				URL编码是编码算法，非加密算法。URL目的将任意文本数据编码为%前缀表示的文本，编码后文本仅包含A~Z，a~z，0~9，-，_，.，*和%，
				便于浏览器和服务器处理。
			
			
		Base64编码：
			URL对字符进行编码，成%xx形式，儿Base64对二进制数据进行编码，表示成文本格式。
			Base64将任意长度二级制数据变为纯文字，只包含A~Z、a~z、0~9、+、/、=这些字符。原理是将3字节的二进制数据按6bit一组，
			用4个int整数表示而后查表，将int整数用索引对应到字符，变成后的字符串。
			如：3个byte数据分别是e4、b8、ad，按6bit分组得到39、0b、22和2b。
				┌───────────────┬───────────────┬───────────────┐
				│      e4       │      b8       │      ad       │
				└───────────────┴───────────────┴───────────────┘
				┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
				│1│1│1│0│0│1│0│0│1│0│1│1│1│0│0│0│1│0│1│0│1│1│0│1│
				└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
				┌───────────┬───────────┬───────────┬───────────┐
				│    39     │    0b     │    22     │    2d     │
				└───────────┴───────────┴───────────┴───────────┘		
			用6为整数和范围总和是0~63,能用64个字符表示，字符A~Z对应索引0~25，字符a~z对应索引26~51，
			字符0~9对应索引52~61，最后两个索引62、63分别用字符+和/表示。
			
			
			Java中二进制数据就是byte数组，java标准库提供Base64对byte[]数组进行编解码：
				byte[] input = new byte[] { (byte) 0xe4, (byte) 0xb8, (byte) 0xad };
				String b64encoded = Base64.getEncoder().encodeToString(input);
				System.out.println(b64encoded);
				运行结果：5Lit
			
			编码得到5Lit后，对Base64解码，仍然用Base64这个类：
				byte[] output = Base64.getDecoder().decode("5Lit");
				System.out.println(Arrays.toString(output)); // [-28, -72, -83]
				运行结果：[-28, -72, -83]
				
				如果输入的byte[]数组长度不是3的整数倍肿么办？这种情况下，需要对输入的末尾补一个或两个0x00，
				编码后，在结尾加一个=表示补充了1个0x00，加两个=表示补充了2个0x00，解码的时候，
				去掉末尾补充的一个或两个0x00即可。
			
			
			
			
			实际上，因为编码后的长度加上=总是4的倍数，所以即使不加=也可以计算出原始输入的byte[]。
			Base64编码的时候可以用withoutPadding()去掉=，解码出来的结果是一样的：
				byte[] input = new byte[] { (byte) 0xe4, (byte) 0xb8, (byte) 0xad, 0x21 };
				String b64encoded = Base64.getEncoder().encodeToString(input);
				String b64encoded2 = Base64.getEncoder().withoutPadding().encodeToString(input);
				System.out.println(b64encoded);
				System.out.println(b64encoded2);
				byte[] output = Base64.getDecoder().decode(b64encoded2);
				System.out.println(Arrays.toString(output));
				输出结果：	5LitIQ==
							5LitIQ
							[-28, -72, -83, 33]
										
			
			因为标准的Base64编码会出现+、/和=，所以不适合把Base64编码后的字符串放到URL中。
			一种针对URL的Base64编码可以在URL中使用的Base64编码，它仅仅是把+变成-，/变成_：
				byte[] input = new byte[] { 0x01, 0x02, 0x7f, 0x00 };
				String b64encoded = Base64.getUrlEncoder().encodeToString(input);
				System.out.println(b64encoded);
				byte[] output = Base64.getUrlDecoder().decode(b64encoded);
				System.out.println(Arrays.toString(output));	
				输出结果：	AQJ_AA==
							[1, 2, 127, 0]
			
			
		Base64编码的目的是把二进制数据变成文本格式，这样在很多文本中就可以处理二进制数据。
		例如，电子邮件协议就是文本协议，如果要在电子邮件中添加一个二进制文件，就可以用Base64编码，然后以文本的形式传送。
		Base64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1/3。
		和URL编码一样，Base64编码是一种编码算法，不是加密算法。
		如果把Base64的64个字符编码表换成32个、48个或者58个，就可以使用Base32编码，Base48编码和Base58编码。字符越少，编码的效率就会越低。	
			
		结：
			URL编码和Base64编码都是编码算法，它们不是加密算法；

			URL编码的目的是把任意文本数据编码为%前缀表示的文本，便于浏览器和服务器处理；

			Base64编码的目的是把任意二进制数据编码为文本，但编码后数据量会增加1/3。	
			
			
			
	哈希算法：
		哈希算法(Hash)又称摘要算法(Digest)，作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。
		哈希算法最重要的特点是：
			相同输入一定得到相同的输出。
			不同输入大概率得到不同的输出。
		哈希算法目的就是为了验证原始数据是否被篡改。
		java字符串的hashCode()就是个哈希算法，它的输入是任意字符串，输出是固定的4字节int整数。
			"hello".hashCode(); // 0x5e918d2
			"hello, java".hashCode(); // 0x7a9d88e8
			"hello, bob".hashCode(); // 0xa0dbae2f
		两个相同的字符串永远会计算出相同的hashCode()，否则基于hashCode定位的HashMap就无法正常工作。这也是为什么当定义一个class时，
		覆写equals()方法时必须正确覆写hashCode()方法。
			
		哈希碰撞：
			指，两个不同的输入得到相同的输出：
				"AaAaAa".hashCode(); // 0x7460e8c0
				"BBAaBB".hashCode(); // 0x7460e8c0
			
			碰撞是不能避免的是一定会出现的，因为输出的字节长度是固定的，String的hashCode()输出是4字节整数，最多只有4294967296种输出，
			但输入的数据长度是不固定的，有无数种输入，所以哈希算法是将一个无限输入集合映射到一个有限输出集合，一定产生碰撞。
			碰撞不可怕，碰撞的概率是最重要的，因为概率高低影响到哈希算法的安全性，一个安全的哈希算法必须满足：
				碰撞概率低
				不能猜测输出
			不能猜测输出是指，输入任意一个bit变化会造成输出完全不同，这样很难从输出反推输入(只能依靠暴力穷举)。
			
			假设哈希算法以下规律：
				hashA("java001") = "123456"
				hashA("java002") = "123457"
				hashA("java003") = "123458"
				
				就很容易从输出123459反推输入，这种哈希算法就不安全。安全的哈希算法从输出看不出任何规律的。
			
			常用的哈希算法：
				算法		输出长度（位）		输出长度（字节）
				MD5			128 bits			16 bytes
				SHA-1		160 bits			20 bytes
				RipeMD-160	160 bits			20 bytes
				SHA-256		256 bits			32 bytes
				SHA-512		512 bits			64 bytes
			
			根据碰撞概率，哈希算法输出长度越长，越难产生碰撞，也就越安全。
			
			Java标准库提供常用的哈希算法，并有一套统一的接口，MD5算法为例，输入计算哈希例子：
				// 创建一个MessageDigest实例:
				MessageDigest md = MessageDigest.getInstance("MD5");
				// 反复调用update输入数据:
				md.update("Hello".getBytes("UTF-8"));
				md.update("World".getBytes("UTF-8"));
				byte[] result = md.digest(); // 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6
				System.out.println(new BigInteger(1, result).toString(16));
				
				输出结果：68e109f0f40ca72a15e05cc22786f8e6
			
				使用MessageDigest时，先根据哈希算法获取一个MessageDigest实例。然后反复调用update(byte[])输入数据。
				输入结束后，调用digest()获得byte[]表示的摘要，最后转换为16进制的字符串。
			
		
		哈希算法的用途：
			因为相同的输入永远会得到相同的输出，so，输入被修改买得到输出就会不同。
			判断下载到本地的软件是原始的为篡改的文件，只要自己计算本地文件的哈希值，于官网的公开哈希值对比即可。
			
			哈希算法另一个重要用途就是存储用户口令，如果直接将用户原始口令放入数据库种，会产生极大风险：
				数据库管理员能够看到用户明文口令。
				数据库数据一旦泄露，黑客即可获取用户明文口令。
			
			不存储用户原始口令，对用户进行认证的方法是：
				存储用口令的哈希，如MD5.
				在用户输入原始口令后，系统计算用户的原始口令的MD5并与数据库存储的MD5对比，如果一致则正确否则错。
				数据库存储用户和口令的表内容应如下：
					username	password
					bob			f30aa7a662c728b7407c54ae6bfd27d1
					alice		25d55ad283aa400af464c76d713c07ad
					tim			bed128365216c019988915ed3add75fb
			
				这样数据库管理员看不见用用户原始口令，即使泄露，何可也无法拿到原始口令，想拿到原始口令只能暴力穷举，
				一个一个口令地试，直到值相等。
				
			使用哈希口令时要防止彩虹表攻击。
			彩虹表是预先计算好的常用口令和它们的MD5对照表：
				常用口令	MD5
				hello123	f30aa7a662c728b7407c54ae6bfd27d1
				12345678	25d55ad283aa400af464c76d713c07ad
				passw0rd	bed128365216c019988915ed3add75fb
				19700101	570da6d5277a646f6552b8832012f5dc
				…	…
				20201231	6879c0ae9117b50074ce0a0d4c843060
			
				如果使用常用口令，黑客从MD5一下就能反查到原始口令。
					bob的MD5：f30aa7a662c728b7407c54ae6bfd27d1，原始口令：hello123；

					alice的MD5：25d55ad283aa400af464c76d713c07ad，原始口令：12345678；

					tim的MD5：bed128365216c019988915ed3add75fb，原始口令：passw0rd。

					这就是为什么不要使用常用密码，以及不要使用生日作为密码的原因。
			
			但即使用户使用常用口令，也能对每个口令额外添加随机数，这方法称为加盐(salt)：
				digest = md5(salt+inputPassword)
			
			
			经过加盐处理的数据库表，内容如下：
				username	salt	password
				bob			H1r0a	a5022319ff4c56955e22a74abcc2c210
				alice		7$p2w	e5de688c99e961ed6e560b972dab8b6a
				tim			z5Sk9	1eee304b92dc0d105904e7ab58fd2f64
				加盐目的在于使黑客的彩虹表失效，用户使用常用口令，也无法从MD5反推原始口令。
				
			
			
		SHA-1(安全散列算法)：
			SHA-1原始一种哈希算法，输出是160bits，即20字节，其是美国国家安全局开发的，SHA算法实际上是一个系列，
			包括SHA-0(废弃)、SHA-1、SHA-256、SHA-512等等。
			
			在java中使用SHA-1和MD5完全一样，只要将算法名改为"SHA-1"：
				// 创建一个MessageDigest实例:
				MessageDigest md = MessageDigest.getInstance("SHA-1");
				// 反复调用update输入数据:
				md.update("Hello".getBytes("UTF-8"));
				md.update("World".getBytes("UTF-8"));
				byte[] result = md.digest(); // 20 bytes: db8ac1c259eb89d4a131b253bacfca5f319d54f2
				System.out.println(new BigInteger(1, result).toString(16));
				
				输出结果：db8ac1c259eb89d4a131b253bacfca5f319d54f2
						
			类似的，计算SHA-256，需要传入名称"SHA-256"，计算什么SHA输入什么SHA名称。
		MD5因为输出长度较短，短时间破解是可能的，目前不推荐使用。
		
			
		结：
			哈希算法可用于验证数据完整性，具有防篡改检测的功能；

			常用的哈希算法有MD5、SHA-1等；

			用哈希存储口令时要考虑彩虹表攻击。	
			
			
			
	BouncyCastle(轻量级密码术包)：		
		bouncy castle（轻量级密码术包）是一种用于 Java 平台的开放源码的轻量级密码术包；
			它支持大量的密码术算法，并提供JCE 1.2.1的实现。	
		这是一个提供很多哈希算法和加密算法的第三方库，提供了java没有的算法，如：RipeMD160哈希算法。	
		必须先将BouncyCastle提供的jar包放到classpath中，这个jar包就是bcprov-jdk15on-xxx.jar。
			jar包官网下载地址：https://www.bouncycastle.org/latest_releases.html
			
		Java标准库的java.security包提供了一种标准机制，允许第三方提供商无缝接入。
		要使用BouncyCastle提供的RipeMD160算法，需要先把BouncyCastle注册一下：
			
			// 注册BouncyCastle:
			Security.addProvider(new BouncyCastleProvider());
			// 按名称正常调用:
			MessageDigest md = MessageDigest.getInstance("RipeMD160");
			md.update("HelloWorld".getBytes("UTF-8"));
			byte[] result = md.digest();
			System.out.println(new BigInteger(1, result).toString(16));
			
			其中注册BouncyCastle是通过下面的语句实现的：
				Security.addProvider(new BouncyCastleProvider());
				注册只需要启动时进行一次，后续就可以使用BouncyCastle提供的所有哈希算法和加密算法。
		
		结：
			BouncyCastle是一个开源的第三方算法提供商；

			BouncyCastle提供了很多Java标准库没有提供的哈希算法和加密算法；

			使用第三方算法前需要通过Security.addProvider()注册。
			
					
			
			
	Hmac算法(哈希信息验证码)：
		之前说到，存储用户的哈希口令时，要加盐存储，目的在于抵御彩虹表攻击。
		哈希算法：
			digest = hash(input)
		因为相同的输入会产生相同的输出，加盐的目的就是使输入有变化：
			digest = hash(salt + input)
		salt可看作是一个额外的"认证码"，全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。
		Hmac算法总是和某种哈希算法配合使用，如MD5对应是HmacMD5，相当于加盐的MD5：
			HmacMD5 ≈ md5(secure_random_key, input)
		
		因此，HmacMD5可以看作带有一个安全的key的MD5。使用HmacMD5而不是用MD5加salt，有如下好处：
			HmacMD5使用的key长度是64字节，更安全；
			Hmac是标准算法，同样适用于SHA-1等其他哈希算法；
			Hmac输出和原有的哈希算法长度一致。	
		
		可见，Hmac本质上就是把key混入摘要的算法。验证此哈希时，除了原始的输入数据，还要提供key。	
			KeyGenerator keyGen = KeyGenerator.getInstance("HmacMD5");
			SecretKey key = keyGen.generateKey();
			// 打印随机生成的key:
			byte[] skey = key.getEncoded();
			System.out.println(new BigInteger(1, skey).toString(16));
			Mac mac = Mac.getInstance("HmacMD5");
			mac.init(key);
			mac.update("HelloWorld".getBytes("UTF-8"));
			byte[] result = mac.doFinal();
			System.out.println(new BigInteger(1, result).toString(16));
			
		和MD5相比，使用HmacMD5的步骤是：
			通过名称HmacMD5获取KeyGenerator实例；
			通过KeyGenerator创建一个SecretKey实例；
			通过名称HmacMD5获取Mac实例；
			用SecretKey初始化Mac实例；
			对Mac实例反复调用update(byte[])输入数据；
			调用Mac实例的doFinal()获取最终的哈希值。	
						
			
		我们可以用Hmac算法取代原有的自定义的加盐算法，因此，存储用户名和口令的数据库结构如下：

			username			secret_key (64 bytes)			password
			bob					a8c06e05f92e...5e16				7e0387872a57c85ef6dddbaa12f376de
			alice				e6a343693985...f4be				c1f929ac2552642b302e739bc0cdbaac
			tim					f27a973dfdc0...6003				af57651c3a8a73303515804d4af43790	
						
			
		有了H，ac计算的哈希和SecretKey，验证时，SecretKey不能从KeyGenerator生成，而是从一个byte[]数组恢复：
			byte[] hkey = new byte[] { 106, 70, -110, 125, 39, -20, 52, 56, 85, 9, -19, -72, 52, -53, 52, -45, -6, 119, -63,
                30, 20, -83, -28, 77, 98, 109, -32, -76, 121, -106, 0, -74, -107, -114, -45, 104, -104, -8, 2, 121, 6,
                97, -18, -13, -63, -30, -125, -103, -80, -46, 113, -14, 68, 32, -46, 101, -116, -104, -81, -108, 122,
                89, -106, -109 };

			SecretKey key = new SecretKeySpec(hkey, "HmacMD5");
			Mac mac = Mac.getInstance("HmacMD5");
			mac.init(key);
			mac.update("HelloWorld".getBytes("UTF-8"));
			byte[] result = mac.doFinal();
			System.out.println(Arrays.toString(result));
			输出结果：// [126, 59, 37, 63, 73, 90, 111, -96, -77, 15, 82, -74, 122, -55, -67, 54]
			
		恢复ScretKey的语句就是new SecretKeySpec(hkey, "HmacMD5")
		
			
		结：
			Hmac算法是一种标准的基于密钥的哈希算法，可以配合MD5、SHA-1等哈希算法，计算的摘要长度和原摘要算法长度相同。	
			
			
			
	对称加密算法：
		是传统的使用一个密码进行加密和解密，如常用的WinZIP和WinRAR对压缩包的加密和解密，就是使用对称加密算法。
		程序角度讲，加密就是这样的函数，接收密码和明文，然后输出密文。
			secret = encrypt(key, message);
		而解密相反，它接收密码和密文，然后输出明文。	
			plain = decrypt(key，secret);
		
		在软件开发中，常用的对称加密算法有：

			算法		密钥长度		工作模式				填充模式
			DES			56/64			ECB/CBC/PCBC/CTR/...	NoPadding/PKCS5Padding/...
			AES			128/192/256		ECB/CBC/PCBC/CTR/...	NoPadding/PKCS5Padding/PKCS7Padding/...
			IDEA		128				ECB						PKCS5Padding/PKCS7Padding/...		
			
			密钥长度直接决定加密强度，工作模式和填充模式可看成是对称加密算法的参数和格式选择，java标准提供的算法实现并不
			包括所有的工作模式和所有填充模式，通常只要挑选常用的使用即可。
			DES算法由于密钥过短，短时间内可被暴力破解，现在已经不安全。
		
		使用AES加密：
			AES算法是目前应用最广泛的加密算法。
			先使用ECB模式加密并进行解密：
				// 原文:
				String message = "Hello, world!";
				System.out.println("Message: " + message);
				// 128位密钥 = 16 bytes Key:
				byte[] key = "1234567890abcdef".getBytes("UTF-8");
				// 加密:
				byte[] data = message.getBytes("UTF-8");
				byte[] encrypted = encrypt(key, data);
				System.out.println("Encrypted: " + Base64.getEncoder().encodeToString(encrypted));
				// 解密:
				byte[] decrypted = decrypt(key, encrypted);
				System.out.println("Decrypted: " + new String(decrypted, "UTF-8"));
				
				// 加密:
				public static byte[] encrypt(byte[] key, byte[] input) throws GeneralSecurityException {
					Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
					SecretKey keySpec = new SecretKeySpec(key, "AES");
					cipher.init(Cipher.ENCRYPT_MODE, keySpec);
					return cipher.doFinal(input);
				}

				// 解密:
				public static byte[] decrypt(byte[] key, byte[] input) throws GeneralSecurityException {
					Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
					SecretKey keySpec = new SecretKeySpec(key, "AES");
					cipher.init(Cipher.DECRYPT_MODE, keySpec);
					return cipher.doFinal(input);
				}	
			
			
			Java标准库提供的对称加密接口非常简单，使用时按以下步骤编写代码：
				根据算法名称/工作模式/填充模式获取Cipher实例；
				根据算法名称初始化一个SecretKey实例，密钥必须是指定长度；
				使用SerectKey初始化Cipher实例，并设置加密或解密模式；
				传入明文或密文，获得密文或明文。
			
			ECD模式是最简单的AES加密模式，只需要一个固定长度的密钥，固定明文生成固定的密文，这种一对一的加密方式会
			导致安全性降低，更好的方式通过CBC模式，需要一个随机数作为IV参数，对于同一份明文，每次生成的密文都不同。
			例子过长，在此链接下查看：https://www.liaoxuefeng.com/wiki/1252599548343744/1304227762667553
				
		结：
			对称加密算法使用同一个密钥进行加密和解密，常用算法有DES、AES和IDEA等；

			密钥长度由算法设计决定，AES的密钥长度是128/192/256位；

			使用对称加密算法需要指定算法名称、工作模式和填充模式。
			
			
			
	口令加密算法：
		AES加密，密钥长度是固定的128/192/256位，因为对称加密算法决定了口令是固定长度，然后对明文进行分块加密。
		因为安全需求，口令长度往往是128以上，至少16个字符。
		用户输入口令并不能直接作为AES的密钥进行加密(除非长度正好是128/192/256位)，并且用户输入口令一般都有规律，
		安全性远远不如安全随机数产生的随机口令，因此用户输入的口令还需使用PBE算法，采取随机数杂凑计算出真的密钥，进行加密。
		
		PBE就是Password Based Encryption的缩写，它的作用如下：
			key = generate(userPassword, secureRandomPassword);		
		
		PBE的作用将用户输入的口令和一个安全随机的口令用杂凑后计算出真正的密钥。以AES密钥为例，让用户输入一个口令，然后生成一个随机数，
		通过PBE算法计算出真正的AES口令，再进行加密，例子：https://www.liaoxuefeng.com/wiki/1252599548343744/1304227859136546
		
		结：
			PBE算法通过用户口令和安全的随机salt计算出Key，然后再进行加密；

			Key通过口令和安全的随机salt计算得出，大大提高了安全性；

			PBE算法内部使用的仍然是标准对称加密算法（例如AES）。
			
			
	密钥交换算法：
		对称加密算法解决了数据加密问题。以AES加密为例，现实世界中，小明向路人甲发送一个加密文件，可先生成一个AES密钥，
		对文件进行加密，后把加密文件发送给各位。因为对方解密，就必须使用小明生成的密钥。
		密钥交换算法DH算法就：Diffie-Hellman算法，就是位解决在不安全的信道上安全的传输密钥。
			例子：https://www.liaoxuefeng.com/wiki/1252599548343744/1304227905273889
		结：
			DH算法是一种密钥交换协议，通信双方通过不安全的信道协商密钥，然后进行对称加密传输。

			DH算法没有解决中间人攻击。	
			
			
	
	
	非对称加密算法：
		从DH算法看出，公钥-私钥组成的密钥是hi非常有用的加密方式，因为公钥是可以公开的，而且私钥是完全保密的，
		由此奠定了非对称加密的基础。
		非对称加密就是加密和解密使用的不是相同的密钥，只有同一个公钥-私钥对才能正常加解密。
		
		又是一个例子：
			小明加密一个文件发个小红，应该先向小红索取她的公钥，然后用小红公钥加密，将加密文件发给小红，
			此文件智能小红的私钥解开，因为小红的私钥在自己手里，其他人无法解开此文件。
			
		非对称加密的典型算法就是RSA算法。
		非对称加密相比对称加密的优点在于，对称加密需要协商密钥，而非对称加密可以安全地公开各自的公钥，
		在N个人之间通信的时候：使用非对称加密只要N个密钥对，每个人之管理自己的密钥对。而使用堆成加密
		需要N*(N-1)/2个密钥，因此每个人需要管理N-1个密钥，密钥管理难度过大，而且容易泄露。
		
		但是非堆成加密的缺点是运算速度非常慢，比对称加密慢很多。
		实际应用的时候，非对称总是和对称加密一起使用。
		
		例子，小明需要给小红传输加密文件，他们先交换了各自公钥，然后：
			1.小明生成一个堆积的AES口令，然后用小红的公钥通过RSA加密此口令，并发给小红。
			2.小红用自己的RSA私钥解密得到AES口令。
			3.双方使用这个共享的AES口令用AES加密通信。
				
			可见非对称加密实际上应用在第一步，即加密"AES口令"。也是在浏览器常用的HTTPS协议的做法，即浏览器
			和服务器先通过RSA交换AES口令，接下来双方通信实际上采用的是速度较快的AES对称加密，而不是缓慢的
			RSA非对称加密。
		
		代码在这里：https://www.liaoxuefeng.com/wiki/1252599548343744/1304227873816610
		
		RSA的公钥和私钥都可以通过getEncoded()方法获得以byte[]表示的二进制数据，并根据需要保存到文件中。
		要从byte[]数组恢复公钥或私钥，可写：
			byte[] pkData = ...
			byte[] skData = ...
			KeyFactory kf = KeyFactory.getInstance("RSA");
			// 恢复公钥:
			X509EncodedKeySpec pkSpec = new X509EncodedKeySpec(pkData);
			PublicKey pk = kf.generatePublic(pkSpec);
			// 恢复私钥:
			PKCS8EncodedKeySpec skSpec = new PKCS8EncodedKeySpec(skData);
			PrivateKey sk = kf.generatePrivate(skSpec);
			
		以RSA算法为例，它的密钥有256/512/1024/2048/4096等不同的长度。长度越长，密码强度越大，当然计算速度也越慢。			
		如果修改待加密的byte[]数据的大小，可以发现，使用512bit的RSA加密时，明文长度不能超过53字节，使用1024bit的RSA加密时，
		明文长度不能超过117字节，这也是为什么使用RSA的时候，总是配合AES一起使用，即用AES加密任意长度的明文，用RSA加密AES口令。
		
		结：
			非对称加密就是加密和解密使用的不是相同的密钥，只有同一个公钥-私钥对才能正常加解密；

			只使用非对称加密算法不能防止中间人攻击。
			
			
	
	
	签名算法：
		使用非对称加密算法的时候，对于一个公钥-私钥对，通常用公钥加密，私钥解密。
		也可私钥加密，公钥解密，这个加密的意义是小明用自己私钥加密一条信息，然后公开加密消息，任何人都能使用小明的公钥解密，
		而使得任何人都可以确定这条消息是小明发出，其他人不能伪造消息，小明也不能抵赖这条消息不是自己写的(可以共这个加密发送公告)。
		
		因此，私钥加密的道德密文实际上就是数字签名，验证此签名是否准确，只能用私钥持有者的公钥进行解密验证。使用数字签名的目的是为了
		确定某个消息确实是某个发送的，任何人都不能伪造消息，发送方也不能抵赖。
		
		实际应用时，签名实际上并不是针对原始消息，而是对原始消息的哈希进行签名，即：
			signature = encrypt(privateKey, sha256(message))
		对签名进行验证实际上就是用公钥解密：
			hash = decrypt(publicKey, signature)
			然后将解密后的哈希与原始消息的哈希进行对比。
		用户总是使用自己的私钥进行签名，所以是要就相当于用户身份。而公钥用来给外部验证用户身份。
		
		常用的数字签名有：
			MD5withRSA
			SHA1withRSA
			SHA256withRSA
		实际上时指定某种哈希算法进行RSA签名的方式。
		例子：https://www.liaoxuefeng.com/wiki/1252599548343744/1304227943022626
		
		DSA签名：
			除了RSA可以签名以外，还可以使用DSA算法进行签名。DSA是Digital Signature Algorithm的缩写，它使用ElGamal数字签名算法。
			
			DSA只能配合SHA使用，常用的算法有：
				SHA1withDSA
				SHA256withDSA
				SHA512withDSA
			和eRSA数字签名相比，DSA优点是更快。
		
		ECDSA签名：
			椭圆曲线签名算法ECDSA：
				椭圆曲线签名算法ECDSA：Elliptic Curve Digital Signature Algorithm也是一种常用的签名算法，它的特点是可以从私钥推出公钥。
				比特币的签名算法就采用了ECDSA算法，使用标准椭圆曲线secp256k1。BouncyCastle提供了ECDSA的完整实现。
			
		结：
			数字签名就是用发送方的私钥对原始数据进行签名，只有用发送方公钥才能通过签名验证。

			数字签名用于：

			防止伪造；
			防止抵赖；
			检测篡改。
			常用的数字签名算法包括：MD5withRSA／SHA1withRSA／SHA256withRSA／SHA1withDSA／SHA256withDSA／SHA512withDSA／ECDSA等。	
			
			
			
	数字证书：
		摘要算法用来确保数据没有被篡改，非对称加密算法可对数据进行加解密，签名算法可确保数据完整性和抗否认性，将这些算法集合一起，
		并搞一套完善的标准，就是数字证书。
		
		数字证书是集合多种密码学算法，用于实现数据加解密，身份认证，签名等多种功能的一种安全标注。
		
		数字证书可防止中间人攻击，因为它采用链式签名认证，即通过根证书(Root CA)去签名下一级证书，层层签名，直到最终的用户证书。
		而Root CA整数内置于操作系统中，所以任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的。
		
		上网经常使用的HTTPS协议就是数字证书的应用，浏览器自动验证证书的有效性。
		
		使用数字签名首先创建证书。正常情况下，一个合法的数字证书需要经过CA签名，这需要认证域名并支付一定的费用。开发的时候，
		可使用这种证书，这种证书可正常开发调试。但不能对外作为服务使用，因为其他客户端并不认可未经CA签名的证书。
		
		Java中，数字证书存储在java专用的keyh store文件中，JDK提供一系列命令来创建和管理key store。使用以下命令创建key store，
		并设定口令123456：
			keytool -storepass 123456 -genkeypair -keyalg RSA -keysize 1024 -sigalg SHA1withRSA -validity 3650 -alias 
			mycert -keystore my.keystore -dname "CN=www.sample.com, OU=sample, O=sample, L=BJ, ST=BJ, C=CN"
			
			几个主要的参数是：
				keyalg：指定RSA加密算法；
				sigalg：指定SHA1withRSA签名算法；
				validity：指定证书有效期3650天；
				alias：指定证书在程序中引用的名称；
				dname：最重要的CN=www.sample.com指定了Common Name，如果证书用在HTTPS中，这个名称必须与域名完全一致。	
			执行了上述命令的话，JDK会在当前目录创建一个my.keystore文件，并存储创建成功的一个私钥和证书，别名是mycert。
		
		有key store存储正式，通过数字证书进行加解密和签名的例子：https://www.liaoxuefeng.com/wiki/1252599548343744/1304227968188450a
			
					
		在上述代码中，我们从key store直接读取了私钥-公钥对，私钥以PrivateKey实例表示，公钥以X509Certificate表示，实际上数字证书只包含公钥，
		因此，读取证书并不需要口令，只有读取私钥才需要。如果部署到Web服务器上，例如Nginx，需要把私钥导出为Private Key格式，把证书导出为X509Certificate格式。	
			
		以HTTPS协议为例，浏览器和服务器建立安全连接的步骤如下：
			浏览器向服务器发起请求，服务器向浏览器发送自己的数字证书；
			浏览器用操作系统内置的Root CA来验证服务器的证书是否有效，如果有效，就使用该证书加密一个随机的AES口令并发送给服务器；
			服务器用自己的私钥解密获得AES口令，并在后续通讯中使用AES加密。	
			
		上述流程只是一种最常见的单向验证。如果服务器还要验证客户端，那么客户端也需要把自己的证书发送给服务器验证，这种场景常见于网银等。

		注意：数字证书存储的是公钥，以及相关的证书链和算法信息。私钥必须严格保密，如果数字证书对应的私钥泄漏，就会造成严重的安全威胁。如果CA证书的私钥泄漏，
		那么该CA证书签发的所有证书将不可信。数字证书服务商DigiNotar就发生过私钥泄漏导致公司破产的事故。	
			
		结：
			数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。

			数字证书采用链式签名管理，顶级的Root CA证书已内置在操作系统中。

			数字证书存储的是公钥，可以安全公开，而私钥必须严格保密。	
			
			
			
						
			
			
多线程：
	多线程是java最基本的一种并发模型。
	
	
	
	多线程基础：
		cpu执行代码是一条一条顺序执行，即使是单核cpu，也可以同时运行多个任务。因为操作系统执行多任务实际上就是让cpu
		对多个任务轮流交替执行。
		
		多线程类似轮流让多个任务交替执行，例如，让浏览器执行0.001秒，让QQ执行0.001秒，再让音乐播放器执行0.001秒，
		在人看来，CPU就是在同时执行多个任务。即使是多核CPU，因为通常任务的数量远远多于CPU的核数，所以任务也是交替执行的。
	
		进程：
			计算机中，一个任务就是一个进程，浏览器、视频播放器、音乐播放器和word各是一个进程。
			
			某些进程内部需要同时执行多个子任务，如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，
			同时还可以在后台进行打印，我们把子任务称为线程。
			
			进程和线程的关系是：一个进程可包含一个或多个线程，至少有一个线程。
				
				Process：进程
				Thread：线程
				                        ┌──────────┐
										│Process   │
										│┌────────┐│
							┌──────────┐││ Thread ││┌──────────┐
							│Process   ││└────────┘││Process   │
							│┌────────┐││┌────────┐││┌────────┐│
				┌──────────┐││ Thread ││││ Thread ││││ Thread ││
				│Process   ││└────────┘││└────────┘││└────────┘│
				│┌────────┐││┌────────┐││┌────────┐││┌────────┐│
				││ Thread ││││ Thread ││││ Thread ││││ Thread ││
				│└────────┘││└────────┘││└────────┘││└────────┘│
				└──────────┘└──────────┘└──────────┘└──────────┘
				┌──────────────────────────────────────────────┐
				│               Operating System               │
				└──────────────────────────────────────────────┘
			操作系统调度最小单位不是进程，而是线程。
			常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程由操作系统决定，程序自己不能决定什么时候执行，
			以及执行多长时间。
			
			同一个应用程序，可以有多个进程，也能有多个线程，因此实现多任务的方法：
				
				多进程模式（每个进程只有一个线程）：
					┌──────────┐ ┌──────────┐ ┌──────────┐
					│Process   │ │Process   │ │Process   │
					│┌────────┐│ │┌────────┐│ │┌────────┐│
					││ Thread ││ ││ Thread ││ ││ Thread ││
					│└────────┘│ │└────────┘│ │└────────┘│
					└──────────┘ └──────────┘ └──────────┘
			
				多线程模式（一个进程有多个线程）：
					┌────────────────────┐
					│Process             │
					│┌────────┐┌────────┐│
					││ Thread ││ Thread ││
					│└────────┘└────────┘│
					│┌────────┐┌────────┐│
					││ Thread ││ Thread ││
					│└────────┘└────────┘│
					└────────────────────┘
			
				多进程＋多线程模式（复杂度最高）：
					┌──────────┐┌──────────┐┌──────────┐
					│Process   ││Process   ││Process   │
					│┌────────┐││┌────────┐││┌────────┐│
					││ Thread ││││ Thread ││││ Thread ││
					│└────────┘││└────────┘││└────────┘│
					│┌────────┐││┌────────┐││┌────────┐│
					││ Thread ││││ Thread ││││ Thread ││
					│└────────┘││└────────┘││└────────┘│
					└──────────┘└──────────┘└──────────┘
			
		
		进程 vs 线程：
			进程和线程是包含关系，但是多任务即可由多进程实现，也可由但进程内的多线程实现，也可混合多进程+多线程。
			使用模式根据进程和线程特点。
			
			和多线程相比，多进程缺点是：
				创建进程比创建线程开销大，尤其是Windows系统。
				进程间通信比线程间通信慢，因为线程间通信就是读写同一个变量，速度很快。
			
			多进程的优点：
				多进程稳定性比多线程高，因为多进程情况下，一个进程崩溃不会影响其他进程，而多线程情况下，任何一个
				线程崩溃都会直接导致整个进程崩溃。
			
			
		多线程：
			java内置多线程支持，一个java程序实际上是一个JVM进程，JVM进程用一个主线程执行Main()方法，在Main()方法内部，
			又可以启动多个线程。此外JVM还有负责垃圾回收的其他工作线程等。
			
			因此对大多数Java程序来说，多任务，实际上就是说如何使用多线程实现多任务。
			
			于单线程相比，多线程编程的特点在于：
				多线程经常需要读写共享数据，并且需要同步。如，播放电影，就需要线程视频播放器，另一个线程播放音频，两个线程
				需要协调运行，否则画面和声音不同步。因此，多线程编程的复杂度高，调试更困难。
			
			Java多线程编程特点：
				多线程模型是Java程序最基本的并发模型；
				后续读写网络、数据库、Web开发等都依赖Java多线程模型。
			
			
	
	创建新线程：
		java内置多线程支持，java程序启动时，实际上是启动了一个JVM进程，然后，JVM启动主线程来执行main()方法。在main()方法中，
		我们又可以启动其他线程。创建一个新线程很容易，需要实例化一个Thread实例，然后调用它的start()方法。
		
		例如：
			Thread t=new Thread();
			t.start();	//启动新线程
			
		1.多线程 此线程启动后什么都不做就会立刻结束，想让新线程执行指定代码：
			public class Main {
				public static void main(String[] args) {
					Thread t = new MyThread();
					t.start(); // 启动新线程
				}
			}

			class MyThread extends Thread {
				@Override
				public void run() {
					System.out.println("start new thread!");
				}
			}
			此方法是将指定方法实例化，方法继承Thread，然后启动新线程即可启动指定方法，
			注意到start()方法会在内部自动调用实例的run()方法。
		
		2.多线程 创建Thread实例时，传入一个Runnable实例：
			public class Main {
				public static void main(String[] args) {
					Thread t = new Thread(new MyRunnable());
					t.start(); // 启动新线程
				}
			}

			class MyRunnable implements Runnable {
				@Override
				public void run() {
					System.out.println("start new thread!");
				}
			}
			
			或java8引入的lambda语法进一步简写为：
				Thread t = new Thread(() -> {
					System.out.println("start new thread!");
				});
				t.start(); // 启动新线程
		
						
		线程的优先级：
			
			设置线程优先级：
				Thread.setPriority(int n) // 1~10, 默认值5
			
			优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，
			但不饿能通过设置优先级来确保高优先级的线程一定先执行。
			
			
		结：
			Java用Thread对象表示一个线程，通过调用start()启动一个新线程；

			一个线程对象只能调用一次start()方法；

			线程的执行代码写在run()方法中；

			线程调度由操作系统决定，程序本身无法决定调度顺序；

			Thread.sleep()可以把当前线程暂停一段时间。	
			
			
			
			
	线程的状态：
		java中，一个线程对象只能调用一次start()方法启动新线程，并在新线程中执行run()方法。一旦run()方法执行完毕，线程就结束了。
		因此，java线程状态有以下几种：
			New：新创建的线程，尚未执行；
			Runnable：运行中的线程，正在执行run()方法的Java代码；
			Blocked：运行中的线程，因为某些操作被阻塞而挂起；
			Waiting：运行中的线程，因为某些操作在等待中；
			Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待；
			Terminated：线程已终止，因为run()方法执行完毕。
			
		状态转移图：
			         ┌─────────────┐
					 │     New     │
					 └─────────────┘
							│
							▼
			┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
			 ┌─────────────┐ ┌─────────────┐
			││  Runnable   │ │   Blocked   ││
			 └─────────────┘ └─────────────┘
			│┌─────────────┐ ┌─────────────┐│
			 │   Waiting   │ │Timed Waiting│
			│└─────────────┘ └─────────────┘│
			 ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
							│
							▼
					 ┌─────────────┐
					 │ Terminated  │
					 └─────────────┘
			线程启动后，它可在Runnable、Blocked、Waiting和Timed Waiting这几个状态间切换，直到最后变成Terminated状态，线程终止。
			
		线程终止的原因有：
			线程正常终止：run()方法执行到return语句返回；
			线程意外终止：run()方法因为未捕获的异常导致线程终止；
			对某个线程的Thread实例调用stop()方法强制终止（强烈不推荐使用）。
					
		一个线程可等待另一个线程直到运行结束，如，main线程在启动t线程后，可通过t.join()等待t线程结束后再继续运行：
			Thread t = new Thread(() -> {
            System.out.println("hello");
			});
			System.out.println("start");
			t.start();
			t.join();
			System.out.println("end");
			
			当nain线程对线程对象t调用join()方法时，主线程将等待变量t表示的线程运行结束，即join就是等待该线程结束，后才继续往下执行自身线程。
			所以以上代码，顺序main线程先打印start，t线程再打印hello，main线程最后再打印end。
			
			如果t线程已结束，对实例t调用join()会立刻返回，此外join(long)的重载方法也可指定一个等待时间，超过事件后不再等待。
			
			
		结：
			Java线程对象Thread的状态包括：New、Runnable、Blocked、Waiting、Timed Waiting和Terminated；

			通过对另一个线程对象调用join()方法可以等待其执行结束；

			可以指定等待时间，超过等待时间线程仍然没有结束就不再等待；

			对已经运行结束的线程调用join()方法会立刻返回。	
	
	
	
	
	中断线程：
		如果线程需要执行一个长时间任务，就可能中断线程。中断线程就是其他线程给该线程发一个信号，该线程收到信号后结束执行run()方法，
		使自身线程能立刻结束运行。
		
		假设从网络下载100M的文件，网速很慢，用户不耐烦，下载中点击取消，此时，程序需要中断下载线程的执行。
		中断线程非常简单，只要在其他线程中对目标线程调用interrupt()方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，
		就立刻结束运行。
		
		示例代码：
			Thread t = new MyThread();
			t.start();
			Thread.sleep(1); // 暂停1毫秒
			t.interrupt(); // 中断t线程
			t.join(); // 等待t线程结束
			System.out.println("end");
			
			class MyThread extends Thread {
				public void run() {
					int n = 0;
					while (! isInterrupted()) {
						n ++;
						System.out.println(n + " hello!");
			
			输出结果：循环次数随机(规律暂不清楚)末尾是end
			main线程通过调用t.interrupt()方法中断t线程，interrupt()方法仅仅向t线程发出中断请求，以至于t线程是否能够立刻响应，
			要看具体代码，t线程的while循环会检测isInterrupted()，所以能正确响应interrupt请求，使自身立刻结束运行run方法。
			
		如果线程是等待状态，如，t.join()会让main线程进入等待状态。此时，对main线程调用interrupt()，join()会立刻抛出InterruptedException，
		因此，目标线程只要捕获到join()方法抛出的InterruptedException，就说明有其他线程对其调用了interrupt()，通常情况下该线程应立刻结束运行。
		示例代码：	
			main：
				Thread t = new MyThread();
				t.start();
				Thread.sleep(1000);
				t.interrupt(); // 中断t线程
				t.join(); // 等待t线程结束
				System.out.println("end");
						
			class MyThread extends Thread：
				public void run() {
				Thread hello = new HelloThread();
				hello.start(); // 启动hello线程
				try {
					hello.join(); // 等待hello线程结束
				} catch (InterruptedException e) {
					System.out.println("interrupted!");
				}
				hello.interrupt();
			
			class HelloThread extends Thread：
				public void run() {
				int n = 0;
				while (!isInterrupted()) {
					n++;
					System.out.println(n + " hello!");
					try {
						Thread.sleep(100);
					} catch (InterruptedException e) {
						break;
			
			输出结果：10个hello！ 其后是interrupted！ 最后是end
			
			main线程通过调用t.interrupt()从而同志t线程中断，此时t线程位于hello.join()等待中，此方法会立刻结束等待并抛出InterruptedException。
			由于在t线程中驳火了InterruptedException，因此就可准备结束该线程。t线程结束前，对hello线程也进行了interrupt()调用同志其中断。
			如果去掉这行代码，会发现hello线程仍会继续运行，且JVM不会退出。
			
		另一个常用中断线程的方法是设置标志位。通常用一个running标志位标识线程是否应该继续运行，外部线程中，通过将HelloThread.running设置为false，
		就能让线程结束：
			//中断线程：
			public static void main(String[] args)  throws InterruptedException：
				HelloThread t = new HelloThread();
				t.start();
				Thread.sleep(1);
				t.running = false; // 标志位置为false
				
			class HelloThread extends Thread：
				public volatile boolean running = true;
				public void run() {
					int n = 0;
					while (running) {
						n ++;
						System.out.println(n + " hello!");
					}
					System.out.println("end!");
			
			HelloThread的标志位boolean running是一个线程间共享的变量。线程间共享变量需要使用volatile关键字标记，确保每个线程都能读取到更新后的变量值。
			
		对线程间共享的变量使用概念剪子volatile声明，涉及到java内存模型，java虚拟机中，变量的值保存在主内存中，但当线程访问变量时，会先获取一个副本，
		并保存在自己工作内存中。如果线程修改了变量的值，虚拟机会在某时刻将修改后的值回写到主内存，但这个时间不确定。
			┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
					   Main Memory
			│                               │
			   ┌───────┐┌───────┐┌───────┐
			│  │ var A ││ var B ││ var C │  │
			   └───────┘└───────┘└───────┘
			│     │ ▲               │ ▲     │
			 ─ ─ ─│─│─ ─ ─ ─ ─ ─ ─ ─│─│─ ─ ─
				  │ │               │ │
			┌ ─ ─ ┼ ┼ ─ ─ ┐   ┌ ─ ─ ┼ ┼ ─ ─ ┐
				  ▼ │               ▼ │
			│  ┌───────┐  │   │  ┌───────┐  │
			   │ var A │         │ var C │
			│  └───────┘  │   │  └───────┘  │
			   Thread 1          Thread 2
			└ ─ ─ ─ ─ ─ ─ ┘   └ ─ ─ ─ ─ ─ ─ ┘
		这导致如果一个线程更新了某个变量，另一个线程读取的值可能还是更新前的。如，主内存的变量a=true，线程1执行=false时，此时仅仅将变量阿的副本变成了false，
		主内存的变量a还是true，JVM将修改后的a会写到主内存之前，其他线程读取到的a值仍是true，这造成了多线程之间共享的变量不一致。
		
		因此，volatile关键字的目的是高速虚拟机：
			每次访问变量时，总是获取主内存的最新值。
			每次修改变量后，立刻回写到主内存。
		
		volatile关键字解决的时可见性问题：当一个线程修改了某一个共享变量的值，其他线程能够立刻看到修改后的值。
		如果去掉volatile关键字，运行上述程序，发现效果和带volatile差不多，是因为在x86的架构下，JVM回写主内存的速度非常快，但是换成ARM的架构，就会有显著的延迟。
		
		结：
			对目标线程调用interrupt()方法可以请求中断一个线程，目标线程通过检测isInterrupted()标志获取自身是否已中断。如果目标线程处于等待状态，该线程会捕获到InterruptedException；

			目标线程检测到isInterrupted()为true或者捕获了InterruptedException都应该立刻结束自身线程；

			通过标志位判断需要正确使用volatile关键字；

			volatile关键字解决了共享变量在线程间的可见性问题。
			
			
			
	守护线程：
		守护线程就是守护其他普通线程的线程，当没有普通线程运行的时候，不论有没有守护线程，JVM都会退出。
		
		Java程序入口由JVM启动main线程，main线程也可启动其他线程。所有线程结束时，JVM退出，进程结束。
		如果线程没有退出，JVM进程就不会退出，所以必须保证所有线程都能及时结束。
		
		但是一个定时触发任务的线程目的是无限循环：
			class TimerThread extends Thread {
			@Override
			public void run() {
				while (true) {
					System.out.println(LocalTime.now());
					try {
						Thread.sleep(1000);
					} catch (InterruptedException e) {
						break;
			
			如果此线程不结束，JVM进程就无法结束。这类线程经常没有负责人负责结束他们。
		
		守护线程就是为其他线程服务的线程，JVM中，所有非守护线程执行完成后，无论有没有守护线程，虚拟机都会自动退出。
		所以JVM退出时，不用关心守护线程是否已结束。
		
		创建守护线程：
			Thread t = new MyThread();
			t.setDaemon(true);
			t.start();
			
			创建方式和普通线程一样，只是在调用start方法前，调用setDaemon(true)将线程标记为守护线程。
			
		守护线程中，编写代码注意：
			守护线程不能持有任何需要关闭的资源，如打开文件等等，因为虚拟机退出时，守护线程没有任何机会时间关闭文件，会导致数据丢失。
		
		结：
			守护线程是为其他线程服务的线程；

			所有非守护线程都执行完毕后，虚拟机退出；

			守护线程不能持有需要关闭的资源（如打开文件等）。
			
			
			
	线程同步：
		
		代码例子：https://www.liaoxuefeng.com/wiki/1252599548343744/1306580844806178
	
		多线程同时运行时，线程调度由操作系统决定，程序本身无法决定。因此任何一个线程都可能在任何指令处被操作系统暂停，
		然后在某个时间段后继续执行，此时，单线程某型下不存在的问题就是，如果多线程同时读写共享变量，会出现数据不一致的问题。
		
		两个线程对一个变量进行操作时，每次运行结果不一样。因为对变量写入读取时，结果正确必须保证原子操作。
		原子操作时指不能被中断的一个或一系列操作。
		
		我们假设n的值是100，如果两个线程同时执行n = n + 1，得到的结果很可能不是102，而是101，原因在于：
			┌───────┐    ┌───────┐
			│Thread1│    │Thread2│
			└───┬───┘    └───┬───┘
				│            │
				│ILOAD (100) │
				│            │ILOAD (100)
				│            │IADD
				│            │ISTORE (101)
				│IADD        │
				│ISTORE (101)│
				▼            ▼	
						
		如果线程1在执行ILOAD后被操作系统中断，此刻如果线程2被调度执行，它执行ILOAD后获取的值仍然是100，
		最终结果被两个线程的ISTORE写入后变成了101，而不是期待的102。

		这说明多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待：
			┌───────┐     ┌───────┐
			│Thread1│     │Thread2│
			└───┬───┘     └───┬───┘
				│             │
				│-- lock --   │
				│ILOAD (100)  │
				│IADD         │
				│ISTORE (101) │
				│-- unlock -- │
				│             │-- lock --
				│             │ILOAD (101)
				│             │IADD
				│             │ISTORE (102)
				│             │-- unlock --
				▼             ▼	
			
		通过加锁和解锁的操作，就保证3条指令总是在一个线程执行期间，不会有其他线程进入此指令区间。即使在执行期线程被操作系统中断执行，
		其他线程会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。此加锁和解锁之间的代码
		称为临界区(Critical Section)，任何时候临界区最多只有一个线程能执行。
		
		保证一段代码的原子性就是通过加锁和解锁实现。java通过sysnchronized(同步)关键字对对象进行加锁：
			synchronized(lock){
				………………
			}
			
		synchronized保证代码块在任意时刻最多只有一个线程能执行。
		
		synchronized(Counter.lock) { // 获取锁	
			表示Counter.lock为锁，多线程各自执行synchronized(Counter.lock)代码块时，必须先获得锁，才能进行代码控制。执行结束后，
			在synchronized语句块结束自动释放锁。如此，对counter.count变量进行读写就不能同时进行。
			
			synchronized解决了多线程同步访问共享变量的正确性，但是缺带来性能下降。因为synchronized代码块无法并发执行，此外，加锁
			和解锁需消耗一定的时间，所以synchronized会降低程序的效率。
		
		如何使用synchronized：
			找出修改共享变量的线程代码块；
			选择一个共享实例作为锁；
			使用synchronized(lockObject) { ... }。
			
		在使用synchronized的时候，不必担心抛出异常。因为无论是否有异常，都会在synchronized结束处正确释放锁：	
			public void add(int m) {
			synchronized (obj) {
				if (m < 0) {
					throw new RuntimeException();
				}
				this.value += m;
			} // 无论有无异常，都会在此释放锁
			
			
		错误的是不同线程使用不同的lock对象作锁，这样导致不同线程可同时获得锁，因为JVM只保证同一个锁在任意时刻
		只能被一个线程获取，但两个不同的锁在同一时刻可被两个线程分别获取。
		
		4个线程对两个共享变量分别进行读写操作，但锁都是Counter.lock对象，造成可以并发执行的Counter.studentCount+=和Count.teacherCount+=1，
		无法并发执行，效率降低，实际上同步线程可分为   AddStudentThread 和 DecStudentThread，   AddTeacherThread 和 DecTeacherThread，
		组之间不存在竞争，因此，应该使用两个不同的锁
			锁为Count.lockstudent 和 Count.lockteacher ，这样才能效率最大化。
			
		不需要synchronized的操作：
			
			JVM规范原子操作：
				基本类型（long和double除外）赋值，例如：int n = m；
				引用类型赋值，例如：List<String> list = anotherList。
			
			long和double是64位，JVM没有明确规定64位赋值操作是不是一个原子操作，但x64平台的JVM是将long和double的赋值作为原子实现操作。
			单台哦原子操作语句不需同步。如：
				public void set(int m) {
					synchronized(lock) {
						this.value = m;
				
			但是，如果是多行赋值语句，就必须保证是同步操作，例如：
				class Pair {
					int first;
					int last;
					public void set(int first, int last) {
						synchronized(this) {
							this.first = first;
							this.last = last;
			
			有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作。例如，上述代码如果改造成：
				class Pair {
					int[] pair;
					public void set(int first, int last) {
						int[] ps = new int[] { first, last };
						this.pair = ps;
					
			就不再需要同步，因为this.pair = ps是引用赋值的原子操作。而语句：
				int[] ps = new int[] { first, last };
			
			这里的ps是方法内部定义的局部变量，每个线程都会有各自的局部变量，互不影响，并且互不可见，并不需要同步。		
			
		结：
			多线程同时读写共享变量时，会造成逻辑错误，因此需要通过synchronized同步；

			同步的本质就是给指定对象加锁，加锁后才能继续执行后续代码；

			注意加锁对象必须是同一个实例；

			对JVM定义的单个原子操作不需要同步	
			
			
	同步方法：
		java靠synchronized进行线程同步，使用synchronized的时候，锁住哪个对象很重要。
		线程自己选择锁对象往往使得代码逻辑混乱，也不利于封装。更好方法是将synchronized逻辑封装起来。
		
		计数器例子：
			public class Counter {
			private int count = 0;

			public void add(int n) {
				synchronized(this) {
					count += n;
				}
			}

			public void dec(int n) {
				synchronized(this) {
					count -= n;
				}
			}

			public int get() {
				return count;
			
			如此，线程调用add、dec方法时，不用关心同步逻辑，因为synchronized代码块在add、dec内部。并且，sunchronized锁住对象是this，
			即当前实例，使得创建多个Counter实例的时候，它们之间互不影响，可以并发执行。
			
			var c1 = Counter();
			var c2 = Counter();

			// 对c1进行操作的线程:
			new Thread(() -> {
				c1.add();
			}).start();
			new Thread(() -> {
				c1.dec();
			}).start();

			// 对c2进行操作的线程:
			new Thread(() -> {
				c2.add();
			}).start();
			new Thread(() -> {
				c2.dec();
			}).start();
		
		
		现对于Counter类，多线程可正确调用。
		如果一个类被设计为允许正确访问，那么这个类就是“线程安全”的(thread-safe)，上面的counter类就是线程安全的。
		java标准库的java.lang.StringBuffer也是线程安全的。
		还有写不变类，String、Integer、LocalDate，所有的成员变量都是final，多线程同时访问时只能读不能写，不变类也是线程安全的。
		类似Math只提供静态方法没有成员变量的类，也是线程安全的。
		
		ArrayList都是非线程安全的，不能再多线程中修改它们，但，如果所有线程都只能读不能写，那么ArrayList是可以安全地再线程间共享的。
			
		没有特殊说明时，一个类默认是非线程安全的。
		synchronized(this)	同步锁，锁住的是this实例时，实际上可用synchronized修饰此方法，以下方法作用相同：
			
			public void add(int n) {						public synchronized void add(int n) { // 锁住this
			synchronized(this) { // 锁住this					count += n;
				count += n;									} // 解锁
			} // 解锁
			
			使用synchronized修饰的方法就是同步方法，表示整个方法都必须使用this实例加锁。
		
		对于static方法，是没有this实例的，因为static方法是针对类而不是实例。但注意到任何一个类都有一个由JVM自动创建的Class实例，因此，
		对static方法添加synchronized，锁住的是该类的Class实例：
			
			public synchronized static void test(int n) {
			...
			
			就相当于
			
			public class Counter {
				public static void test(int n) {
					synchronized(Counter.class) {
						...
			
			读取一个变量不需要同步，读取两个变量时就需要同步。
			
		结：
			用synchronized修饰方法可以把整个方法变为同步代码块，synchronized方法加锁对象是this；

			通过合理的设计和数据封装可以让一个类变为“线程安全”；

			一个类没有特殊说明，默认不是thread-safe；

			多线程能否安全访问某个非线程安全的实例，需要具体问题具体分析。	
			
			
	死锁：
		java线程锁是可重入的锁。
		如：
			private int count = 0;

			public synchronized void add(int n) {
				if (n < 0) {
					dec(-n);
				} else {
					count += n;
				
			public synchronized void dec(int n) {
				count += n;
			
			由于synchronized修饰的add方法，一旦线程执行到add方法内部，说明已经获取到当前实例this锁。
			如果传入的n<0，将在add方法内部调用dec方法。由于dec方法也需要获取this锁，对同一个线程，也能
			在获取到锁后继续获取同一个锁。
			因为JVM允许同一线程重复获取同一个锁，这种能被同一个线程反复获取的锁，叫可重入锁。
			java线程锁是可重入锁，so，获取锁的时候，不但判断是否第一次获取，还要记录是第几次获取。
			每获取一次，记录+1，每退出synchronized块记录-1，减到0，才会真正释放锁。
			
		死锁：
			线程获得锁后，再继续获得另一个锁。
			public void add(int m) {
				synchronized(lockA) { // 获得lockA的锁
					this.value += m;
					synchronized(lockB) { // 获得lockB的锁
						this.another += m;
					} // 释放lockB的锁
				} // 释放lockA的锁
			
			dec方法线程先获取b再获取a
			
			获取多个锁的时候，不同线程获取多个不同对象的锁可能导致死锁。
			
			线程1和2分别执行add和dec时：
					线程1：进入add()，获得lockA；
					线程2：进入dec()，获得lockB。
				
				随后：

					线程1：准备获得lockB，失败，等待中；
					线程2：准备获得lockA，失败，等待中。
			
			此时两线程各有不同锁，但各自试图获取对方的锁，造成双方无限等待，这是死锁。
			死锁，没有任何机制能解除死锁，只能强制结束JVM进程。
			
			死锁的避免方式时线程获取锁的顺序要一致。
			
			避免死锁的方式就是线程获取锁的顺序要一致，先获取locka再获取lockb的顺序。
						
		结：
			Java的synchronized锁是可重入锁；

			死锁产生的条件是多线程各自持有不同的锁，并互相试图获取对方已持有的锁，导致无限等待；

			避免死锁的方法是多线程获取锁的顺序要一致。			
			
			
	
	使用wait和notify(推迟和通知)：
		synchronized解决了多线程竞争的问题。
		如对一个任务管理器，多个线程同时向队列中添加任务，使用synchronized加锁：
			class TaskQueue {
			Queue<String> queue = new LinkedList<>();

			public synchronized void addTask(String s) {
				this.queue.add(s);
		
		synchronized并没有解决多线程协调问题。
		
		以TashQueue为例，编写一个getTask方法取出队列的第一个任务：
			class TaskQueue {
			Queue<String> queue = new LinkedList<>();

			public synchronized void addTask(String s) {
				this.queue.add(s);
			}

			public synchronized String getTask() {
				while (queue.isEmpty()) {
				}
				return queue.remove();
			get判断队列是否为空，为空则循环等待，直到另一个线程向队列放入任务，while退出循环，就可返回队列元素。
			但while永不退出，因为线程执行while循环时，已经getTask入口获取this锁，其他线程无法调用addTask，因为
			addTask执行条件也是获取this锁。
			
			因为想执行效果是：
				线程1可调用addTask不断向队列中添加任务。
				线程2可以调用getTask从队列中获取任务。如果队列为空，则getTask应该等待，直到队列中有一个任务返回。
			
			多线程运行原则就是：条件不满足时，线程进入等待状态。条件满足时，线程被唤醒，继续执行任务。
				gettask方法的while方法体中添加this.wait()语句，表示如果条件成立(队列为空)进入等待状态。
				关键是：wait必须再当前获取锁的对象上调用，获取的是this锁，因此调用this.wait。
				调用wait方法后线程进入等待，wait不会返回，直到线程从等待被其他线程唤醒后，wait将返回然后执行下一条语句。
				
			wait的机制非常复杂，是定义再object类的一个native方法，就是JVM的C代码实现的，并且必须再synchronized块中才能调用
			wait方法，因为wait调用时，会释放线程获得的锁，wait方法返回后，线程会重新试图获得锁。
			
			所以只能再锁对象上调用wait方法，因为再getTask中，获得了this锁，so只能再this对象上调用wait方法：
				public synchronized String getTask() {
				while (queue.isEmpty()) {
					// 释放this锁:
					this.wait();
					// 重新获取this锁
				}
				return queue.remove()
			
			当一个线程在this.wait等待时，会释放this锁，从而使得其他线程能够addTask方法获得this锁。
			
			将等待的线程被重新唤醒，从wait返回的话要在相同锁对象调用notify方法：
				public synchronized void addTask(String s) {
					this.queue.add(s);
					this.notify(); // 唤醒在this锁等待的线程
				
				在向队列中添加任务后，线程立刻对this锁对象调用notify方法，此方法会唤醒一个正在this锁等待的线程
				(在getTask中位于this.wait线程)，从而使等待线程this.wait方法返回。
			
			
		结：
			wait是推迟，notify是通知，notifyAll是通知所有
			
			wait和notify用于多线程协调运行：

			在synchronized内部可以调用wait()使线程进入等待状态；

			必须在已获得的锁对象上调用wait()方法；

			在synchronized内部可以调用notify()或notifyAll()唤醒其他等待线程；

			必须在已获得的锁对象上调用notify()或notifyAll()方法；

			已唤醒的线程还需要重新获得锁后才能继续执行。	
			
			
			
			
	使用ReentrantLock(可重入锁)：
		java5引入一个高级的处理并发java.util.concurrent包，提供了大量更高级的并发功能，能大大简化多线程程序编写。
		synchronized用于加锁，此锁是很重并且获取时要一直等待，没有额外的尝试机制。
		java.util.concurrent.locks包提供的ReentrantLock用于替代synchronized加锁。
		
		传统synchronized代码：
			public class Counter {
				private int count;
				public void add(int n) {
					synchronized(this) {
						count += n;
						
		使用ReentrantLock代替：
			public class Counter {
				private final Lock lock = new ReentrantLock();
				private int count;

				public void add(int n) {
					lock.lock();
					try {
						count += n;
					} finally {
						lock.unlock();
			
			
		因为synchronized是java提供语法，so不需要担心异常，ReentrantLock是java实现的锁，就必须先获取锁，然后在finally中释放锁。
		ReentrantLock是可重入锁，和sunchronized一样，一个线程可多次获取同一个锁。
		
		和synchronized不同，ReentrantLock可尝试获取锁：
			if (lock.tryLock(1, TimeUnit.SECONDS)) {
				try {
					...
				} finally {
					lock.unlock();
			以上代码尝试获取锁的时候，最多等待1秒。1秒后仍未获取锁，tryLock返回false，程序就可以做一些额外处理，而不是无限期等下去。
		
		所以ReentrantLock比直接使用synchronized更安全，线程在tryLock失败的时候不会导致死锁。
		
		结：
			ReentrantLock可以替代synchronized进行同步；

			ReentrantLock获取锁更安全；

			必须先获取到锁，再进入try {...}代码块，最后使用finally保证释放锁；

			可以使用tryLock()尝试获取锁。	
			
			
	使用Condition(条件锁)：
		使用ReentrantLock比直接使用synchronized更安全，可替代synchronized进行线程同步。
		synchronized可配合wait和notify实现线程在条件不满足时等待，条件满足时唤醒，用ReentrantLock编写wait和notify时，
		使用Condition对象实现wait和notify的功能。
		
		以TaskQueue为例，将前面synchronized实现的功能通过ReentrantLock和Condition实现：
			private final Lock lock = new ReentrantLock();
			private final Condition condition = lock.newCondition();
			private Queue<String> queue = new LinkedList<>();     队列集合
			
			public void addTask(String s) {
				lock.lock();
				try {
					queue.add(s);
					condition.signalAll();
				} finally {
					lock.unlock();

			public String getTask() {
				lock.lock();
				try {
					while (queue.isEmpty()) {
						condition.await();
					}
					return queue.remove();
				} finally {
					lock.unlock();
			
			Condition，引用的Condition对象必须从Lock实例的newCondition返回，才能获得一个绑定Lock实例的Condition实例。
			Condition提供的await、signal、signalAll原理和synchronized锁对象的wait、notify、notifyAll是一致的，其行为也一样。
				await()会释放当前锁，进入等待状态；

				signal()会唤醒某个等待线程；

				signalAll()会唤醒所有等待线程；

				唤醒线程从await()返回后需要重新获得锁。
			
			此外和tryLock类似，await可以在等待指定时间后，如果还没被其他线程通过signal或signalAll唤醒，可自己醒来。
			
			if (condition.await(1, TimeUnit.SECOND)) {
				// 被其他线程唤醒
			} else {
				// 指定时间内没有被其他线程唤醒
					
		所以，使用Condition配合Lock，实现更灵活的线程同步。
		
		结：
			Condition可以替代wait和notify；

			Condition对象必须从Lock对象获取。
			
			
	使用ReadWriteLock(读写锁)：
		ReentrantLock保证只有一个线程可以执行临界锁：
			private final Lock lock = new ReentrantLock();
			private int[] counts = new int[10];
			
			public void inc(int index) {
				lock.lock();
				try {
					counts[index] += 1;
				} finally {
					lock.unlock();
			
			public int[] get() {
				lock.lock();
				try {
					return Arrays.copyOf(counts, counts.length);
				} finally {
					lock.unlock();
			
			
		但有时这种保护有点过头。因为任何时候只允许一个线程修改，也就是inc方法必须获取锁，但是get方法只读取数据不修改，
		但实际上允许多个线程同时调用。
		
		理想是：允许多个线程同时读，但只要一个线程在写，其他线程必须等待：	
				读		写
			读	允许	不允许
			写	不允许	不允许
			
		ReadWriteLock可解决这个问题，其保证了：
			只许一个线程写入(其他线程既不能写入也不能读取)。
			没有写入时，多个线程允许同时读(提高性能)。
			
		用ReadWriteLock实现这个功能十分容易。我们需要创建一个ReadWriteLock实例，然后分别获取读锁和写锁：	
			private final ReadWriteLock rwlock = new ReentrantReadWriteLock();	可重入读写锁
			private final Lock rlock = rwlock.readLock();		读锁
			private final Lock wlock = rwlock.writeLock();		写锁
			private int[] counts = new int[10];					线程数组

			public void inc(int index) {
				wlock.lock(); // 加写锁
				try {
					counts[index] += 1;
				} finally {
					wlock.unlock(); // 释放写锁
					
			public int[] get() {
				rlock.lock(); // 加读锁
				try {
					return Arrays.copyOf(counts, counts.length);
				} finally {
					rlock.unlock(); // 释放读锁
			
		把读写操作分别用读锁和写锁来加锁，在读取时，多个线程可以同时获得读锁，这样就大大提高了并发读的执行效率。
		使用ReadWriteLock时，适用条件是同一个数据，有大量线程读取，但仅有少数线程修改。
		例如，一个论坛的帖子，回复可以看做写入操作，它是不频繁的，但是，浏览可以看做读取操作，是非常频繁的，这种情况就可以使用ReadWriteLock。

		结：
			使用ReadWriteLock可以提高读取效率：

			ReadWriteLock只允许一个线程写入；

			ReadWriteLock允许多个线程在没有写入时同时读取；

			ReadWriteLock适合读多写少的场景。	
			
			
			
	使用StampedLock(读写锁改进版)：		
		ReadWriteLock可解决多线程同时读，但只有一个线程能写的问题。	
		ReadWriteLock潜在的问题是：如果线程在读，写线程需要等待线程释放锁后才能获取写锁，读的过程中不允许写，这是悲观的读锁。
		StampedLock和ReadWriteLock相比，改进之处在于：
			读的过程中也允许获取写锁后写入。如此，读取的数据就可能不一致，所以需要判断读的过程中是否有写入，这种读锁是乐观锁。
		
		乐观锁：是乐观的估计读的过程中大概率不会有写入，因此为乐观锁。
		悲观锁：读的过程中拒绝写入，就是写入必须等待。
		显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍即可。
		
		例子如下：
			private final StampedLock stampedLock = new StampedLock();
			private double x;
			private double y;

			public void move(double deltaX, double deltaY) {
				long stamp = stampedLock.writeLock(); // 获取写锁
				try {
					x += deltaX;
					y += deltaY;
				} finally {
					stampedLock.unlockWrite(stamp); // 释放写锁

			public double distanceFromOrigin() {
				long stamp = stampedLock.tryOptimisticRead(); // 获得一个乐观读锁
				// 注意下面两行代码不是原子操作
				// 假设x,y = (100,200)
				double currentX = x;
				// 此处已读取到x=100，但x,y可能被写线程修改为(300,400)
				double currentY = y;
				// 此处已读取到y，如果没有写入，读取是正确的(100,200)
				// 如果有写入，读取是错误的(100,400)
				if (!stampedLock.validate(stamp)) { // 检查乐观读锁后是否有其他写锁发生
					stamp = stampedLock.readLock(); // 获取一个悲观读锁
					try {
						currentX = x;
						currentY = y;
					} finally {
						stampedLock.unlockRead(stamp); // 释放悲观读锁
					}
				}
				return Math.sqrt(currentX * currentX + currentY * currentY);
			
			和ReadWriteLock相比，写入的加锁是一样的，不同的是读取。首先通过tryOptimisticRead获取一个乐观读锁，并返回版本号。
			接着进行读取，读完后，通过validate验证版本号，如果读取过程中没有写入，版本号不变，验证成功，就能继续后续操作。
			如果读取过程中有写入，版本号发生变化，验证失败。失败的时候，再通过悲观读锁再次读取。由于写入的概率不高，程序绝大
			部分情况下可通过乐观读锁获取数据，极少情况下使用悲观读锁获取数据。
			
			StampedLock提供更复杂将悲观读锁升级为写锁的功能，主用在if-then-update的场景：
				先读，如果读的数据满足条件，就返回，如果读的数据不满足条件，再尝试写。
			
		结：
			StampedLock提供了乐观读锁，可取代ReadWriteLock以进一步提升并发性能；

			StampedLock是不可重入锁。	
			
	

	
	使用Concurrent集合(并发)：
	
		concurrent(并发)
		ReentrantLock(阻塞队列)
		TaskQueue(任务队列)
	
		ReentrantLock(阻塞队列)和Condition实现BlockingQueue：
			private final Lock lock = new ReentrantLock();
			private final Condition condition = lock.newCondition();
			private Queue<String> queue = new LinkedList<>();

			public void addTask(String s) {
				lock.lock();
				try {
					queue.add(s);
					condition.signalAll();
				} finally {
					lock.unlock();

			public String getTask() {
				lock.lock();
				try {
					while (queue.isEmpty()) {
						condition.await();
					}
					return queue.remove();
				} finally {
					lock.unlock();
			
			BlockingQueue意思是，当一个线程用TaskQueue的getTask方法时，该方法内部可能会让线程变为等待状态，直到队列条件满足不为空，
			线程被唤醒后，getTask才会返回。
			因为BlockingQueue非常有用，直接使用java标准库的java.util.concurrent包提供的线程安全的集合：ArrayBlockingQueue。
			除了BlockingQueue外，针对List、Map、Set、Deque等，java.util.concurrent包也提供了对应的并发合集类。
			
		并发合集类如下：
			interface		non-thread-safe				thread-safe
			List			ArrayList					CopyOnWriteArrayList
			Map				HashMap						ConcurrentHashMap
			Set				HashSet / TreeSet			CopyOnWriteArraySet
			Queue			ArrayDeque / LinkedList		ArrayBlockingQueue / LinkedBlockingQueue
			Deque			ArrayDeque / LinkedList		LinkedBlockingDeque
			
			使用这些并发合集与使用非线程安全的集合类完全相同，ConcurrentHashMap为例：
				
				Map<String, String> map = new ConcurrentHashMap<>();
				// 在不同的线程读写:
				map.put("A", "1");
				map.put("B", "2");
				map.get("A", "1");
			因为所有同步和加锁的逻辑都在集合内部实现，对外部调用来说，只要正常按接口引用，其他代码和原来的非线程安全代码完全一样。
			当我们需要多线程访问时将
				Map<String, String> map = new HashMap<>();
			改为
				Map<String, String> map = new ConcurrentHashMap<>();
			即可。
		
		java.util.Collections工具类提供一个旧线程安全集合转换器：
			Map unsafeMap = new HashMap();
			Map threadSafeMap = Collections.synchronizedMap(unsafeMap);
			
			但实际上时用一个包装了非线程安全的Map，然后对所有读写方法都用synchronized加锁，这样获得的线程安全集合的性能比
			java.util.concurrent集合低很多，so不推荐使用。
			
		结：
			使用java.util.concurrent包提供的线程安全的并发集合可以大大简化多线程编程：

			多线程同时读写并发集合是安全的；

			尽量使用Java标准库提供的并发集合，避免自己编写同步代码。
			
			
			
	使用Atomic(原子性)：
		
		atomic          原子性
		compareAndSet   比较交换
		incrementAndGet 增加并获得
		LongAdder 		自增计数器 
		LongAccumulator 累加器
		
		java.util.concurrent除了提供底层锁，并发集合外，还提供一组原子操作的封装类，位于java.util.concurrent.atomic包。
		
		AtomicInteger为例，主要操作有：
			增加值并返回新值：int addAndGet(int delta)
			加1后返回新值：	  int incrementAndGet()
			获取当前值：	  int get()
			用CAS方式设置：   int compareAndSet(int expect, int update)
		
		Atomic类通过无锁(lock-free)的方式实现的线程安全(thread-safe)访问。主要原理利用CAS：Compare and Set。
			
		自己通过CAS编写incrementAndGet，大概张这样：
			public int incrementAndGet(AtomicInteger var) {
				int prev, next;
				do {
					prev = var.get();
					next = prev + 1;
				} while ( ! var.compareAndSet(prev, next));
				return next;
			
		CAS指，此操作中，如果AtomicInteger的当前值是prev，那么就更新为next，返回true。
		如果AtomicInteger的当前值不是prev，就什么都不干，返回false。通过CAS操作并配合do...while循环，
		即使其他线程修改了AtomicInteger的值，最终结果也是正确的。
			
		利用AtomicLong可编写一个多线程安全的全局唯一ID生成器：
			class IdGenerator {
				AtomicLong var = new AtomicLong(0);

				public long getNextId() {
					return var.incrementAndGet();
			
			一般不需要直接do...while循环调用compareAndSet实现复杂的并发操作，而是使用incrementAndGet这样封装好的方法，
			因此使用非常简单。
			高度竞争的情况下，可使用Java8的LongAdder和LongAccumulator。
		
		结：
			使用java.util.concurrent.atomic提供的原子操作可以简化多线程编程：

			原子操作实现了无锁的线程安全；

			适用于计数器，累加器等。
			
			
			
			
	使用线程池：
		创建线程需要操作系统资源(县城资源，栈空间等等)，频繁创建和销毁大量线程需要消耗大量事件。
		
		复用一组线程：
			┌─────┐ execute  ┌──────────────────┐
			│Task1│─────────>│ThreadPool        │
			├─────┤          │┌───────┐┌───────┐│
			│Task2│          ││Thread1││Thread2││
			├─────┤          │└───────┘└───────┘│
			│Task3│          │┌───────┐┌───────┐│
			├─────┤          ││Thread3││Thread4││
			│Task4│          │└───────┘└───────┘│
			├─────┤          └──────────────────┘
			│Task5│
			├─────┤
			│Task6│
			└─────┘
			就可以将很多小任务让一组线程执行，而不是对应一个新线程。这种能接收大量小任务并进行分发处理的就是线程池。
			
			就是线程池内部维护了若干个线程，没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。
			如果所有线程都处于忙碌状态，新任务要么都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。
			
		Java标准库提供了ExecutorService接口表示线程池，它的典型用法如下：	
			// 创建固定大小的线程池:
			ExecutorService executor = Executors.newFixedThreadPool(3);
			// 提交任务:
			executor.submit(task1);
			executor.submit(task2);
			executor.submit(task3);
			executor.submit(task4);
			executor.submit(task5);
			
		因为ExecutorService只是接口，标准库提供常用实现类：
			FixedThreadPool：线程固定的线程池。
			CachedThreadPool：线程数根据任务动态调整的线程池。
			SingleThreadExecutor：仅单线程执行的线程池。
		
		创建这些线程池的方法都被封装到Executors类中。以FixedThreadPool为例，观察线程池的执行逻辑：
			// 创建一个固定大小的线程池:
			ExecutorService es = Executors.newFixedThreadPool(4);
			for (int i = 0; i < 6; i++) {
				es.submit(new Task("" + i));
			}
			// 关闭线程池:
			es.shutdown();
			
			class Task implements Runnable {
				private final String name;

				public Task(String name) {
					this.name = name;
				}

				@Override
				public void run() {
					System.out.println("start task " + name);
					try {
						Thread.sleep(1000);
					} catch (InterruptedException e) {
					}
					System.out.println("end task " + name);
				}
			
			执行结果是，由于有6个任务，线程池只有4个线程，所以会前4个线程同时执行，线程空闲后，才执行后面两个任务。
			线程池在程序结束后要记得关闭。使用shutdown方法关闭线程池时，会等待正在执行的任务先完成，然后关闭。
			shutdownNow会立刻停止正在执行的任务，awaitTermination则会等指定的事件让线程池关闭。
			如果线程池改为CanchedThreadPool，由于此线程池的实现根据任务数量动态调整线程池大小，所以6个任务能同时执行。
			
		想创建指定动态范围的线程池：
			int min = 4;
			int max = 10;
			ExecutorService es = new ThreadPoolExecutor(min, max,
					60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
			
		
		ScheduledThreadPool：
			某些任务需要定期反复执行，如，每秒刷新证券价格。
			此任务本身固定，但要反复执行，可使用ScheduledThreadPool。放入ScheduledThreadPool的任务可以定期反复执行。
			
			创建一个ScheduledThreadPool仍是通过Executors类：
				ScheduledExecutorService ses = Executors.newScheduledThreadPool(4);
			
			可通过提交一次性任务，会在指定延迟后只执行一次：
				// 1秒后执行一次性任务:
				ses.schedule(new Task("one-time"), 1, TimeUnit.SECONDS);
			
			如果任务固定每3秒执行：
				// 2秒后开始执行定时任务，每3秒执行:
				ses.scheduleAtFixedRate(new Task("fixed-rate"), 2, 3, TimeUnit.SECONDS);
			
			任务以固定每3秒为间隔执行：
				// 2秒后开始执行定时任务，以3秒为间隔执行:
				ses.scheduleWithFixedDelay(new Task("fixed-delay"), 2, 3, TimeUnit.SECONDS);
			
			
			注意FixedRate和FixedDelay的区别。FixedRate是指任务总是以固定时间间隔触发，不管任务执行多长时间：
				│░░░░   │░░░░░░ │░░░    │░░░░░  │░░░  
				├───────┼───────┼───────┼───────┼────>
				│<─────>│<─────>│<─────>│<─────>│
			FixedDelay则是上次任务执行完后，等待固定时间间隔，再执行下一次任务：
				│░░░│       │░░░░░│       │░░│       │░
				└───┼───────┼─────┼───────┼──┼───────┼──>
					│<─────>│     │<─────>│  │<─────>│
			
			so使用ScheduledThreadPool时，要根据需要选择执行一次，FixedRate执行还是FixedDelay执行。
			
			标准库提供java.util.Timer类，此类可定期执行任务，但一个Timer会对应一个Thread，所以一个Timer只能定期执行一个任务，
			多个定时任务必须启动多个Timer，儿一个ScheduleThreadPool可调度多个定时任务，so可用ScheduledThreadPool取代旧的Timer。
			
		结：
			JDK提供了ExecutorService实现了线程池功能：

			线程池内部维护一组线程，可以高效执行大量小任务；

			Executors提供了静态方法创建不同类型的ExecutorService；

			必须调用shutdown()关闭ExecutorService；

			ScheduledThreadPool可以定期调度多个任务。	
			
			
			
			
	使用Future(未来)：
		
		Runnable（可运行）
		Callable（可调用）
		ExecutorService（执行器 服务）
		submit（提交）
	
		多任务时，使用线程池方便。提交任务只需要实现Runnable接口，就可让线程池执行：
			class Task implements Runnable {
				public String result;
				public void run() {
					this.result = longTimeCalculation(); 
		
		Runnable接口的问题是方法没有返回值。如果需要返回结果只能保存到变量，还要提供额外的方法读取。所以还有个Callable接口，
		和Runnable接口比，它多了返回值：
			class Task implements Callable<String> {
				public String call() throws Exception {
					return longTimeCalculation(); 
			Callable接口是泛型接口，可返回指定类型结果。
		
		获取异步执行结果的话。
		ExecutorService.submit方法，其返回一个Future类型，一个Future类型的实例代表一个未来能获取结果的对象：
			//定义线程数为4的线程池
			ExecutorService executor = Executors.newFixedThreadPool(4)；
			//定义任务
			Callable<String> task = new Task();
			//提交任务并获得Future
			Future<String> future = executor.submit(task);
			//从Future获取异步执行返回的结果
			String result = future.get() //可能阻塞
			
			提交Callable任务后，同时会获得一个Future对象，然后再主线程某时刻吊桶Future兑现的get方法，就能获得异步执行的结果。
			在调用get时，如果一波任务已完成，就直接获得结果。如果异步还没完成，get就会阻塞直到任务完成后才返回结果。
			
		一个Future<V>接口表示一个未来可能会返回的结果，定义方法：
			get：获取结果(可能会等待)
			get(long timeout， TimeUnit unit):获取结果，但只等待指定时间
			cancel(boolean mayInterruptIfRunning)：取消当前任务
			isDone：判断任务是否已完成
			
		结：
			对线程池提交一个Callable任务，可以获得一个Future对象；

			可以用Future在将来某个时刻获取结果。	
			
			
			
	使用CompletableFuture(用于异步编程的类)：
		
		CompletableFuture的优点是：
			异步任务结束时，会自动回调某个对象的方法；
			异步任务出错时，会自动回调某个对象的方法；
			主线程设置好回调后，不再关心异步任务的执行。
			
		结：
			CompletableFuture可以指定异步处理流程：

			thenAccept()处理正常结果；
			exceptional()处理异常结果；
			thenApplyAsync()用于串行化另一个CompletableFuture；
			anyOf()和allOf()用于并行化多个CompletableFuture。	
			
			
	使用ForkJoin：
		java7引入的Fork/Join线程池，可将大任务拆分成多个小任务进行执行。
		
		如果计算一个超大数组的和，最简单的就是一个循环在一个线程内完成：
			┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
			└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
		或数组拆分两份分别计算最后加起来就是最终结果，分别用两个线程并行执行：
			┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
			└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
			┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
			└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
		两个线程还是很大，就拆分成4个，4个线程并行执行：
			┌─┬─┬─┬─┬─┬─┐
			└─┴─┴─┴─┴─┴─┘
			┌─┬─┬─┬─┬─┬─┐
			└─┴─┴─┴─┴─┴─┘
			┌─┬─┬─┬─┬─┬─┐
			└─┴─┴─┴─┴─┴─┘
			┌─┬─┬─┬─┬─┬─┐
			└─┴─┴─┴─┴─┴─┘
		这就是Fork/Join任务的原理：判断一个任务是否足够小，如果是则直接计算，否则分拆成几个小任务分别计算。
		此过程可反复裂变成一系列小任务(子任务)。
		Fork/Join线程池在标准库中应用，标准库提供的java.util.Arrays.parallelSort(array)进行并行排序，原理是内部通过Fork/Join
		对大数组拆分进行排序，在多核CPU上可大大提高排序的速度。
	
			
		结：
			Fork/Join是一种基于“分治”的算法：通过分解任务，并行执行，最后合并结果得到最终结果。

			ForkJoinPool线程池可以把一个大任务分拆成小任务并行执行，任务类必须继承自RecursiveTask或RecursiveAction。

			使用Fork/Join模式可以进行并行计算以提高效率。	
			
			
			
	使用ThreadLocal(线程局部变量)：
	
		ThreadLocl(线程局部变量)
		context(上下文)
	
		多线程是java实现多任务的基础，Thread对象代表一个线程，可以在代码中调用Thread.currentThread()获取当前线程，打印日志时，可同时打印出当前线程名字。
		web应用程序是典型的多任务应用，每个用户请求页面时，都会创建一个任务，如：
			public void process(User user) {
				checkPermission();	检查权限
				doWork();			做工作
				saveStatus();		保存状态
				sendResponse();		发送响应
		
		观察process，内部需要调用其他方法，但如何在一个线程内传递状态。
			public void process(User user) {
				checkPermission(user);
				doWork(user);
				saveStatus(user);
				sendResponse(user);
			
			可能传递user即可，但一个方法有会调用其他很多方法会导致user传递到所有地方
			void doWork(User user) {
				queryStatus(user);
				checkStatus();
				setNewStatus(user);
				log();
			这种线程中，横跨千万方法，需传递的对象，通常称为上下文(Context)，是一种状态，可以是用户身份，任务信息等。
			方法每增加一个Context参数非常麻烦，有些时候，如果调用链有无法修改源码的第三发库，user对象就传不进去。
			标准库提供一个特殊的ThreadLocl(线程局部变量)，它可以在一个线程中传递同一个对象。
			
			ThreadLocl实例通常以静态字段初始化如下：
				static ThreadLocal<User> threadLoclUser = new ThreadLocl<>();
				
				典型使用方式：
					void processUser(user){
						try{
							threadLoclUser.set(user);
							step1();
							step2();
						}finally{
							threadLoclUser.remove();
				通过设置User实例关联到ThreadLocal中，移除之前，所有方法可随时获取user实例：
					void step1() {
						User u = threadLocalUser.get();
						log();
						printUser();

					void log() {
						User u = threadLocalUser.get();
						println(u.name);

					void step2() {
						User u = threadLocalUser.get();
						checkUser(u.id);
			
			普通方法调用一定是同一个线程执行，so，step1、step2以及log方法内，threadLocalUser.get获取的user对象时同一个实例。
			实际上可将ThreadLocal看成一个全局Map<Thread,Object>，每个线程ThreadLocal变量时，总使用Thread自身作为key。
				Object threadLocalValue = threadLocalMap.get(Thread.currentThread());
			因此ThreadLocal相当于给每个线程开辟一个独立的存储空间，各个线程的ThreadLocal关联的实例互不干扰。
			应特别注意ThreadLocal一定在finally中清除。
				try {
					threadLocalUser.set(user);
					...
				} finally {
					threadLocalUser.remove();
			因为当前线程执行相关代码后，可能被重新放入线程池，如果ThreadLocal没被清除，该线程执行其他代码时，会把上一次状态带进去。
			为保证释放ThreadLocal关联的实例，通过AutoCloseable接口配合try(resource){}结构，让编译器自动为我们关闭，
			如一个保存当前用户名的ThreadLocal封装为一个userContext对象：
				
				public class UserContext implements AutoCloseable {
					static final ThreadLocal<String> ctx = new ThreadLocal<>();
					public UserContext(String user) {
						ctx.set(user);

					public static String currentUser() {
						return ctx.get();

					@Override
					public void close() {
						ctx.remove();
			
			使用时借助try(resource){}结构可：
				try (var ctx = new UserContext("Bob")) {
					// 可任意调用UserContext.currentUser():
					String currentUser = UserContext.currentUser();
				} // 在此自动调用UserContext.close()方法释放ThreadLocal关联对象
			这样就在UserContext中完全封装了ThreadLocal。外部代码try(resource){}内部随时调用UserContext.currentUser()获取当前线程绑定的用户名。
			
		结：
			ThreadLocal表示线程的“局部变量”，它确保每个线程的ThreadLocal变量都是各自独立的；

			ThreadLocal适合在一个线程的处理流程中保持上下文（避免了同一参数在所有方法中传递）；

			使用ThreadLocal要用try ... finally结构，并在finally中清除。	
			
			
			
			
			
Maven基础：
	
	Maven是java项目管理和构建工具，定义项目结构、项目依赖，并使用统一方式进行自动化构建。
	
	Maven介绍：
		依赖包的管理：将需要的包放入classpath中。
		目录结构：src目录存放java源代码，resources目录存放配置文件，bin目录存放编译生成的.class文件。
		配置环境：JDK版本，编译打包流程，当前代码版本号。
		除Ecplise这种IDE外，还要命令行工具进行编译，项目才能在独立服务器上编译、测试、部署。
		结合以上配置就需要标准化的java项目管理构建工具进行整合。
	
		Maven-java项目管理构建工具：
			提供了一套标准化项目结构。
			提供一套标准化的构建流程(编译，测试，打包，发布)。
			提供一套依赖管理机制。
		
		Maven项目结构：
			Maven管理的普通java项目，目录结构：
				a-maven-project
				├── pom.xml
				├── src
				│   ├── main
				│   │   ├── java
				│   │   └── resources
				│   └── test
				│       ├── java
				│       └── resources
				└── target
				项目根目录a-maven-project是项目名，项目描述文件是pom.xml，存放java源码目录是src/main/java，
				存放测试源码目录为src/test/java，存放测试资源的目录是src/test/resources，所有编译打包生成的文件
				全在target目录里，这就是Mavne项目的标注目录结构。
				
			所有目录结构都是约定好的标准结构，不能随意更改目录结构，使用标准结构不用做任何配置，Maven即可正常使用。
			
			pom.xml描述文件构造基本如下(翻译为机翻)：
				<project ...>										项目
					<modelVersion>4.0.0</modelVersion>				模型版本
					<groupId>com.itranswarp.learnjava</groupId>		项目包名
					<artifactId>hello</artifactId>					项目名称
					<version>1.0</version>							版本
					<packaging>jar</packaging>						包装
					<properties>									属性
						...
					</properties>
					<dependencies>									依赖性
						<dependency>								从属性
							<groupId>commons-logging</groupId>		项目包名
							<artifactId>commons-logging</artifactId>项目名称
							<version>1.2</version>					版本
						</dependency>
					</dependencies>
				</project>
			groupId类似java包名，常用公司或组织名。
			artifactId类似java类名常用项目名。
			Maven项目工程由groupId，artifactId和version作为唯一标识，引用其他第三方库，也是通过3个变量确定。
			如依赖commons-logging：
				<dependency>
					<groupId>commons-logging</groupId>
					<artifactId>commons-logging</artifactId>
					<version>1.2</version>
				</dependency>
				使用dependency声明一个依赖后，Maven会自动下载依赖包并放入classpath中。
			
		安装Maven：
			官方网址：https://maven.apache.org/
			可下载罪行的Maven3.6x本地解压设置环境变量：
				M2_HOME=/path/to/maven-3.6.x
				PATH=$PATH:$M2_HOME/bin
			Windows可将%M2_HOME%\bin添加到系统Path变量中。
			而后打开命令行窗口，输入mvn -version，即可看见maven的版本信息。
			类似：
				│Microsoft Windows [Version 10.0.0]                      │
				│(c) 2015 Microsoft Corporation. All rights reserved.    │
				│                                                        │
				│C:\> mvn -version                                       │
				│Apache Maven 3.6.0 (97c98ec64a1fdfee7767ce5ffb20918...) │
				│Maven home: C:\Users\liaoxuefeng\maven                  │
				│Java version: ...                                       │
				│...                                                     │
				│C:\> _   
			如果提示命令未找到那么系统PATH路径有误，需修复后运行。
			
		结：
			Maven是一个Java项目的管理和构建工具：

			Maven使用pom.xml定义项目内容，并使用预设的目录结构；
			在Maven中声明一个依赖项可以自动下载并导入classpath；
			Maven使用groupId，artifactId和version唯一定位一个依赖。
			
			
			
	依赖管理：
		依赖管理是项目依赖第三方的包，第三方的包通过搜索引擎到官网进行下载再放入classpath但是过程繁琐。
		Maven解决了依赖管理问题：
			项目依赖abc的包，而abc又依赖xyz：
				┌──────────────┐
				│Sample Project│
				└──────────────┘
						│
						▼
				┌──────────────┐
				│     abc      │
				└──────────────┘
						│
						▼
				┌──────────────┐
				│     xyz      │
				└──────────────┘
			当声明abc依赖时，Maven自动将abc和xyz加入项目依赖，不需要自己去研究abc是否需要依赖xyz。
			
			因此只要项目声明需要包，Maven就会自动导入这个包，再判断这个包需要子包，又会导入其子包以此类推。
				
			当声明以下spring-boot-starter-web依赖时	，Maven自动判断解析最终需要二三十个其他依赖：
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-web</artifactId>
				<version>1.4.2.RELEASE</version>
				
			
		依赖关系：
			Maven依赖关系分别为compile、test、runtime和provided：
				scope		说明											示例
				compile		编译时需要用到该jar包（默认）					commons-logging
				test		编译Test时需要用到该jar包						junit
				runtime		编译时不需要，但运行时需要用到					mysql
				provided	编译时需要用到，但运行时由JDK或某个服务器提供	servlet-api
				
				其中的compile最常见，Maven将这类型依赖直接放入classpath。
				
			test仅在测试时用到，正常运行不需要，常用的test依赖就是JUnit：
				<dependency>
					<groupId>org.junit.jupiter</groupId>
					<artifactId>junit-jupiter-api</artifactId>
					<version>5.3.2</version>
					<scope>test</scope>
				</dependency>
			
			runtime编译时也不需要，但运行时需要。runtime典型的依赖时JDBC驱动，如MySQL驱动：
				<dependency>
					<groupId>mysql</groupId>
					<artifactId>mysql-connector-java</artifactId>
					<version>5.1.48</version>
					<scope>runtime</scope>
				</dependency>
			
			provided编译时需要但运行时不需要，其典型的依赖时ServletAPI，编译时需要但运行时Servlet服务器内置了相关jar，所以运行不需要。
				<dependency>
					<groupId>javax.servlet</groupId>
					<artifactId>javax.servlet-api</artifactId>
					<version>4.0.0</version>
					<scope>provided</scope>
				</dependency>
			
			Maven维护的一个中央仓库中(repo1.maven.org)，所有第三方库将自身的jar以及相关信息上传至中央仓库，
			Maven就能从中央仓库将所需依赖下载到本地。
			
			Maven并不会每次从中央仓库下载，jar一旦被下载过就会缓存在本地目录(用户主目录的.m2目录下)，除了第一次下载外，后续因为有
			本地缓存所以不会重复下载相同的jar包。
			
		唯一ID：
			对于某个依赖，Maven只要通过以下3个变量即可唯一确定某个jar包：
				groupId：	属于组织的名称，类似Java的包名；
				artifactId：该jar包自身的名称，类似Java的类名；
				version：	该jar包的版本。
			
			Maven通过对jar进行PGP签名确保任何一个jar包一经发布就无法修改。修改已发布jar唯一方法就是发布一个新版本。
			因此，某个jar包一旦被Maven下载过，即可永久地安全缓存在本地。
			
			只有-SNAPSHOT结尾地版本号会被Maven视为开发版本，开发版每次都会重新下载，这种SNAPSHOT版本呢只能用于内部私有的Maven repo，
			公开发布的版本不允许出现SNAPSHOT。
		
		Maven镜像：
			可从Maven的中央仓库下载外，也可从Maven的镜像仓库下载，如果访问Maven中央仓库非常慢，可选择速度较快的镜像仓库。
			Maven镜像仓库定期从中央仓库同步。
			           slow    ┌───────────────────┐
				┌─────────────>│Maven Central Repo.│
				│              └───────────────────┘
				│                        │
				│                        │sync
				│                        ▼
			┌───────┐  fast    ┌───────────────────┐
			│ User  │─────────>│Maven Mirror Repo. │
			└───────┘          └───────────────────┘
			中国区可使用阿里云提供的Maven镜像仓库。使用Maven镜像仓库需要配置，用户主目录下进入.m2目录，创建一个sttings.xml配置文件：
				<settings>
					<mirrors>
						<mirror>
							<id>aliyun</id>
							<name>aliyun</name>
							<mirrorOf>central</mirrorOf>
							<!-- 国内推荐阿里云的Maven镜像 -->
							<url>http://maven.aliyun.com/nexus/content/groups/public/</url>
						</mirror>
					</mirrors>
				</settings>
				配置镜像仓库后，Maven的下载速度就会非常快。
		
		搜索第三方组件：
			需要引用第三方组件获取其的groupId、artifactId、version的话需通过search.maven.org搜索关键字，找到对应组件后，直接复制：
				<dependency>
					<groupId>com.squareup.okhttp3</groupId>
					<artifactId>okhttp</artifactId>
					<version>4.2.2</version>
				</dependency>
		
		命令行编译：
			在命令中，进入pom.xml所在目录，输入以下命令：
				$ mvn clean package
				如果过顺利即可在target目录下获得编译后自动打包的jar。
		
		在IDE中使用Maven：
			基本所有IDE(集成开发环境，程序开发环境的软件)
			
		结：
			Maven通过解析依赖关系确定项目所需的jar包，常用的4种scope有：compile（默认），test，runtime和provided；

			Maven从中央仓库下载所需的jar包并缓存在本地；

			可以通过镜像仓库加速下载。	
			
	
	
	构建流程：
		validate：验证。
		compile：编译源码。
		test-compile：测试源码。
		package：打包。
		Lifecycle：生命周期。
		Phase：阶段。
		Goal：目标。
		
		Maven除了有标准化的项目结构，还有标准化的构建流程，可自动化实现编译，打包、发布等。
		
		
		构建流程是对项目进项打包的过程：
			验证(validate) > 编译源码(compile) > 编译测试源码(test-compile) > 单元测试(test) > 打包(package)
			这个过程就是lifecycle(生命周期)，生命周期中有很多阶段(phase)，阶段通过既定顺序完成一个项目的构建。
			
			
			
		Lifecycle和Phase(生命周期、阶段)：
			Maven的声明周期时一系列阶段构成(Phase)，以内置的生命周期default为例，其包含以下phase：
				validate				process-classes				test					install
				initialize				generate-test-sources		prepare-package			deploy
				generate-sources		process-test-sources		package
				process-sources			generate-test-resources		pre-integration-test
				generate-resources		process-test-resources		integration-test
				process-resources		test-compile				post-integration-test
				compile					process-test-classes		verify
		
			如果运行mvn package，Maven就会执行default生命周期，从开始一直到package的phase为止：
				validate —— package
			运行mvn compile，也会执行default生命周期，只会运行到compile：
				validate —— compile
			Maven另一个常用生命周期时clean，会执行3个phase：
				pre-clean	clean(此处clean是phase)		post—clean
			所以使用mvn命令时，后参数是phase，Maven自动根据生命周期运行到指定的phase。
			
			更复杂的是指定多个phase，运行mvn clean parckage，Maven先执行clean生命周期并运行到clean这个phase，后执行default
			生命周期并运行到package的phase，实际执行的phase如下：
				pre-clean	clean	validate ……	package
			
			实际开发中，常用命令：
				mvn clean：清理所有生成的class和jar。
				mvn clean compile：先清理在执行到compile。
				mvn clean test：先清理在执行到test，因为执行test前必须执行compile，所以此处不必指定compile。
				mvn clean package：先清理，在执行到package。
				大多phase(阶段)在执行过程中因为通常没有在pom.xml中配置相关设置，所以phase什么都做不了。
			
			常用的phase只有：
				clean：清理。
				compile：编译。
				test：运行测试。
				package：打包。
				
		Goal(目标)：
			执行一个phase(阶段)会触发一个或多个goal：
				执行的Phase		对应执行的Goal
				compile			compiler:compile
				test			compiler:testCompile
								surefire:test
			goal命名总是abc:xyz形式。
			
		lifacycle、phase、goal对比：
		(声明周期) (阶段) (目标)
			lifacycle相当于java的package，包含一个或多个phase。
			phase相当于java的class，包含一个或多个goal。
			goal相当于class的method，它才是真正干活的。
			
			大多情况下只要指定phase，就默认执行phase绑定的goal，少数情况直接指定运行一个goal，如启动tomcat服务器：
				mvn tomcat:run
				
		以下对生命周期和对应阶段进行介绍：
			Clean Lifecycle：真正的构建前进行清理工作
							 pre-clean：执行需要在clean之前完成的工作。
							 clean：移除所有上一次构建生成的文件。
							 post-clean：执行一些需要在clean之后立刻完成的工作。
			Site Lifecycle：生成项目报告，站点，发布站点
							pre-site：执行需要在生成站点前完成的任务。
							site：生成项目的站点文档。
							post-site：执行需要在生成站点文档之后的工作，为部署做准备。
							site-deploy：将生成的站点文档部署到特定的服务器上。
			default Lifecycle：这是最重要的构建核心部分、编译、测试、打包、部署等等，在上面已经提到过，这里只提部分：
							validate：检验工程是否正确，所需信息是否完整。
							initialize：初始化构建平台，如设置properties或创建目录。
							process-resources：复制并处理资源文件，至目标目录，准备打包。
							compile：编译源代码。
							process-classes：源代码编译后期处理，如java字节码增强or优化。
							test-compile：编译测试源代码(默认test目录下)
							test：执行单元测试。
							package：将工程文件打包为指定格式，JAR or WAR等等。
							integration-test：集成测试。
							verify：检查package是否有效、符合标准。
							install：将包安装至本地仓库，使其项目依赖。
							deploy：将最终包符指到远程仓库，使其它开发人员与项目共享。
								
		
		结：
			Maven通过lifecycle、phase和goal来提供标准的构建流程。

			最常用的构建命令是指定phase，然后让Maven执行到指定的phase：
				mvn clean
				mvn clean compile
				mvn clean test
				mvn clean package
			通常情况，我们总是执行phase默认绑定的goal，因此不必指定goal。

	
	
	使用插件：
		plugin：插件。
		phase：阶段。
		goal：目标。
		transformer：转换器。
		
		使用Maven构建项目的目的就是执行lifecycle，执行到指定的phase位置，每个phase都会执行自身默认一或多个goal(目标),goal是最小任务单位。
		compile的Phase(阶段)：mvn phase
		此phase会调用compiler插件执行关联的compiler：compile的goal(目标)。
		执行每个phase都是通过某个插件(plugin)执行，Maven本身不知道如何执行compile，只负责找对应的compile插件，然后执行默认的
		compiler：compile的goal完成编译。
		
		总而言之使用Maven，就是配置好需使用的插件，通过phase(阶段)调用它们。
		
		Maven内置的常用标准插件：
			插件名称	对应执行的phase
			clean		clean
			compiler	compile
			surefire	test
			jar			package
			
			当插件无法满足可使用自定义插件，自定义插件需要声明，如maven-shade-plugin可创建一个可执行的jar，
			使用时选哟在pom.xml中进行声明：
				<project>
					...
					<build>
						<plugins>
							<plugin>
								<groupId>org.apache.maven.plugins</groupId>
								<artifactId>maven-shade-plugin</artifactId>
								<version>3.2.1</version>
								<executions>
									<execution>
										<phase>package</phase>
										<goals>
											<goal>shade</goal>
										</goals>
										<configuration>
											...
										</configuration>
									</execution>
								</executions>
							</plugin>
						</plugins>
					</build>
				</project>
			自定义插件一般需要一些配置如，maven-shade-plugin需指定java程序入口，配置是：
				<configuration>
					<transformers>
						<transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
							<mainClass>com.itranswarp.learnjava.Main</mainClass>
						</transformer>
					</transformers>
				</configuration>
			需注意Maven自带的标准插件，如compiler是无需声明的，只有引入其他插件才需声明。
		
		以下为常用插件：
			maven-shade-plugin：	打包所有依赖包并生成可执行jar；
			cobertura-maven-plugin：生成单元测试覆盖率报告；
			findbugs-maven-plugin：	对Java源码进行静态分析以找出潜在问题。
		
		结：
			Maven通过自定义插件可以执行项目构建时需要的额外功能，使用自定义插件必须在pom.xml中声明插件及配置；

			插件会在某个phase被执行时执行；

			插件的配置和用法需参考插件的官方文档。


			
	模块管理：
		parent：根源。
		dependencies：依赖性。
		dependency：依赖。
		
		
		模块管理就是将一个大项目拆分成多个模块降低软件复杂度的有效方法：
			                        ┌ ─ ─ ─ ─ ─ ─ ┐
									  ┌─────────┐
									│ │Module A │ │
									  └─────────┘
			┌──────────────┐ split  │ ┌─────────┐ │
			│Single Project│───────>  │Module B │
			└──────────────┘        │ └─────────┘ │
									  ┌─────────┐
									│ │Module C │ │
									  └─────────┘
									└ ─ ─ ─ ─ ─ ─ ┘
			就Maven来说原来的大项目：
				single-project
				├── pom.xml
				└── src
			将其拆分为3个小模块：
				mutiple-project
				├── module-a
				│   ├── pom.xml
				│   └── src
				├── module-b
				│   ├── pom.xml
				│   └── src
				└── module-c
					├── pom.xml
					└── src
			
			每个模块当作是独立的个体，都有各自独立的pom.xml文件，这些文件中有相同的重复的代码，可将重复代码提取出来作为parent文件。
			对于模块pom.xml文件的对比相关例子参考：https://www.liaoxuefeng.com/wiki/1252599548343744/1309301243117601
			
			parent本身不包含任何java代码，编写parent的pom.xml只是为各模块减少重复的配置，加上parent文件后的项目结构：
				multiple-project
				├── pom.xml
				├── parent
				│   └── pom.xml
				├── module-a
				│   ├── pom.xml
				│   └── src
				├── module-b
				│   ├── pom.xml
				│   └── src
				└── module-c
					├── pom.xml
					└── src
			
			模块A的pom简化：
				<project xmlns="http://maven.apache.org/POM/4.0.0"
					xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
					xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
					<modelVersion>4.0.0</modelVersion>

					<parent>
						<groupId>com.itranswarp.learnjava</groupId>
						<artifactId>parent</artifactId>
						<version>1.0</version>
						<relativePath>../parent/pom.xml</relativePath>
					</parent>

					<artifactId>module-a</artifactId>
					<packaging>jar</packaging>
					<name>module-a</name>
				</project>
				在parent标签中进行parent配置以继承，只要任何模块在pom进行配置都能继承parent文件。
				
				如果A依赖B，那么A就需要B的jar才能正常编译，需要在A中引入B：
					<dependencies>
						<dependency>
							<groupId>com.itranswarp.learnjava</groupId>
							<artifactId>module-b</artifactId>
							<version>1.0</version>
						</dependency>
					</dependencies>
							
				在编译的时候需在根目录创建一个pom.xml统一编译：
					<project xmlns="http://maven.apache.org/POM/4.0.0"
						xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
						xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

						<modelVersion>4.0.0</modelVersion>
						<groupId>com.itranswarp.learnjava</groupId>
						<artifactId>build</artifactId>
						<version>1.0</version>
						<packaging>pom</packaging>
						<name>build</name>

						<modules>		//以下是项目拆分的各个模块
							<module>parent</module>
							<module>module-a</module>
							<module>module-b</module>
							<module>module-c</module>
						</modules>
					</project>
					这样在根目录上执行mvn clean package时，Maven根据根目录的pom.xml找到包括parent在内的共4个<module>,一次性全部编译。
		
		中央仓库：
			使用的大多第三方模块都是此用法，如：
				使用commons logging、log4j这些第三方模块，就是第三方模块的开发者自己将编译好的jar包发布到Maven的中央仓库。
		
		私有仓库：
			是指公司内部如果不希望将源码和jar包放到公网上，那就可以搭建私有仓库。私有总是在内部使用，只要本地的~/.m2/settings.xml中配置好，
			使用方式和中央仓库没什么区别。
		
		本地仓库：
			将本地开发的项目发布在本地，其他项目可通过本地仓库引用它。但不推荐将自己的模块安装到Maven本地仓库，因为每次修改某个模块的源码，
			都需要重新安装，很容易出现版本不一致的情况。更好的方法使用模块化编译，编译时告诉Maven之间存在依赖关系，需要一块编译，Maven就会
			自动按依赖顺序编译这些模块。
			(本地仓库应该是每次修改模块后将项目一块进行编译避免版本不一致情况)
			
			
		结：
			Maven支持模块化管理，可以把一个大项目拆成几个模块：
			可以通过继承在parent的pom.xml统一定义重复配置；
			可以通过<modules>编译多个模块。	
			
			
			
	使用mvnw：
		
		什么是Mvnw：
			mvnw是Maven Wrapper缩写。安装Maven时默认系统所有项目会使用全局安装的Maven版本。
			某些项目必须使用某个特定版本Maven时，可使用MavenWrapper，它可负责给此特定项目安装指定版本Maven，其他项目不受影响。
			就是说Maven Wrapper给一个项目提供一个独立的。指定版本的Maven给它使用。
		
		安装Maven Wrapper：
			最简单的方式就是项目的根目录pom.xml所在目录，运行安装命令：
				mvn -N io.takari:maven:0.7.6:wrapper
			它会自动使用最新版本的Maven，0.7.6是MavenWrapper的版本。
		
			指定Maven的安装版本则使用：
				mvn -N io.takari:maven:0.7.6:wrapper -Dmaven=3.3.3
				
			安装后查看项目结构发现会多了mvnw、mvnw.cmd和.mvn目录，只需要将mvn命令改为mvnw就能使用和项目关联的Maven，如：
				mvnw clean package
				在Linux或mac下运行则需要加上./
				./mvnw clean package
		Maven Wrapper的另一个作用就是将项目的mvnw、mvnw.cmd和.mvn提交到版本库中，可使所有开发人员使用统一的Maven版本。

		结：
			使用Maven Wrapper可为项目指定特定的Maven版本。
			
			
			
	发布Artifact：
		Artifact：人为制造。
		Nexus：关系。
		
		此小节的代码示例过多代码统一参考以下链接：
			https://www.liaoxuefeng.com/wiki/1252599548343744/1347981037010977
		
		Artifact：人为制造。
		Artifact使Maven中一个概念，表示某个module如何打包，如war exploded，war，jar，ear等打包形式，
		module有Artifact的话就能部署到应用服务器中了。
		
		使用commons-logging第三方库的时候，通过Maven自动下载它的jar包，并通过pom.xml解析依赖，自动将相关依赖包下载后加入到classpath。
		
		如果在Maven的repo中放入一个开源库并分享，希望别人使用，别人只要按标准引用groupId:artifactId:version，即可自动下载jar包
		以及相关依赖。
		也就是说发布Artifact就是如何发布一个库到Maven的repo(再回收率)中的过程。
			
		以静态文件发布：
			中央仓库的Artifact的结构，如Commons Math它的groupId是org.apache.commons，artifactId是commons-math3，
			发布在中央仓库的文件夹路径就是https://repo1.maven.org/maven2/org/apache/commons/commons-math3/3.6.1/，
			此文件夹下，commons-math-。jar就是发布的jar包，
						commons-math-。pom就是它的pom.xml描述文件，
						commons-math--sources.jar是源代码，
						commons-math--javadoc.jar是文档。
			其他以.asc、.md5、sha1结尾的文件分别是GPG签名，MD5摘要和SHA-1摘要。
			只要通过这种目录结构组织文件，就一定是一个有效的Maven仓库。
			
			以开源项目how-to-become-rich为例，先创建Maven工程目录结构：
				how-to-become-rich
				├── maven-repo        <-- Maven本地文件仓库
				├── pom.xml           <-- 项目文件
				├── src
				│   ├── main
				│   │   ├── java      <-- 源码目录
				│   │   └── resources <-- 资源目录
				│   └── test
				│       ├── java      <-- 测试源码目录
				│       └── resources <-- 测试资源目录
				└── target            <-- 编译输出目录
			
				在po.xml中添加以下内容：
					<distributionManagement>
						<repository>
							<id>local-repo-release</id>
							<name>GitHub Release</name>
							<url>file://${project.basedir}/maven-repo</url>
						</repository>
					</distributionManagement>
							
			
					<build>
						<plugins>
							<plugin>											<plugin>
								<artifactId>maven-javadoc-plugin</artifactId>		<artifactId>maven-source-plugin</artifactId>
								<executions>										<executions>
									<execution>											<execution>
										<id>attach-javadocs</id>							<id>attach-sources</id>
										<phase>package</phase>								<phase>package</phase>
										<goals>												<goals>
											<goal>jar</goal										<goal>jar-no-fork</goal>
										</goals>											</goals>
									</execution>										</execution>
								</executions>										</executions>
							</plugin>											</plugin>
						</plugins>
					</build>
					注意<distributionManagement>，指示了发布的软件包的位置，这里的<url>是根目录下的maven-repo目录，
					在<build>中定义的两个插件maven-source-plugin和maven-javadoc-plugin分别用来创建源码和javadoc，如果不想发布源码，
					可将对应的插件去掉。
					
					直接在项目根目录下运行Maven命令mvn clean package deploy，如果一切顺利，就能在maven-repo目录下找到部署后的所有文件：
						maven-repo
						└── com
							└── itranswarp
								└── rich
									└── how-to-become-rich
										├── 1.0.0
										│   ├── how-to-become-rich-1.0.0-javadoc.jar
										│   ├── how-to-become-rich-1.0.0-javadoc.jar.md5
										│   ├── how-to-become-rich-1.0.0-javadoc.jar.sha1
										│   ├── how-to-become-rich-1.0.0-sources.jar
										│   ├── how-to-become-rich-1.0.0-sources.jar.md5
										│   ├── how-to-become-rich-1.0.0-sources.jar.sha1
										│   ├── how-to-become-rich-1.0.0.jar
										│   ├── how-to-become-rich-1.0.0.jar.md5
										│   ├── how-to-become-rich-1.0.0.jar.sha1
										│   ├── how-to-become-rich-1.0.0.pom
										│   ├── how-to-become-rich-1.0.0.pom.md5
										│   └── how-to-become-rich-1.0.0.pom.sha1
										├── maven-metadata.xml
										├── maven-metadata.xml.md5
										└── maven-metadata.xml.sha1
			
					最后将这个工程push(推送)到GitHub上，并选择Settings-GitHub Pages，选择master branch启用Pages服务，
					这样将全部内容推送至GitHub后，可作为静态网站访问Maven的repo，地址是：
						https://michaelliao.github.io/how-to-become-rich/maven-repo/
					版本1.0.0对应的jar地址是：
						https://michaelliao.github.io/how-to-become-rich/maven-repo/com/itranswarp/rich/how-to-become-rich
						/1.0.0/how-to-become-rich-1.0.0.jar
					现在如果有人想引用这个Maven包，告知以下依赖即可：
						<dependency>
							<groupId>com.itranswarp.rich</groupId>
							<artifactId>how-to-become-rich</artifactId>
							<version>1.0.0</version>
						</dependency>
								
					但除了正常导入依赖外，对方还需添加一个<repository>的声明，即使用方完整的pom.xml文件。
						
				在<repository>中，必须声明发布的Maven的repo地址，id和name可任意填写，url填入github pages提供的地址+/maven-repo/后缀。
				即可正常引用此库并编写代码如下：
					Millionaire millionaire = new Millionaire();
					System.out.println(millionaire.howToBecomeRich());
			
			使用commons-longging等三方库时，并不需要声明repo地址，因为都是发布到Maven中央仓库，就不需要告诉Maven仓库地址，
			因为它知道中央仓库的默认地址是https://repo1.maven.org/maven2/，也能通过~/.m2/settings.xml指定一个代理仓库地址以
			替代中央仓库以提高速度。
			因此GitHub Pages并不会将发布的Maven包同步到中央仓库，所以自然使用方必须手动添加一个提供的仓库地址。
			
			此外，通过GitHub pages发布Maven repo需要注意，不要改动已发布的版本。因为Maven的仓库不允许修改任何版本的，对一个库
			进行修改的唯一方法就是发布一个新版本。但通过静态文件的方式发布repo，实际上可修改jar文件，但遵循规则不要修改已发布版本。
			(Mavenrepo应该是回收Maven版本)
			
			
		通过Nexus(关系)发布到中央仓库：
			
			central.sonatype.org：中央仓库。
			
			我们可以将自己开源库发布到Maven中央仓库，这样用户就不需要声明repo地址，可直接引用，更显专业。
			但是不能直接发布到Maven中央仓库，而是通过曲线救国的方式发布到central.sonatype.org，它会定期自动同步到Maven的中央仓库。
			Nexus(关系)是支持Maven仓库的软件，由Sonatype开发，分为免费和专业版，多数大公司内部使用Nexus走位自己私有Maven仓库，而
			central.sonatype.org相当于面向开源的一个Nexus公共服务。
			
			所以第一步central.sonatype.org注册账号，链接地址步骤：
				1. 在Publish Your Project下方点击“Learn how »”
				2. 找到Provide project details，点击Provide
				3. 在Error页面点击“sign up”注册
			
			注册通过得到账号，通过https://central.sonatype.org/pages/apache-maven.html页面就能成功将自己Artifact(人为制造)发布到Nexus上，
			几小时后，Artifact就会出现在Maven的中央仓库。
			(在这里指的是将自己认为修改的版本发布到Nexus(关系)上了)
			
			发布的难点和重点：
				必须正确创建GPG签名，Linux和Mac下推荐使用gnupg2。
				必须在~/.m2/settings.xml中配置好登录用户名和口令，以及GPG口令。
				<server>
					<id>ossrh</id>
					<username>OSSRH-USERNAME</username>
					<password>OSSRH-PASSWORD</password>
				</server>
			
				在待发布的Artifact的pom.xml中添加OSS的Maven repo地址，以及maven-jar-plugin、maven-source-plugin、maven-gpg-plugin、
				nexus-staging-maven-plugin。(代码过长此处不予演示，请参考开头链接中代码)
				最后执行命令mvn clean package deploy 即可发布至central.sonatype.org(中央仓库)。
				此方法前期需要申请账号和项目流程，后期需安装调试GPG，但只要跑通流程，后续发布只要一行命令。
		
		发布到私有仓库：
			通过nexus-staging-maven-plugin除了可发布到central.sonatype.org(中央仓库)外，也可以发布到私有仓库，如公司内部搭建Nexus(关系)服务器。
			如果没有私有Nexus服务器，也可发布到GitHubPackages。GitHub Packages(GitHub包)是GitHub提供的仓库服务，支持Maven、NPM、Docker等。
			使用GitHub Packages时，无论发布Artifact，还是引用已发布的Artifact(人为制造)，都需要明确的授权Token，因此GitHub Packages只能作为
			私有仓库使用。
			
			Token：标记。
			repository：资源库、仓库、版本库。
			
			发布前先登录后在用户的Settings-Developer settings-Personal access tokens中创建两个Token(标记)，一个用于发布，一个用于使用。
			发布Artifact的Token必须有repo、write:packages和read:packages权限。
			
			使用Artifact的Token(标记)只需要read:packages权限。
			在发布端，将GitHub的用户名和发布Token写入~/.m2/settings.xml配置：
				<server>
					<id>github-release</id>
					<username>GITHUB-USERNAME</username>
					<password>f052...c21f</password>
				</server>
			然后在需发布的Artifact的pom.xml中，添加一个<repository>(版本库)声明：
				<distributionManagement>
					<repository>
						<id>github-release</id>
						<name>GitHub Release</name>
						<url>https://maven.pkg.github.com/michaelliao/complex</url>
					</repository>
				</distributionManagement>
			
			注意到<id>和~/.m2/settings.xml配置中的<id>保持一致，因为发布时Maven根据id找到用于登录的用户名和Token，才能上传文件到
			GitHub。直接通过命令mvn clean package deploy部署，成功后zaiGitHub用户页面可看见该Artifact。
			完整的配置可参考：https://github.com/michaelliao/complex/，这是非常简单的支持复数运算的库。
			
			使用Artifact时，因为GitHub的Package(包)只能作为私有仓库使用，所以除了使用方的pom.xml声明<repository>(版本库)外：
				<repositories>
					<repository>
						<id>github-release</id>
						<name>GitHub Release</name>
						<url>https://maven.pkg.github.com/michaelliao/complex</url>
					</repository>
				</repositories>
				<dependencies>
					<dependency>
						<groupId>com.itranswarp</groupId>
						<artifactId>complex</artifactId>
						<version>1.0.0</version>
					</dependency>
				</dependencies>
				还要将读写权限的Token配置到~/.m2/settings.xml文件中。
		
		结：
			使用Maven发布一个Artifact(修改版本)时：
				可以发布到本地，然后由静态服务器提供repo服务，使用方必须声明repo地址；
				可以发布到central.sonatype.org(中央仓库)，并自动同步到Maven中央仓库，需要前期申请账号以及本地配置；
				可以发布到GitHub Packages作为私有仓库使用，必须提供Token以及正确的权限才能发布和使用。
			
			


网络编程：
	是java最擅长方向之一，由虚拟机实现底层复杂的网络协议，只需要调用java标准库提供的接口，就可简单高效地编写网络程序。
	
	网络编程基础：
		internet：因特网。
		Network Interface：网络接口。
		
		
		计算机网络是两台或更多计算机组成的网络，同一网络中任意多台电脑可以直接通信，因为计算机之间遵循同一种网路协议。
		互联网是网络地网络(internet)，将很多计算机网络连接一起，形成全球统一的互联网。
		某个特定网络的计算机可能使用ABC网络协议，另一个使用XYZ。如果计算机网络通讯协议不统一，就无法将不同网络连接起来
		形成互联网。因此为将计算机网络接入互联网，就必须使用  TCP/IP 协议。
		
		IP地址：
			互联网中，一个IP地址用于唯一标识一个网络接口(Network Interface网络接口)。一台连入互联网计算机肯定有一个IP地址，
			也有可能拥有多个IP地址。
			
			IP地址分为 IPv4 和 IPv6 两种，IPv4采用32位地址，类似101.202.99.12，
										  IPv6采用128位地址，类似2001:0DA8:100A:0000:0000:1020:F2F3:1428。
			IPv4地址总有大约42亿，IPv6大概有340万亿亿亿亿，IPv4地址目前已经耗尽，但IPv6是用不完的。
			IP地址又分为公网IP地址和内网IP地址。
			公网IP地址可直接被访问，内网IP地址只能在内网访问。内网IP类似于：
				192.168.x.x
				10.x.x.x
			如果一台计算机只有一个网卡，并接入网络，那么它的本地地址127.0.0.1还有一个IP地址，如101.202.99.12，可通过此IP地址接入网络。
			如果有两个网卡，那么除了本机地址，还可有两个IP地址，分别接入两个网络。通常连接两个网络的设备是路由器或交换机，至少有两个IP地址，
			分别接入不同的网络，让网络间连接起来。
			如果两台计算机位于同一网络，它们之间可直接通信，因为IP地址前端是相同的，也就是网络号相同。网络号IP地址通过子网掩码过滤得到的
			例如：	
				IP是101.202.99.2，子网掩码255.255.255.0，那么计算机网络号是：
					IP = 101.202.99.2
					Mask = 255.255.255.0
					Network = IP & Mask = 101.202.99.0
			
			每台计算机都要正确的配置IP地址和子网掩码，根据这两个计算网络号，网络号相同则两个计算机处于相同网络下，可直接通信。
			如果两台计算机计算出网络号不同，那么则不能直接通信，之间必须通过路由器或交换机网络设备直接通信，这种设备称为网关。
			
			网关就是连接多个网络，负责将来自同一网络的数据包发到另一个网络，这个过程叫路由。
			所以一台计算机一个网卡会有3个关键设置：
				IPv4地址 IPv4子网掩码 IPv4默认网关
				IP地址，例如：10.0.2.15
				子网掩码，例如：255.255.255.0
				网关的IP地址，例如：10.0.2.2
			
		域名：
			直接记忆IP地址十分困难，所以通常使用域名访问某个特定的服务。域名解析服务器DNS负责将域名翻译成对应的IP，
			客户端根据IP地址访问服务器。
			域名访问网站流程大概是：
				用户输入域名	>	域名解析器解析域名将其翻译成IP地址	>	通过IP地址访问到网站
			
			cmd窗口通过nslookup 域名 查看域名对应的IP地址(效果如下)：
				$ nslookup www.liaoxuefeng.com
				Server:  xxx.xxx.xxx.xxx
				Address: xxx.xxx.xxx.xxx#53

				Non-authoritative answer:
				Name:    www.liaoxuefeng.com
				Address: 47.98.33.223
			还有一个特殊的本机域名，localhost(本地)，对应IP总是本机地址127.0.0.1。
			
		网络模型：
			Open System Interconnect：公开 系统 互连。
		
			计算机网络从底层传输到高层软件设计十分复杂，需合理设计计算机网络模型，必须采用分层模型，每一层负责处理自己的操作。
			OSI(Open System Interconnect)网络模型是ISO组织定义的一个计算机互联的标准模型，目的是简化网络各层的操作，提供标准接口
			和维护，这只是一个定义。此模型从上到下依次是：
				应用层：提供应用程宇之间的通信。
				表示层：处理数据格式，加解密等等。
				会话层：负责建立和维护会话。
				传输层：负责提供端到端的可靠传输。
				网络层：负责根据目标地址选择路由来传输数据。
				链路层和物理层负责将数据进行分片并且真正通过物理网络传输，如，无线网，光纤等。
			
			互联网实际使用的TCP/IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型。		
				OSI		TCP/IP
				应用层	应用层
				表示层
				会话层
				传输层	传输层
				网络层	IP层
				链路层	网络接口层
				物理层
				
		常用协议：
			IP协议是一个分组交换，不保证可靠传输。而TCP协议是传输控制协议，它是面向连接的协议，支持可靠传输和双向通信。
			TCP协议建立在IP协议之上，就是说IP协议只负责发数据包、超时重传这些机制实现的。并且，TCP协议允许双向通信，
			即使通信双方可同时发送和接收数据。
			TCP协议是应用最广泛的协议，许多高级协议都建立在TCP协议上，如HTTP，SMTP等。
			UDP协议(User Datagram Prodocol)是一种数据报文协议，是无连接协议，不保证可靠传输。因为UDP协议在通信前不需要建立连接，
			因此它的传输效率比TCP高，而且UDP协议比TCP简单。
			选择UDP协议时，传输数据通常能容忍丢失，如，一些语音视频通信应用选择UDP协议。
		
		结：
			计算机网络的基本概念主要有：
				计算机网络：由两台或更多计算机组成的网络；
				互联网：连接网络的网络；
				IP地址：计算机的网络接口（通常是网卡）在网络中的唯一标识；
				网关：负责连接多个网络，并在多个网络之间转发数据的计算机，通常是路由器或交换机；
				网络协议：互联网使用TCP/IP协议，它泛指互联网协议簇；
				IP协议：一种分组交换传输协议；
				TCP协议：一种面向连接，可靠传输的协议；
				UDP协议：一种无连接，不可靠传输的协议。
				
			
			
	TCP编程：
		Application：应用。
		Socket：插座。
		Router：路由器。
		
		开发网络应用的时候，会遇到Socket(插座)概念，此概念是抽象的，一个应用程序通过一个Socket建立远程连接，而Socket内部通过
		Tcp/IP协议将数据传输到网络：
			┌───────────┐                                   ┌───────────┐
			│Application│                                   │Application│
			├───────────┤                                   ├───────────┤
			│  Socket   │                                   │  Socket   │
			├───────────┤                                   ├───────────┤
			│    TCP    │                                   │    TCP    │
			├───────────┤      ┌──────┐       ┌──────┐      ├───────────┤
			│    IP     │<────>│Router│<─────>│Router│<────>│    IP     │
			└───────────┘      └──────┘       └──────┘      └───────────┘
		Socket、TCP和部分IP功能都是由操作系统提供的，不同的编程语言只是提供了对操作系统调用的简单封装。
		如，java提供的几个Socket相关的类就封装了操作系统提供的接口。
		因为仅仅通过IP地址通信是不够的，所以需要Socket进行网络通信。同一台计算机同时间会运行多个网络应用程序，如浏览器、QQ
		、邮件客户端等等。当操作系统接收到一个数据包的时候，如果只有IP地址，是无法判断应发给哪个应用程序的，所以，操作系统
		抽象出Socket接口，每个应用程序需要各自对应不同的Socket，数据包才能根据Socket正确发到对应的应用程序的。
		
		一个Socket由IP地址和端口号(范围是0~65535)组成，可将Socket简单理解为IP地址加端口号。端口号总是由操作系统分配，它是0~65535
		之间的数字，其中小于1024的端口属于特权端口，需要管理员权限，大于1024的端口可由任意用户的应用程序打开。
			以下的Socket的前部分就是IP地址，末尾是端口号。
			 浏览器：101.202.99.2:1201
			 QQ：	 101.202.99.2:1304
			 邮箱：	 101.202.99.2:15000
			使用Socket进行网络编程时，本质上就是两个进程之间的通信。
			其中一个必须充当服务器端，它会主动监听某个指定客户端，
			另一个必须充当客户端，它必须主动连接服务器的IP地址和指定端口，如果连接成功，服务器端和客户端就成功建立了一个TCP连接，
			双方后续就可以随时发送和接收数据。
			也就是说Socket网络编程的时候会建立两个进程，一个是服务器端，一个客户端，
				服务器端的会主动监听某个指定的端口，
				客户端的主动连接服务器的IP地址和指定端口，连接成功后两端成功建立一个TCP连接，然后双方就能随时发送和接收数据。
			
			因此当Socket连接成功在服务器端和客户端之间建立后：
				服务器端，它的Socket是指定的IP地址和指定的端口号。
				客户端，它的Socket是它所在计算机的IP地址和一个由操作系统分配的随机端口号。
				两个端的Socket形式如：101.202.99.2:1201。
		
			
		服务器端：
			accept：接受、同意、承认。
		
			使用Socket编程，首先编写服务器端程序，Java标准库提供ServerSocket实现对指定IP和指定端口的监听。
			ServerSocket经典实现代码参考：https://www.liaoxuefeng.com/wiki/1252599548343744/1305207629676577
			
			服务器通过代码：ServerSocket ss = new ServerSocket(6666);
			在指定端口6666监听。此处没有指定IP地址，表示在计算机的所有网络接口上进行监听。
			如果ServerSocket监听成功，就使用一个无限循环处理客户端的连接：
				for (;;) {
					Socket sock = ss.accept();
					Thread t = new Handler(sock);
					t.start();}

				ss.accept表示每当有新的客户端连接，就会返回一个Socket实例，这个Socket实例就是和刚连接客户端进行通信的。
				由于客户端很多，要实现并发处理，就必须为每个新的Socket创建一个新线程来处理，这样主线程的作用就是接收
				新的连接，每当收到新连接后，就创建一个新线程进行处理。
				此处也可使用线程池处理客户端连接，能大大提升运行效率。
				如果没有客户端进来，accept方法会阻塞并一直等待。如果多个客户端同时连接进来，ServerSocket会将连接扔进队列里，
				然后一个一个处理。对于java程序而言，只要通过循环不断调用accept就可获取新的连接。
			
		客户端：
			客户端代码参考：https://www.liaoxuefeng.com/wiki/1252599548343744/1305207629676577
			客户端程序通过：Socket sock = new Socket("localhost", 6666);
				连接到服务器端，上述代码服务器地址是localhost，表示本机地址，端口是6666。如果连接成功，将返回Socket实例，用于后续通信。
		
		Socket流：
			flush：刷新。
			
			Socket创建成功后，无论服务器端还是客户端，都使用Socket实例进行网络通信。因为TCP是基于流的协议，因此，java标准库
			使用InputStream和OutPutStream封装Socket数据流，这样当使用Socket流，和普通IO流类似：
				// 用于读取网络数据:
				InputStream in = sock.getInputStream();
				// 用于写入网络数据:
				OutputStream out = sock.getOutputStream();
			
			写入网络数据时，要调用flush(刷新)方法。如果不调用的话可能发现，客户端和服务器都收不到数据，这并不是java库的设计问题，
			而是以流形式写入数据的时候，并不是一写入就立刻发送到网络，而是先写入内存缓冲区，知道缓冲区满了后，才会一次性真正发送
			到网络，这样设计的目的是为了提高传输效率。如果缓冲区数据少，而又想强制将数据发送到网络，就必须调用flush强制将缓冲区
			数据发送出去。
			
		结：
			使用Java进行TCP编程时，需要使用Socket模型：
				服务器端用ServerSocket监听指定端口；
				客户端使用Socket(InetAddress, port)连接服务器；
				服务器端用accept()接收连接并返回Socket；
				双方通过Socket打开InputStream/OutputStream读写数据；
				服务器端通常使用多线程同时处理多个客户端连接，利用线程池可大幅提升效率；
				flush()用于强制输出缓冲区到网络。	
						
			
			
	UDP编程：
		receive：接收。
		DatagramPacket：数据包。
		getOffset：获得偏移量。
		getLength：获得长度。
		send：发送。
		setData：设置数据。
		
		UDP比TCP简单很多，因为UDP没有创建连接，数据包也是一次收发一个，所以没有流的概念。
		在java中使用UDP编程，仍需要使用Socket，因为应用程序在使用UDP时必须指定网络接口(IP)和端口号。
		注意：UDP端口和TCP端口虽然都使用0~65535，但他们是两套独立的端口，即一个应用程序用TCP占用端口1234，
			  不影响另一个应用程序用UDP占用端口1234.
			  
		服务器端：
			
			服务器端使用UDP也需要监听指定的端口。java提供DatagramSocket(数据包通讯端)实现此功能。
				DatagramSocket ds = new DatagramSocket(6666); // 监听指定端口
				for (;;) { // 无限循环
					// 数据缓冲区:
					byte[] buffer = new byte[1024];
					DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
					ds.receive(packet); // 收取一个UDP数据包
					// 收取到的数据存储在buffer中，由packet.getOffset(), packet.getLength()指定起始位置和长度
					// 将其按UTF-8编码转换为String:
					String s = new String(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8);
					// 发送数据:
					byte[] data = "ACK".getBytes(StandardCharsets.UTF_8);
					packet.setData(data);
					ds.send(packet);
			服务器端首先使用如下语句在指定的端口监听UDP数据包：
				DatagramSocket ds = new DatagramSocket(6666);
			如果没有其他应用程序占据此端口，那么监听成功，旧使用一个无限循环处理收到的UDP数据包：
				for (;;) {
					...}
			要接收一个UDP数据包，需要准备一个byte[]缓冲区，并通过DatagramPacket(数据包)实现接收：
				byte[] buffer = new byte[1024];
				DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
				ds.receive(packet);
			如果收取一个String，那么通过DatagramPackect返回的packet.getLength()和packet.getLength()确定数据在缓冲区的起止位置：
				getOffset：获得偏移量。
				getLength：获得长度。
				String s = new String(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8);
			当服务器收到一个DatagramPacket后，通常立刻回复一个或多个UDP包，因为客户端地址在DatagramPacket中，每次收到的DatagramPacket
			可能是不同的客户端，如果不回复，客户端就收不到任何UDP包。发送UDP包也是通过DatagramPacket实现，发送代码：
				byte[] data = ...
				packet.setData(data);
				ds.send(packet);	//发送
		
		客户端：
			和服务器端相比，客户端使用UDP时，只要直接向服务器端发送UDP包，然后接收返回的UDP包：
				DatagramSocket ds = new DatagramSocket();		//数据包
				ds.setSoTimeout(1000);							//超时设置
				ds.connect(InetAddress.getByName("localhost"), 6666); // 连接指定服务器和端口
				// 发送:
				byte[] data = "Hello".getBytes();
				DatagramPacket packet = new DatagramPacket(data, data.length);	//设置数据长度
				ds.send(packet);	//发送数据
				// 接收:
				byte[] buffer = new byte[1024];
				packet = new DatagramPacket(buffer, buffer.length);
				ds.receive(packet);		//接收
				String resp = new String(packet.getData(), packet.getOffset(), packet.getLength());
				ds.disconnect();		//断开连接
			
			客户端打开一个DatagramSocket使用代码：
				DatagramSocket ds = new DatagramSocket();		//数据包通讯端
				ds.setSoTimeout(1000);		//设置超时时间
				ds.connect(InetAddress.getByName("localhost"), 6666);	//设置IP和端口号
			客户端创建DatagramSpcket实例时并不需要指定端口，而是由操作系统自动指定一个当前未使用的端口。紧接着，调用setSoTineout(1000)
			设定超时1秒，意思是后续接收UDP包时，等待时间最多不会超过1秒，否则在没有UDP包时，客户端会无限期等待下去，这一点
			和服务器不一样，服务器端可无限等待，因为它本来就被设计成长时间运行。
			
			客户端的DatagramSocket还调用一个connect()方法连接到指定的服务器端。因为UDP是无连接的协议，这里的connect方法是为了在
			客户端的DatagramSocket实例中保存服务器端的IP和端口号，确保这个DatagramSocket实例只能往指定的地址和端口发送UDP包，
			不能往其他地址和端口发送。这么做不是UDP的限制，而是java内置了安全检查。
			
			如果客户端希望向两个不同服务器发送UDP包，那么必须创建两个DatagramSokcet实例。
			后续的手法数据和服务器端是一致的。通常说，客户端必须先发UDP包，因为客户端不发UDP包，服务器端就根本不知道客户端的地址和端口号。
			如果客户端认为通信结束，就可调用disconnect断开连接：ds.disconnect()；
			当然，disconnect并不是真正断开连接，只是清除了客户端DatagramSocket实例记录远程服务器地址和端口号，这样，
			DatagramSocket实例就可连接另一个服务器端。
			
		结：
			使用UDP协议通信时，服务器和客户端双方无需建立连接：
				服务器端用DatagramSocket(port)监听端口；
				客户端使用DatagramSocket.connect()指定远程地址和端口；
				双方通过receive()和send()读写数据；
				DatagramSocket没有IO流接口，数据被直接写入byte[]缓冲区。	
			
			
	发送Email(邮箱)：
		发送邮件最重要的：
			password登录口令是qq或163或其他邮箱软件开启STMP服务的一个口令
		Email电子邮件。邮件软件比如Outlook都是用来收发邮件的
		使用java也能收发电子邮件。
		传统邮件是通过邮局投递，然后从邮局到另一个邮局，最终到达用户邮箱：
			           ┌──────────┐    ┌──────────┐
					   │PostOffice│    │PostOffice│     .───.
			┌─────┐    ├──────────┤    ├──────────┤    (   ( )
			│═══ ░│───>│ ┌─┐ ┌┐┌┐ │───>│ ┌─┐ ┌┐┌┐ │───> `─┬─'
			└─────┘    │ │░│ └┘└┘ │    │ │░│ └┘└┘ │       │
					   └─┴─┴──────┘    └─┴─┴──────┘       │
		电子邮件发送过程类似，只是电子邮件是从用户电脑的邮件，如Outlook发送到服务器上，可能经过若干个邮件服务器上，
		收件方就可以用软件接收邮件：
			             ┌─────────┐    ┌─────────┐    ┌─────────┐
						 │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│
			┌───────┐    ├─────────┤    ├─────────┤    ├─────────┤    ┌───────┐
			│░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░│
			├───────┤    ├─────────┤    ├─────────┤    ├─────────┤    ├───────┤
			│       │───>│O ░░░░░░░│───>│O ░░░░░░░│───>│O ░░░░░░░│<───│       │
			└───────┘    └─────────┘    └─────────┘    └─────────┘    └───────┘
			   MUA           MTA            MTA            MDA           MUA
			
			MUAmta：Mail User Agent、邮件用户代理
			MTA：MTA Queue、 邮件传输代理队列
			MDA：Model Driven Architecture、模型驱动架构
			用户发出	>	服务器	>服务器		>	用户接收
			
			类似Outlook这样的邮箱软件称为UMA：Mail User Agent，意思是给用户服务的邮件代理。
			邮件服务器称为MTA：Mail Transfer Agent，意思是邮件中转的代理。
			最终到达的邮件服务器称为MDA：Mail Delivery Agent，意思是邮件到达的代理。
			电子邮件到达MDA就不再动了。实际上Email通常存储在MDA服务器硬盘上，等收件人通过软件或登录浏览器查看邮件。
			
			MTA和MDA服务器软件通常是现成的，不用关心服务器内部如何运行。要发送邮件，关心的是如何编写一个MUA软件，将邮件发送到MTA上。
			MUA到MTA发送邮件的协议就是SMTP协议，它是Simple Mail Transport Protocol的错写，使用标准端口25，也可使用加密端口465或587。
			SMTP协议是建立在TCP之上的协议，任何程序发送邮件都必须遵守SMTP协议。使用java程序发送邮件时，无需关心SMTP协议的底层原理，
			只要使用JavaMail这个标准API就能直接发送邮件。
	
		准备SMTP登录信息：
			SMTP就是邮件MUA到MTA的协议(MUA用户邮件代理发送到MTA邮件中转)
			使用自己的邮件地址me@example.com给他人发邮件，已知他人邮件是xiaoming@somewhere.com，发送邮件前，首先确定作为MTA邮件服务器
			地址和端口号。邮服务器地址通常是smtp.example.com，端口号由邮件服务器商确定使用25标准端口还是465、587加密端口。
			
			以下是一些常用邮件服务商SMTP信息：
				QQ邮箱：SMTP服务器是smtp.qq.com，端口是465/587；
				163邮箱：SMTP服务器是smtp.163.com，端口是465；
				Gmail邮箱：SMTP服务器是smtp.gmail.com，端口是465/587。
			有了SMTP服务器的域名和端口号，还需要SMTP服务器的登录信息，通常使用自己的邮件地址作为用户名，登录口令是用户口令或
			一个独立设置的SMTP口令。
			
			如果JavaMail发送邮件的话：
				首先创建一个Maven工程，并将JavaMail县官的两个依赖加入：
					分别是：javax.mail-api、javax.mail
					<dependencies>
						<dependency>
							<groupId>javax.mail</groupId>
							<artifactId>javax.mail-api</artifactId>
							<version>1.6.2</version>
						</dependency>
						<dependency>
							<groupId>com.sun.mail</groupId>
							<artifactId>javax.mail</artifactId>
							<version>1.6.2</version>
						</dependency>
				然后通过JavaMailAPI廉价到SMTP服务器上：
					SMTP就是邮件MUA到MTA的协议(MUA用户邮件代理发送到MTA邮件中转)				
					String smtp = "smtp.office365.com";		// 服务器地址:				
					String username = "jxsmtp101@outlook.com";	// 登录用户名:					
					String password = "********";		// 登录口令:登录口令需要去相应邮箱软件开启STMP服务					
					Properties props = new Properties();	// 连接到SMTP服务器587端口:
					props.put("mail.smtp.host", smtp); 		// SMTP主机名
					props.put("mail.smtp.port", "587"); 	// 主机端口号
					props.put("mail.smtp.auth", "true"); 	// 是否需要用户认证
					props.put("mail.smtp.starttls.enable", "true"); // 启用TLS加密
					Session session = Session.getInstance(props, new Authenticator() {	// 获取Session实例:
						protected PasswordAuthentication getPasswordAuthentication() {
							return new PasswordAuthentication(username, password);
						}
					});
					session.setDebug(true);		// 设置debug模式便于调试:
					
					Session：会话。
					Properties：属性。
					Authenticator：认证器。
					以587端口为例，链接SMTP服务器时，需准备一个Properties对象，填入相关信息。最后获取Session
					实例时，如果服务器需要认证，还要传入一个Authenticator对象，并返回指定的用户名和口令。
					当获取到Session实例后，打开调试模式可看到SMTP通信的详细内容，便于调试。
			
		发送邮件：
			Message：通知、消息。
			Transport：运输，这个对象就是运输消息的意思，再调用send发送消息。
			InternetAddress：互联网地址，给定一个邮件发送人的地址，即邮箱。
			setRecipient：容器、接收者，set就是设置接收方地址邮箱。
			RecipientType：接收者类型。
			Subject：主题。
			text：文本。
			
			发送邮件先要构建一个Message对象，再调用Transport.send(Message)即可完成发送：
				MimeMessage message = new MimeMessage(session);			
				message.setFrom(new InternetAddress("me@example.com"));	// 设置发送方地址:
				// 设置接收方地址:
				message.setRecipient(Message.RecipientType.TO, new InternetAddress("xiaoming@somewhere.com"));				
				message.setSubject("Hello", "UTF-8");	// 设置邮件主题:邮件内容以及编码格式		
				message.setText("Hi Xiaoming...", "UTF-8");	// 设置邮件正文:				
				Transport.send(message);	// 发送:
			大多数邮件服务器要求发送地址和登录用户名必须一致，否则发送将失败。
			填入真是地址，运行上述代码，可以再控制台看到JavaMail打印的调试信息，调试信息参考：
				https://www.liaoxuefeng.com/wiki/1252599548343744/1319099923693601
				根据其中的代码调试信息看出，SMTP协议是一个请求-响应协议，客户端总是发送命令，然后等待服务器响应。
				服务器响应总是以数字开头，后面信息才是用于调试的文本。这些响应码已经被定义在SMTP协议中了，只要具体查看
				响应码就能知道出错原因。
			一切春丽则对方收到一封文本格式的电子邮件。
			
		发送HTML邮件：
			发送HTML和文本邮件类似，只要将：
				message.setText(body, "UTF-8");改为message.setText(body, "UTF-8", "html");
				也就是后面加上邮件格式。
				传入的body是类似<h1>Hello</h1><p>Hi, xxx</p>这样的HTML字符串即可。
				HTML邮件可在邮件客户端直接显示为网页格式。
		发送附件：
			Multipart：多部件、复合。
			BodyPart：主体部分、部位。
			Handler：处理器。
			datahandler：数据处理器。
			ByteArrayDataSource；字节阵列数据源。
			content：内容。
			plain：普通的。
			application：应用软件。
			octet：8位字节。
			stream：流。
			Header：标题。
			
			再电子邮件中携带附件，不能直接调用message.setText()方法，而要构建一个Multipart对象：
				Multipart multipart = new MimeMultipart();	
				// 添加text:
				BodyPart textpart = new MimeBodyPart();		
				textpart.setContent(body, "text/html;charset=utf-8");
				multipart.addBodyPart(textpart);
				// 添加image:
				BodyPart imagepart = new MimeBodyPart();
				imagepart.setFileName(fileName);	//文件名
				imagepart.setDataHandler(new DataHandler(new ByteArrayDataSource(input, "application/octet-stream")));
				multipart.addBodyPart(imagepart);
				// 设置邮件内容为multipart:
				message.setContent(multipart);
				
				一个Multipart对象可添加多个BodyPart，其中第一个BodyPart是文本(邮件正文)，后面的BodyPart是附件。
				BodyPart依靠setContent()决定添加的内容，如果添加文本，用setContent("..","text/plain;charset=utf-8")添加纯文本，
				或是setContent("","text/html;charset=utf-8")添加HTML文本。如果添加附件，需要设置文件名(不一定和real file name相同)
				并且添加一个DataHandler(数据处理器)，传入文件的MIME类型。二进制文件可用application/octet-stream，
				Word文档则是application/msword。
				最后通过setContent将Multipart添加到Message中，即可发送。
				
		发送内嵌图片的HTML邮件：
			类似<img src="http://example.com/test.jpg">的外部图片链接通常被邮件客户端过滤，并提示显示图片不安全。
			只有内嵌的图片才能正常在邮件中显示。
			内嵌图片也是附件，邮件本身也是Multipart，但要做些额外处理。
				Multipart multipart = new MimeMultipart();
				// 添加text:
				BodyPart textpart = new MimeBodyPart();		正文部分、部件
				content内容：内容格式html
				textpart.setContent("<h1>Hello</h1><p><img src=\"cid:img01\"></p>", "text/html;charset=utf-8");
				多部件，添加bodypart正文部分
				multipart.addBodyPart(textpart);
				// 添加image:
				BodyPart imagepart = new MimeBodyPart();	创建正文对象
				imagepart.setFileName(fileName);	设置文件名
				设置数据处理器
				ByteArrayDataSource字节数组数据源
				imagepart.setDataHandler(new DataHandler(new ByteArrayDataSource(input, "image/jpeg")));	
				// 与HTML的<img src="cid:img01">关联:
				imagepart.setHeader("Content-ID", "<img01>");	设置处理器
				multipart.addBodyPart(imagepart);	添加正文部分
			在HTML邮件中引用图片时，需设定一个ID，用类似<img src=\"cid:img01\">引用后，再添加图片作为BodyPart(主体部分)时，
			除了正确设置MIME类型(根据图片类型使用)image/jpeg或image/png，还要设置一个Header(标题)：
				imagepart.setHeader("Content-ID", "<img01>");
			这个ID和HTML中引用的ID对应起来，邮件客户端就能正常显示内嵌图片。
		但如果用户名或口令错误，将会导致535登录失败。
			DEBUG SMTP: AUTH LOGIN failed
			Exception in thread "main" javax.mail.AuthenticationFailedException: 535 5.7.3 Authentication unsuccessful [HK0PR03CA0105.apcprd03.prod.outlook.com]
		登录用户和发件人不一致会导致554拒绝发送错误。	
			DEBUG SMTP: MessagingException while sending, THROW: 
			com.sun.mail.smtp.SMTPSendFailedException: 554 5.2.0 STOREDRV.Submission.Exception:SendAsDeniedException.MapiExceptionSendAsDenied;
		有些时候，如果邮件主题和正文过于简单，会导致554被识别为垃圾邮件的错误(垃圾邮件时最骚的)：
			DEBUG SMTP: MessagingException while sending, THROW: 
			com.sun.mail.smtp.SMTPSendFailedException: 554 DT:SPM
		结：
			使用JavaMail API发送邮件本质上是一个MUA软件通过SMTP协议发送邮件至MTA服务器；
			打开调试模式可以看到详细的SMTP交互信息；
			某些邮件服务商需要开启SMTP，并需要独立的SMTP登录密码。	
			用户登录口令是需要去邮箱软件设置中开启STMP服务给的口令。
			
	接收Email(电子邮箱)：
		客户端总是通过STMP协议将邮件发送给MTA(MTA 邮件服务器，发送者将邮箱发送到其中，MTA再将邮件发送到MDA服务器硬盘上，
												那么邮件就算到达了，接收方通过MDA邮件服务器查看邮件)。
		接收Email则相反，因为邮件最终到达收件人的MDA服务器，so，接收邮件是收件人用自己客户端将邮件从MDA服务器上抓取到
		本地的过程。
		接收邮件使用广泛的协议是POP3：Post Office Protocol version 3(邮政局协议版本)，它是建立在TCP连接之上的协议。POP3服务器标准端口是110，
		如果整个会话需要加密，则使用加密端口995.
		另一种接收邮件的协议是IMAP：Internet Mail Access Protocol(互联网邮件访问协议)，使用标准端口143和加密端口993。
		IMAP和POP3的主要区别是，IMAP协议在本地的所有操作都会自动同步到服务器上，并且IMAP可允许用户在邮件服务器的收件箱中创建文件夹。
		IMAP（互联网访问协议）
		JavaMail提供IMAP协议支持。因为POP3和IMAP使用方式非常类似，因此只介绍POP3的用法。
		
		Store：存储。
		使用POP3收取Email时，无需关系POP3协议底层，因为JavaMail提供高层接口。首先需要连接到Store对象：
			// 准备登录信息:
			String host = "pop3.example.com";
			int port = 995;
			String username = "bob@example.com";
			String password = "password";

			Properties props = new Properties();
			props.setProperty("mail.store.protocol", "pop3"); // 协议名称
			props.setProperty("mail.pop3.host", host);// POP3主机名
			props.setProperty("mail.pop3.port", String.valueOf(port)); // 端口号
			// 启动SSL:
			props.put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory");
			props.put("mail.smtp.socketFactory.port", String.valueOf(port));

			// 连接到Store:
			URLName url = new URLName("pop3", host, post, "", username, password);
			Session session = Session.getInstance(props, null);
			session.setDebug(true); // 显示调试信息
			Store store = new POP3SSLStore(session, url);
			store.connect();
		一个Store对象表示整个邮箱的存储，要收取邮件需通过Store访问指定的Folder(文件夹)，通常是INBOX表示收件箱。	
			// 获取收件箱:
			Folder folder = store.getFolder("INBOX");
			// 以读写方式打开:
			folder.open(Folder.READ_WRITE);
			// 打印邮件总数/新邮件数量/未读数量/已删除数量:
			System.out.println("Total messages: " + folder.getMessageCount());
			System.out.println("New messages: " + folder.getNewMessageCount());
			System.out.println("Unread messages: " + folder.getUnreadMessageCount());
			System.out.println("Deleted messages: " + folder.getDeletedMessageCount());
			// 获取每一封邮件:
			Message[] messages = folder.getMessages();
			for (Message message : messages) {
				// 打印每一封邮件:
				printMessage((MimeMessage) message);}
		Mime：多用途互联网邮件扩展MIME，Multipurpose Internet Mail Extensions。
		当获取到一个Message对象时，	可强制转型谓MimeMessage(Mime消息)，然后打印出邮件主题、发件人、收件人信息。
			void printMessage(MimeMessage msg) throws IOException, MessagingException {
				// 邮件主题:
				System.out.println("Subject: " + MimeUtility.decodeText(msg.getSubject()));
				// 发件人:
				Address[] froms = msg.getFrom();
				InternetAddress address = (InternetAddress) froms[0];
				String personal = address.getPersonal();
				String from = personal == null ? address.getAddress() : (MimeUtility.decodeText(personal) + " <" + address.getAddress() + ">");
				System.out.println("From: " + from);
				// 继续打印收件人:
				...}
		较为麻烦的时获取邮件正文。一个MimeMessage对象也是一个Part(部分)对象，可能只包含一个文本，也可能是一个Multipart对象，
		即由几个part构成，因此，需要递归解析出完整正文：
			String getBody(Part part) throws MessagingException, IOException {
				if (part.isMimeType("text/*")) {
					// Part是文本:
					return part.getContent().toString();
				}
				if (part.isMimeType("multipart/*")) {
					// Part是一个Multipart对象:
					Multipart multipart = (Multipart) part.getContent();
					// 循环解析每个子Part:
					for (int i = 0; i < multipart.getCount(); i++) {
						BodyPart bodyPart = multipart.getBodyPart(i);
						String body = getBody(bodyPart);
						if (!body.isEmpty()) {
							return body;}}}return "";
		最后关闭Folder(文件夹)和Store(仓库、存储)：
			folder.close(true); // 传入true表示删除操作会同步到服务器上（即删除服务器收件箱的邮件）
			store.close();
			
		结：
			使用Java接收Email时，可以用POP3协议或IMAP协议。

			使用POP3协议时，需要用Maven引入JavaMail依赖，并确定POP3服务器的域名／端口／是否使用SSL等，然后，调用相关API接收Email。

			设置debug模式可以查看通信详细内容，便于排查错误。	
			
			
			
	HTTP编程：
	
		Server：服务器。
		Browser：浏览器。
		Header：头部、标题。
		Body：身体、主要部分。
		
		其是使用最广泛的Web应用程序使用的基础协议，浏览器访问网站、手机app访问后台服务器皆是通过HTTP协议实现。
		HTTP是HyperText Transfer Protocol缩写，意为超文本传输协议，是基于TCP协议之上的一种请求-响应协议。
		浏览器访问网站发送的HTTP请求响应。当浏览器希望访问某个网站时，浏览器和网站之间先建立TCP连接，且服务器
		总是使用80端口和加密端口443，然后，浏览器像服务器发送HTTP请求，服务器收到后返回一个HTTP响应，并在响应中
		包含HTML的网页内容，然后通过浏览器的解析就能给用户显示网页。
		流程如下：
			
			1.浏览器和网站服务器先建立TCP连接，服务器端口使用80 or 加密的443。
			2.浏览器向服务器发送一个HTTP请求，服务器收到，返回一个HTTP响应，其中包含HTML网页内容。
			3.最后浏览器解析服务器的响应(HTML)就能显示网页
			            GET / HTTP/1.1
						Host: www.sina.com.cn
						User-Agent: Mozilla/5 MSIE
						Accept: */*                ┌────────┐
			┌─────────┐ Accept-Language: zh-CN,en  │░░░░░░░░│
			│O ░░░░░░░│───────────────────────────>├────────┤
			├─────────┤<───────────────────────────│░░░░░░░░│
			│         │ HTTP/1.1 200 OK            ├────────┤
			│         │ Content-Type: text/html    │░░░░░░░░│
			└─────────┘ Content-Length: 133251     └────────┘
			  Browser   <!DOCTYPE html>              Server
			  浏览器	<html><body>				 服务器
						<h1>Hello</h1>
						...
		HTTP请求格式是固定的，由HTTP Header和HTTP Body两部分组成，第一行总是请求方法 路径 HTTP版本，GET/HTTP/1.1
		表示使用GET请求，路径是/，版本是HTTP/1.1。
		后续每一行都是固定Header：value格式，称为HTTP Header，服务器依靠某些特定的Header识别客户端请求，如：
			Host(主机)：表示请求的域名，因为一台服务器上可能有多个网站，因此有必要依靠Host识别用于请求。
			User-Agent(用户-代理)：标识客户端自身标识信息，不同浏览器有不同标识，服务器依靠User-Agent判断客户端类型。
			Accept(接受、同意、承认)：标识客户端能处理的HTTP响应格式，*/*标识任意格式，text/*标识任意文本，
									  image/png标识PNG格式的图片。
			Accept-Language(接受-语言)：表示客户端接收的语言。多种语言按优先级排序，服务器依靠该字段给用户返回特定
										语言的网页版本。
		如果是GET请求，那么该HTTP请求只有HTTP Header，没有HTTP Body(只有标题没有正文部分)。
		如果是POST请求，那么HTTP请求带有Body，以一个空行分隔。一个典型的带Body的HTTP请求如下：
			POST /login HTTP/1.1
			Host: www.example.com
			Content-Type: application/x-www-form-urlencoded
			Content-Length: 30

			username=hello&password=123456
		POST请求通常要设置Content-Type(内容-类型)表示Body(正文)的类型，Content-Length表示Body的长度，这样服务器就能根据
		请求的Header和Body做出正确响应。
		此外，GET请求的参数必须是附加在URL上，并以URLEncode方式编码，
			例如：http://www.example.com/?a=1&b=K%26R，
			参数分别是a=1和b=K&R。
		因为URL长度限制，GET请求的参数不能太多，而POST请求的参数就没有长度限制，因为POST请求的参数必须放入Body(正文、身体)中
		并且，POST请求的参数不一定是URL编码，可按任意格式编码，只要在Content-Type中正确设置即可。常见的发送JSON的POST请求
		如下：
			POST /login HTTP/1.1
			Content-Type: application/json
			Content-Length: 38

			{"username":"bob","password":"123456"}
		HTTP响应也是由Header和Body两部分组成，典型HTTP响应如下：
			HTTP/1.1 200 OK
			Content-Type: text/html
			Content-Length: 133251

			<!DOCTYPE html>
			<html><body>
			<h1>Hello</h1>
			...
		响应第一行总是HTTP版本 响应代码 响应说明，
		如HTTP/1.1 200 OK
		表示版本是HTTP1.1、 响应说明是OK。客户端只依赖响应代码判断HTTP响应是否成功。HTTP有固定的响应代码。
			1xx：表示一个提示性响应，如101表示将切换协议，常见于WebSocket连接
			2xx：表示一个成功的响应，如200表示成功，206表示只发送部分内容。
			3xx：表示一个重定向的响应，如301表示永久重定向，303表示客户端应该按指定路径重新发送请求。
			4xx：表示因为客户端问题导致的错误响应，例如400是因为Content-Type等各种原因导致的无效请求，
				 404表示指定路径不存在。
			5xx：表示因为服务器问题导致的错误响应，如500表示服务器内部故障，503表示服务器暂时无法响应。
		浏览器收到第一个HTTP响应后，解析HTML后，又会发送一系列HTTP请求，如GET /logo.jpg HTTP/1.1请求一个图片，
		服务器响应图片请求后，会直接将二进制内容的图片发送给浏览器。
			HTTP/1.1 200 OK
			Content-Type: image/jpeg
			Content-Length: 18391

			????JFIFHH??XExifMM?i&??X?...(二进制的JPEG图片)
		所以服务器总是被动接收客户端一个HTTP请求，然后响应它。客户端则根据需要发送若干个HTTP请求。
		对于最早期的HTTP/1.0协议，每次发送一个HTTP请求，客户端都需要先创建一个新的TCP连接，然后，收到服务器响应后，
		关闭这个TCP连接。由于建立TCP连接费时，因此为提高效率，HTTP/1.1允许在一个TCP连接中反复发送-响应，这样大大
		提高效率。
		request：请求。
		response：响应。
			                       ┌─────────┐
			┌─────────┐            │░░░░░░░░░│
			│O ░░░░░░░│            ├─────────┤
			├─────────┤            │░░░░░░░░░│
			│         │            ├─────────┤
			│         │            │░░░░░░░░░│
			└─────────┘            └─────────┘
				 │      request 1       │
				 │─────────────────────>│
				 │      response 1      │
				 │<─────────────────────│
				 │      request 2       │
				 │─────────────────────>│
				 │      response 2      │
				 │<─────────────────────│
				 │      request 3       │
				 │─────────────────────>│
				 │      response 3      │
				 │<─────────────────────│
				 ▼                      ▼
		因为HTTP协议是一个 请求-响应 协议，客户端在发送一个HTTP请求后，必须等待服务器响应后，才能发送下一个请求，这样
		如果某个响应太慢，就会堵住后面的请求。
		为了提速，HTTP/2.0允许客户端在没收到响应的时候，发送多个HTTP请求，服务器返回响应的时候，不一定按顺序返回，
		只要双方能识别出哪个请求，就能做到并行发送和接收。
			                       ┌─────────┐
			┌─────────┐            │░░░░░░░░░│
			│O ░░░░░░░│            ├─────────┤
			├─────────┤            │░░░░░░░░░│
			│         │            ├─────────┤
			│         │            │░░░░░░░░░│
			└─────────┘            └─────────┘
				 │      request 1       │
				 │─────────────────────>│
				 │      request 2       │
				 │─────────────────────>│
				 │      response 1      │
				 │<─────────────────────│
				 │      request 3       │
				 │─────────────────────>│
				 │      response 3      │
				 │<─────────────────────│
				 │      response 2      │
				 │<─────────────────────│
				 ▼                      ▼
		HTTP编程：
			HTTP设计客户端和服务器端，于TCP类似，需要针对客户端和服务器端编程。
			服务器端本质是编写web服务器，是复杂的体系，也是JavaEE(企业)开发核心内容。
			浏览器也是一种HTTP客户端，so，客户端HTTP编程，行为本质和浏览器一样，即发送一个HTTP请求，接收服务器响应后，
			获得响应内容。只不过浏览器进一步将响应内容解析后渲染并展示给用户，我们使用Java进行HTTP客户端办成仅限于
			获得响应内容。
			Java标准库提供基于HTTP的包，但早期JDK版本通过HttpURLConnection访问HTTP，代码参考：
				https://www.liaoxuefeng.com/wiki/1252599548343744/1319099982413858
			早期版本需要手动处理InputStream(输入流)，所以使用很麻烦。
			从Java11开始，引入新的HTTPClient(客户端)，使用链式调用的API，能大大简化HTTP处理。
			新版HTTPClient，要先创建一个全局HTTPClient实例，因为HTTPClient内部使用线程池优化多个HTTP连接，
			并且可复用：	build：建立、建造。		builder：生成器。
				static HttpClient httpClient = HttpClient.newBuilder().build();
				使用GET请求获取文本内容代码参考：https://www.liaoxuefeng.com/wiki/1252599548343744/1319099982413858
			Response(响应)
			BodyHandlers(身体 处理器)
			ByteArray(字节数组)
			要获取图片这样的二进制内容，只要将，HttpResponse(http响应).BodyHandlers.ofString()换成
												HttpResponse.BodyHandlers.ofByteArray()就能获得
												HttpResponse<byte[]>对象。如果响应内容很大，不希望
												一次性全部加载到内存中就可使用，
												HttpResponse.BodyHandlers.ofInputStream()获取一个
												InputStream流。
			Content-type(内容-类型)
			使用Post请求，要准备好发送的body数据正确设置Content-Type，代码内容参考：
				https://www.liaoxuefeng.com/wiki/1252599548343744/1319099982413858
									
		结：
			Java提供了HttpClient作为新的HTTP客户端编程接口用于取代老的HttpURLConnection接口。
			HttpClient使用链式调用并通过内置的BodyPublishers和BodyHandlers来更方便地处理数据。	
			
	RMI远程调用：		
		RMI缩写（Radio Magnetic Indicator），无线电磁方位指示器，远程方法调用
		java的RMI是，JVM中代码可通过网络实现远程调用另一个JVM某个方法。
		提供服务以方称为服务器，实现远程调用一方称为客户端。
		
		最简单的RMI，服务器会提供WorldClock服务，允许客户端获取指定时区时间，允许客户端调用下面方法：
			//LocalDateTime本地日期时间
			LocalDateTime getLocalDateTime(String zoneId);
		实现RMI，服务器和客户端必须共享同一个接口。先定义一个WorkdClock接口：
			//Zone：地区
			public interface WorldClock extends Remote {
				LocalDateTime getLocalDateTime(String zoneId) throws RemoteException;}
		//Remote：远程。
		java的RMI规定此接口必须派生自java.rmi.Remote，并在每个方法声明抛出RemoteException。	
		再是编写服务器的实现类，因为客户端请求的调用方法getLocalDateTime()最终通过这个实现类返回结果，
		实现类WorldClockService代码如下：
			public class WorldClockService implements WorldClock {
				@Override
				public LocalDateTime getLocalDateTime(String zoneId) throws RemoteException {
					return LocalDateTime.now(ZoneId.of(zoneId)).withNano(0);}}	nano：纳米
		服务器端的服务相关代码编写完成。需通过JavaRMI提供一系列底层支持接口，将上面编写的服务以RMI形式暴露在网络上，
		客户端才能进行使用：(RMI远程方法调用)
			public class Server {
				public static void main(String[] args) throws RemoteException {
					//输出创建世界时钟远程服务
					System.out.println("create World clock remote service...");
					// 实例化一个WorldClock世界时钟，WorldClockService世界时钟服务:
					WorldClock worldClock = new WorldClockService();
					// 将此服务转换为远程服务接口:
					//UnicastRemoteObject单播远程对象、exportobject出口对象，将其强转为世界时钟并接收
					WorldClock skeleton = (WorldClock) UnicastRemoteObject.exportObject(worldClock, 0);
					// 将RMI服务注册到1099端口:1099就是RMI默认端口
					//LocateRegistry找到注册表
					//createRegistry创建注册表
					Registry registry = LocateRegistry.createRegistry(1099);
					// 注册此服务，服务名为"WorldClock":
					//注册一个WorldClock世界时钟的注册表
					//rebind重新绑定、skeleton骨架为接收单薄远程对象的WroldClock类型。
					registry.rebind("WorldClock", skeleton);
		以上目的主要通过RMI提供相关类，将自己的WorldClock实例注册到RMI服务器上。RMI默认端口1099，最后一步注册服务时
		通过rebind()指定服务器名称为WorldClock世界时钟。
		下一步就能编写客户端代码。RMI要求服务器和客户端共享同一个端口，因此将WorldClock.java接口文件复制到客户端，
		然后在客户端实现RMI调用：
			//Client客户端
			//NotBoundException不绑定异常
			//RemoteException远程异常
			public class Client {
				public static void main(String[] args) throws RemoteException, NotBoundException {
					// 连接到服务器localhost，端口1099:
					//LocateRegistry找到注册表
					//getRegistry获得注册表
					//将RMI端口号1099注册表信息使用Registry注册表类型接收
					Registry registry = LocateRegistry.getRegistry("localhost", 1099);
					// 查找名称为"WorldClock"的服务并强制转型为WorldClock接口:
					//lookup检查、查找
					WorldClock worldClock = (WorldClock) registry.lookup("WorldClock");
					// 正常调用接口方法:
					//WorldClock世界时间
					//getLocalDateTime获取本地日期时间，传入需要获取时间的地区以及城市(可能国家也行)
					//传入的Asia/Shanghai：Asia亚洲、上海
					LocalDateTime now = worldClock.getLocalDateTime("Asia/Shanghai");
					// 打印调用结果:
					//now显示查询地区当前时间，now现在
					System.out.println(now);}}
		先运行服务器再运行客户端。运行结果得知，客户端只有接口，并无实现类，因此客户端获得接口方法返回值实际上通过网络
		从服务器端获取的。整个过程，对客户端来说，其持有的WorldClock世界时间接口实际上对应一个实现类，是由Registry注册表
		内部动态生成，并负责将方法调用通过网络传递到服务器端。而服务器端接收网络调用服务并不是自己编写的WorldClockService
		世界时间服务，而是Registry自动生成代码。
		
		客户端的实现类称为stub(末节区域)，服务器端的网络服务类称为skeleton(骨架)，它会真正调用服务器端的WorldClockService
		(世界时间服务)获取结果，然后将结果通过网络传递给客户端。整个过程RMI底层负责实现序列化和反序列化：
			序列化：可理解为将java对象转换为字节序列的过程。
			反序列化：将字节序列恢复成java对象。
			序列化作用：作用是传递和保存对象时，保证对象的完整性和可传递性。将对象转为有序字节流方便再网络上传输或者保存再本地文件中。
			反序列化作用：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。
			总是核心的作用就是对象状态的保存与创建，核心过程就是字节流中保存的对象状态和描述信息。
			//Network网络
			//ClientStub客户端存根
			//Service服务
			//ServerSkeleton服务器框架
			//Service Impl 服务 、Impl：实现类，接口实现
			┌ ─ ─ ─ ─ ─ ─ ─ ─ ┐         ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
			  ┌─────────────┐                                 ┌─────────────┐
			│ │   Service   │ │         │                     │   Service   │ │
			  └─────────────┘                                 └─────────────┘
			│        ▲        │         │                            ▲        │
					 │                                               │
			│        │        │         │                            │        │
			  ┌─────────────┐   Network   ┌───────────────┐   ┌─────────────┐
			│ │ Client Stub ├─┼─────────┼>│Server Skeleton│──>│Service Impl │ │
			  └─────────────┘             └───────────────┘   └─────────────┘
			└ ─ ─ ─ ─ ─ ─ ─ ─ ┘         └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
		Java的RMI严重依赖序列化和反序列化，很可能造成严重的安全漏洞，因为Java序列化和反序列化不但涉及到数据，还涉及到二进制代码，
		即使使用白名单机制也难保证100%排除恶意构造的字节码。
		所以使用RMI时，双方必须是内网相互信任的机器，不要将1099端口暴露再公网上作对外服务。
		此外，Java的RMI调用机制决定双发必须是Java程序，其他语言难调用Java的RMI。如果使用不同语言进行RPC调用，可选择更通用的协议，如gRPC。
		RMI我们创建的Client还是Server的接口都是通过调用JVM创建的ClockClientStub和ClockServerStub通过网络连接进行远程调用。
			
		结：
			Java提供了RMI实现远程方法调用：
				RMI通过自动生成stub和skeleton实现网络调用，客户端只需要查找服务并获得接口实例，服务器端只需要编写实现类并注册为服务；

				RMI的序列化和反序列化可能会造成安全漏洞，因此调用双方必须是内网互相信任的机器，不要把1099端口暴露在公网上作为对外服务。	
			
			
XML与JSON：
	XML：可扩展性标记语言
	JSON：轻量级数据交换格式
	XML和JSON是经常在网络使用的数据表示格式。
	
	XML简介：
		XML是可扩展性标记语言(eXtensible MarkupLanguage)缩写，是一种数据表示格式，可描述非常复杂的数据结构，常用于传输和存储数据。
		一个XML文档例子：
			下面xml的标签有点电子书的感觉：
				version：版本。
				encoding：编码。
				DOCTYPE：文档类型。
				note：笔记、注释。
				system：系统。
				book：书。
				name：名字。
				author：作者。
				isbn：国际标准图书编号。 
				tags：标签标题、s是复数就是有多个的意思。
				tag：标题。
				pubDate：发布时间、出版时间。
				
			<?xml version="1.0" encoding="UTF-8" ?>
			<!DOCTYPE note SYSTEM "book.dtd">
			<book id="1">
				<name>Java核心技术</name>
				<author>Cay S. Horstmann</author>
				<isbn lang="CN">1234567</isbn>
				<tags>
					<tag>Java</tag>
					<tag>Network</tag>	</tags>	<pubDate/>	</book>
		XML的特点：
			纯文本，默认使用UTF-8编码。
			可嵌套，适合结构化数据。
			如果将XML内容存为文件，那么它就是一个XML文件，如Book.xml。
			XML经常通过网络作为消息传输。
		XML的结构：
			XML拥有固定结构，首行必定是<?xml version="1.0?>，可加上可选编码。
			如果类似<!DOCTYPE note SYSTEM "book.dtd">声明是文档定义类型(DTD:Document Type Definition),DTD是可选的。
			XML的文档内容，一个XML文档有且仅有一个根元素，根元素可包含任意一个子元素，元素可包含属性，如：
				<isbn lang="CN">1234567</isbn>包含一个属性lang="CN"，且元素必须正确嵌套。空元素可用<tag/>表示。
			使用<、>引号等标识符，如果内容出现特殊符号，则需要使用&???;表示转义。
				Java<tm>则是：<name>Java&lt;tm&gt;</name>
				常见特殊字符表达方式：
					<	%lt;
					>	&gt;
					&	&amp;
					"	&quot;
					'	&apos;
				格式正确的XML(Well Formed)是指XML格式正确的，可被解析器正常读取。合法的XML指，不但XML格式正确，并且
				其数据结构可被DTD或XSD验证。
			DTD文档可指定一系列规则：
				根元素必须是book。
				book元素必须包含name，author等指定元素，author作者。
				isbn元素必须包含属性lang。
			验证XML文件正确方式，最简单的是通过浏览器验证。可直接将XML文件拖拽到浏览器窗口，如果格式错误，浏览器会报错。
			与HTML不同，浏览器对HTML有一定的"容错性"，缺少关闭标签也能破解，但XML要求严格的格式，任何没有正确嵌套的标签
			都会导致错误。
			XML是一个技术体系，出了常用的XML文档本身外，XML还支持：
				DTD和XSD：验证XML结构和数据是否有效。
						  DTD：文件类型定义Document Type Definition。
						  XSD：定义语言。
				Namespace：XML节点和属性的名字空间。	//namespace空间名称
				XSLT：将XML转化为另一种文本。
				XPath：一种XML节点查询语言。	//path：路径。
			实际中xml的相关功能实现非常复杂很少用到。
		结：
			XML使用嵌套结构的数据表示方式，支持格式验证；
			XML常用于配置文件、网络消息传输等。
						
	使用DOM：Document Object Model文档对象模型
		XML是一种树形
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
	
	
	